// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingRequest {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_requested: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDiscoveryPingRequest {}

impl CDiscoveryPingRequest {
    pub fn new() -> CDiscoveryPingRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDiscoveryPingRequest {
        static mut instance: ::protobuf::lazy::Lazy<CDiscoveryPingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDiscoveryPingRequest,
        };
        unsafe {
            instance.get(CDiscoveryPingRequest::new)
        }
    }

    // optional uint32 sequence = 1;

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    fn get_sequence_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sequence
    }

    fn mut_sequence_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sequence
    }

    // optional uint32 packet_size_requested = 2;

    pub fn clear_packet_size_requested(&mut self) {
        self.packet_size_requested = ::std::option::Option::None;
    }

    pub fn has_packet_size_requested(&self) -> bool {
        self.packet_size_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_requested(&mut self, v: u32) {
        self.packet_size_requested = ::std::option::Option::Some(v);
    }

    pub fn get_packet_size_requested(&self) -> u32 {
        self.packet_size_requested.unwrap_or(0)
    }

    fn get_packet_size_requested_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.packet_size_requested
    }

    fn mut_packet_size_requested_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.packet_size_requested
    }
}

impl ::protobuf::Message for CDiscoveryPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.sequence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.packet_size_requested = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.packet_size_requested {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.packet_size_requested {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDiscoveryPingRequest {
    fn new() -> CDiscoveryPingRequest {
        CDiscoveryPingRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDiscoveryPingRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence",
                    CDiscoveryPingRequest::get_sequence_for_reflect,
                    CDiscoveryPingRequest::mut_sequence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "packet_size_requested",
                    CDiscoveryPingRequest::get_packet_size_requested_for_reflect,
                    CDiscoveryPingRequest::mut_packet_size_requested_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDiscoveryPingRequest>(
                    "CDiscoveryPingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDiscoveryPingRequest {
    fn clear(&mut self) {
        self.clear_sequence();
        self.clear_packet_size_requested();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingResponse {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_received: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDiscoveryPingResponse {}

impl CDiscoveryPingResponse {
    pub fn new() -> CDiscoveryPingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDiscoveryPingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CDiscoveryPingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDiscoveryPingResponse,
        };
        unsafe {
            instance.get(CDiscoveryPingResponse::new)
        }
    }

    // optional uint32 sequence = 1;

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    fn get_sequence_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sequence
    }

    fn mut_sequence_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sequence
    }

    // optional uint32 packet_size_received = 2;

    pub fn clear_packet_size_received(&mut self) {
        self.packet_size_received = ::std::option::Option::None;
    }

    pub fn has_packet_size_received(&self) -> bool {
        self.packet_size_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_received(&mut self, v: u32) {
        self.packet_size_received = ::std::option::Option::Some(v);
    }

    pub fn get_packet_size_received(&self) -> u32 {
        self.packet_size_received.unwrap_or(0)
    }

    fn get_packet_size_received_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.packet_size_received
    }

    fn mut_packet_size_received_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.packet_size_received
    }
}

impl ::protobuf::Message for CDiscoveryPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.sequence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.packet_size_received = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.packet_size_received {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.packet_size_received {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDiscoveryPingResponse {
    fn new() -> CDiscoveryPingResponse {
        CDiscoveryPingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDiscoveryPingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence",
                    CDiscoveryPingResponse::get_sequence_for_reflect,
                    CDiscoveryPingResponse::mut_sequence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "packet_size_received",
                    CDiscoveryPingResponse::get_packet_size_received_for_reflect,
                    CDiscoveryPingResponse::mut_packet_size_received_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDiscoveryPingResponse>(
                    "CDiscoveryPingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDiscoveryPingResponse {
    fn clear(&mut self) {
        self.clear_sequence();
        self.clear_packet_size_received();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientHandshakeInfo {
    // message fields
    network_test: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamingClientHandshakeInfo {}

impl CStreamingClientHandshakeInfo {
    pub fn new() -> CStreamingClientHandshakeInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamingClientHandshakeInfo {
        static mut instance: ::protobuf::lazy::Lazy<CStreamingClientHandshakeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamingClientHandshakeInfo,
        };
        unsafe {
            instance.get(CStreamingClientHandshakeInfo::new)
        }
    }

    // optional int32 network_test = 2;

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: i32) {
        self.network_test = ::std::option::Option::Some(v);
    }

    pub fn get_network_test(&self) -> i32 {
        self.network_test.unwrap_or(0)
    }

    fn get_network_test_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.network_test
    }

    fn mut_network_test_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.network_test
    }
}

impl ::protobuf::Message for CStreamingClientHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.network_test = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.network_test {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.network_test {
            os.write_int32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamingClientHandshakeInfo {
    fn new() -> CStreamingClientHandshakeInfo {
        CStreamingClientHandshakeInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamingClientHandshakeInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "network_test",
                    CStreamingClientHandshakeInfo::get_network_test_for_reflect,
                    CStreamingClientHandshakeInfo::mut_network_test_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientHandshakeInfo>(
                    "CStreamingClientHandshakeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamingClientHandshakeInfo {
    fn clear(&mut self) {
        self.clear_network_test();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientHandshakeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientHandshakeMsg {
    // message fields
    info: ::protobuf::SingularPtrField<CStreamingClientHandshakeInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CClientHandshakeMsg {}

impl CClientHandshakeMsg {
    pub fn new() -> CClientHandshakeMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CClientHandshakeMsg {
        static mut instance: ::protobuf::lazy::Lazy<CClientHandshakeMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientHandshakeMsg,
        };
        unsafe {
            instance.get(CClientHandshakeMsg::new)
        }
    }

    // required .CStreamingClientHandshakeInfo info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingClientHandshakeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingClientHandshakeInfo {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingClientHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingClientHandshakeInfo::new())
    }

    pub fn get_info(&self) -> &CStreamingClientHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| CStreamingClientHandshakeInfo::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CStreamingClientHandshakeInfo> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStreamingClientHandshakeInfo> {
        &mut self.info
    }
}

impl ::protobuf::Message for CClientHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CClientHandshakeMsg {
    fn new() -> CClientHandshakeMsg {
        CClientHandshakeMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CClientHandshakeMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientHandshakeInfo>>(
                    "info",
                    CClientHandshakeMsg::get_info_for_reflect,
                    CClientHandshakeMsg::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientHandshakeMsg>(
                    "CClientHandshakeMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CClientHandshakeMsg {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHandshakeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerHandshakeInfo {
    // message fields
    mtu: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamingServerHandshakeInfo {}

impl CStreamingServerHandshakeInfo {
    pub fn new() -> CStreamingServerHandshakeInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamingServerHandshakeInfo {
        static mut instance: ::protobuf::lazy::Lazy<CStreamingServerHandshakeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamingServerHandshakeInfo,
        };
        unsafe {
            instance.get(CStreamingServerHandshakeInfo::new)
        }
    }

    // optional int32 mtu = 1;

    pub fn clear_mtu(&mut self) {
        self.mtu = ::std::option::Option::None;
    }

    pub fn has_mtu(&self) -> bool {
        self.mtu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = ::std::option::Option::Some(v);
    }

    pub fn get_mtu(&self) -> i32 {
        self.mtu.unwrap_or(0)
    }

    fn get_mtu_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mtu
    }

    fn mut_mtu_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mtu
    }
}

impl ::protobuf::Message for CStreamingServerHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.mtu = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mtu {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mtu {
            os.write_int32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamingServerHandshakeInfo {
    fn new() -> CStreamingServerHandshakeInfo {
        CStreamingServerHandshakeInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamingServerHandshakeInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mtu",
                    CStreamingServerHandshakeInfo::get_mtu_for_reflect,
                    CStreamingServerHandshakeInfo::mut_mtu_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamingServerHandshakeInfo>(
                    "CStreamingServerHandshakeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamingServerHandshakeInfo {
    fn clear(&mut self) {
        self.clear_mtu();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerHandshakeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CServerHandshakeMsg {
    // message fields
    info: ::protobuf::SingularPtrField<CStreamingServerHandshakeInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CServerHandshakeMsg {}

impl CServerHandshakeMsg {
    pub fn new() -> CServerHandshakeMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CServerHandshakeMsg {
        static mut instance: ::protobuf::lazy::Lazy<CServerHandshakeMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CServerHandshakeMsg,
        };
        unsafe {
            instance.get(CServerHandshakeMsg::new)
        }
    }

    // required .CStreamingServerHandshakeInfo info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingServerHandshakeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingServerHandshakeInfo {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingServerHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingServerHandshakeInfo::new())
    }

    pub fn get_info(&self) -> &CStreamingServerHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| CStreamingServerHandshakeInfo::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CStreamingServerHandshakeInfo> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStreamingServerHandshakeInfo> {
        &mut self.info
    }
}

impl ::protobuf::Message for CServerHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CServerHandshakeMsg {
    fn new() -> CServerHandshakeMsg {
        CServerHandshakeMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CServerHandshakeMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingServerHandshakeInfo>>(
                    "info",
                    CServerHandshakeMsg::get_info_for_reflect,
                    CServerHandshakeMsg::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CServerHandshakeMsg>(
                    "CServerHandshakeMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CServerHandshakeMsg {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CServerHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CServerHandshakeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationRequestMsg {
    // message fields
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::std::option::Option<EStreamVersion>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAuthenticationRequestMsg {}

impl CAuthenticationRequestMsg {
    pub fn new() -> CAuthenticationRequestMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAuthenticationRequestMsg {
        static mut instance: ::protobuf::lazy::Lazy<CAuthenticationRequestMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAuthenticationRequestMsg,
        };
        unsafe {
            instance.get(CAuthenticationRequestMsg::new)
        }
    }

    // optional bytes token = 1;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        };
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_token_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.token
    }

    fn mut_token_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.token
    }

    // optional .EStreamVersion version = 2;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> EStreamVersion {
        self.version.unwrap_or(EStreamVersion::k_EStreamVersionNone)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<EStreamVersion> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamVersion> {
        &mut self.version
    }
}

impl ::protobuf::Message for CAuthenticationRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, &v)?;
        };
        if let Some(v) = self.version {
            os.write_enum(2, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAuthenticationRequestMsg {
    fn new() -> CAuthenticationRequestMsg {
        CAuthenticationRequestMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAuthenticationRequestMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "token",
                    CAuthenticationRequestMsg::get_token_for_reflect,
                    CAuthenticationRequestMsg::mut_token_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVersion>>(
                    "version",
                    CAuthenticationRequestMsg::get_version_for_reflect,
                    CAuthenticationRequestMsg::mut_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAuthenticationRequestMsg>(
                    "CAuthenticationRequestMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAuthenticationRequestMsg {
    fn clear(&mut self) {
        self.clear_token();
        self.clear_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationRequestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationResponseMsg {
    // message fields
    result: ::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult>,
    version: ::std::option::Option<EStreamVersion>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAuthenticationResponseMsg {}

impl CAuthenticationResponseMsg {
    pub fn new() -> CAuthenticationResponseMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAuthenticationResponseMsg {
        static mut instance: ::protobuf::lazy::Lazy<CAuthenticationResponseMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAuthenticationResponseMsg,
        };
        unsafe {
            instance.get(CAuthenticationResponseMsg::new)
        }
    }

    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CAuthenticationResponseMsg_AuthenticationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CAuthenticationResponseMsg_AuthenticationResult {
        self.result.unwrap_or(CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult> {
        &mut self.result
    }

    // optional .EStreamVersion version = 2;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> EStreamVersion {
        self.version.unwrap_or(EStreamVersion::k_EStreamVersionNone)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<EStreamVersion> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamVersion> {
        &mut self.version
    }
}

impl ::protobuf::Message for CAuthenticationResponseMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.version {
            os.write_enum(2, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAuthenticationResponseMsg {
    fn new() -> CAuthenticationResponseMsg {
        CAuthenticationResponseMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAuthenticationResponseMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CAuthenticationResponseMsg_AuthenticationResult>>(
                    "result",
                    CAuthenticationResponseMsg::get_result_for_reflect,
                    CAuthenticationResponseMsg::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVersion>>(
                    "version",
                    CAuthenticationResponseMsg::get_version_for_reflect,
                    CAuthenticationResponseMsg::mut_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAuthenticationResponseMsg>(
                    "CAuthenticationResponseMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAuthenticationResponseMsg {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationResponseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationResponseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CAuthenticationResponseMsg_AuthenticationResult {
    SUCCEEDED = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for CAuthenticationResponseMsg_AuthenticationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult> {
        match value {
            0 => ::std::option::Option::Some(CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED),
            1 => ::std::option::Option::Some(CAuthenticationResponseMsg_AuthenticationResult::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CAuthenticationResponseMsg_AuthenticationResult] = &[
            CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED,
            CAuthenticationResponseMsg_AuthenticationResult::FAILED,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<CAuthenticationResponseMsg_AuthenticationResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CAuthenticationResponseMsg_AuthenticationResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CAuthenticationResponseMsg_AuthenticationResult {
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationResponseMsg_AuthenticationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CKeepAliveMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CKeepAliveMsg {}

impl CKeepAliveMsg {
    pub fn new() -> CKeepAliveMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CKeepAliveMsg {
        static mut instance: ::protobuf::lazy::Lazy<CKeepAliveMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CKeepAliveMsg,
        };
        unsafe {
            instance.get(CKeepAliveMsg::new)
        }
    }
}

impl ::protobuf::Message for CKeepAliveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CKeepAliveMsg {
    fn new() -> CKeepAliveMsg {
        CKeepAliveMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CKeepAliveMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CKeepAliveMsg>(
                    "CKeepAliveMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CKeepAliveMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CKeepAliveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CKeepAliveMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartNetworkTestMsg {
    // message fields
    frames: ::std::option::Option<u32>,
    framerate: ::std::option::Option<u32>,
    bitrate_kbps: ::std::option::Option<u32>,
    burst_bitrate_kbps: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStartNetworkTestMsg {}

impl CStartNetworkTestMsg {
    pub fn new() -> CStartNetworkTestMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStartNetworkTestMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStartNetworkTestMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStartNetworkTestMsg,
        };
        unsafe {
            instance.get(CStartNetworkTestMsg::new)
        }
    }

    // optional uint32 frames = 1;

    pub fn clear_frames(&mut self) {
        self.frames = ::std::option::Option::None;
    }

    pub fn has_frames(&self) -> bool {
        self.frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: u32) {
        self.frames = ::std::option::Option::Some(v);
    }

    pub fn get_frames(&self) -> u32 {
        self.frames.unwrap_or(0)
    }

    fn get_frames_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.frames
    }

    fn mut_frames_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.frames
    }

    // optional uint32 framerate = 2;

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    fn get_framerate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.framerate
    }

    fn mut_framerate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.framerate
    }

    // optional uint32 bitrate_kbps = 3;

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: u32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    pub fn get_bitrate_kbps(&self) -> u32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    fn get_bitrate_kbps_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bitrate_kbps
    }

    fn mut_bitrate_kbps_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bitrate_kbps
    }

    // optional uint32 burst_bitrate_kbps = 4;

    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: u32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    pub fn get_burst_bitrate_kbps(&self) -> u32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }

    fn get_burst_bitrate_kbps_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.burst_bitrate_kbps
    }

    fn mut_burst_bitrate_kbps_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.burst_bitrate_kbps
    }
}

impl ::protobuf::Message for CStartNetworkTestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.frames = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.framerate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.burst_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frames {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frames {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.bitrate_kbps {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_uint32(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStartNetworkTestMsg {
    fn new() -> CStartNetworkTestMsg {
        CStartNetworkTestMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStartNetworkTestMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frames",
                    CStartNetworkTestMsg::get_frames_for_reflect,
                    CStartNetworkTestMsg::mut_frames_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "framerate",
                    CStartNetworkTestMsg::get_framerate_for_reflect,
                    CStartNetworkTestMsg::mut_framerate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bitrate_kbps",
                    CStartNetworkTestMsg::get_bitrate_kbps_for_reflect,
                    CStartNetworkTestMsg::mut_bitrate_kbps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "burst_bitrate_kbps",
                    CStartNetworkTestMsg::get_burst_bitrate_kbps_for_reflect,
                    CStartNetworkTestMsg::mut_burst_bitrate_kbps_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStartNetworkTestMsg>(
                    "CStartNetworkTestMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStartNetworkTestMsg {
    fn clear(&mut self) {
        self.clear_frames();
        self.clear_framerate();
        self.clear_bitrate_kbps();
        self.clear_burst_bitrate_kbps();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartNetworkTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartNetworkTestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamVideoMode {
    // message fields
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    refresh_rate: ::std::option::Option<u32>,
    refresh_rate_numerator: ::std::option::Option<u32>,
    refresh_rate_denominator: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamVideoMode {}

impl CStreamVideoMode {
    pub fn new() -> CStreamVideoMode {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamVideoMode {
        static mut instance: ::protobuf::lazy::Lazy<CStreamVideoMode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamVideoMode,
        };
        unsafe {
            instance.get(CStreamVideoMode::new)
        }
    }

    // required uint32 width = 1;

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    fn get_width_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.width
    }

    fn mut_width_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.width
    }

    // required uint32 height = 2;

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    fn get_height_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.height
    }

    fn mut_height_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.height
    }

    // optional uint32 refresh_rate = 3;

    pub fn clear_refresh_rate(&mut self) {
        self.refresh_rate = ::std::option::Option::None;
    }

    pub fn has_refresh_rate(&self) -> bool {
        self.refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate(&mut self, v: u32) {
        self.refresh_rate = ::std::option::Option::Some(v);
    }

    pub fn get_refresh_rate(&self) -> u32 {
        self.refresh_rate.unwrap_or(0)
    }

    fn get_refresh_rate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.refresh_rate
    }

    fn mut_refresh_rate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.refresh_rate
    }

    // optional uint32 refresh_rate_numerator = 4;

    pub fn clear_refresh_rate_numerator(&mut self) {
        self.refresh_rate_numerator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_numerator(&self) -> bool {
        self.refresh_rate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_numerator(&mut self, v: u32) {
        self.refresh_rate_numerator = ::std::option::Option::Some(v);
    }

    pub fn get_refresh_rate_numerator(&self) -> u32 {
        self.refresh_rate_numerator.unwrap_or(0)
    }

    fn get_refresh_rate_numerator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.refresh_rate_numerator
    }

    fn mut_refresh_rate_numerator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.refresh_rate_numerator
    }

    // optional uint32 refresh_rate_denominator = 5;

    pub fn clear_refresh_rate_denominator(&mut self) {
        self.refresh_rate_denominator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_denominator(&self) -> bool {
        self.refresh_rate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_denominator(&mut self, v: u32) {
        self.refresh_rate_denominator = ::std::option::Option::Some(v);
    }

    pub fn get_refresh_rate_denominator(&self) -> u32 {
        self.refresh_rate_denominator.unwrap_or(0)
    }

    fn get_refresh_rate_denominator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.refresh_rate_denominator
    }

    fn mut_refresh_rate_denominator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.refresh_rate_denominator
    }
}

impl ::protobuf::Message for CStreamVideoMode {
    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        };
        if self.height.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.refresh_rate = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.refresh_rate_numerator = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.refresh_rate_denominator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.refresh_rate {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.refresh_rate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.refresh_rate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.refresh_rate {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.refresh_rate_numerator {
            os.write_uint32(4, v)?;
        };
        if let Some(v) = self.refresh_rate_denominator {
            os.write_uint32(5, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamVideoMode {
    fn new() -> CStreamVideoMode {
        CStreamVideoMode::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamVideoMode>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    CStreamVideoMode::get_width_for_reflect,
                    CStreamVideoMode::mut_width_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    CStreamVideoMode::get_height_for_reflect,
                    CStreamVideoMode::mut_height_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "refresh_rate",
                    CStreamVideoMode::get_refresh_rate_for_reflect,
                    CStreamVideoMode::mut_refresh_rate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "refresh_rate_numerator",
                    CStreamVideoMode::get_refresh_rate_numerator_for_reflect,
                    CStreamVideoMode::mut_refresh_rate_numerator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "refresh_rate_denominator",
                    CStreamVideoMode::get_refresh_rate_denominator_for_reflect,
                    CStreamVideoMode::mut_refresh_rate_denominator_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamVideoMode>(
                    "CStreamVideoMode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamVideoMode {
    fn clear(&mut self) {
        self.clear_width();
        self.clear_height();
        self.clear_refresh_rate();
        self.clear_refresh_rate_numerator();
        self.clear_refresh_rate_denominator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamVideoMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamVideoMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientCaps {
    // message fields
    system_info: ::protobuf::SingularField<::std::string::String>,
    system_can_suspend: ::std::option::Option<bool>,
    maximum_decode_bitrate_kbps: ::std::option::Option<i32>,
    maximum_burst_bitrate_kbps: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamingClientCaps {}

impl CStreamingClientCaps {
    pub fn new() -> CStreamingClientCaps {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamingClientCaps {
        static mut instance: ::protobuf::lazy::Lazy<CStreamingClientCaps> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamingClientCaps,
        };
        unsafe {
            instance.get(CStreamingClientCaps::new)
        }
    }

    // optional string system_info = 1;

    pub fn clear_system_info(&mut self) {
        self.system_info.clear();
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::string::String) {
        self.system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::string::String {
        if self.system_info.is_none() {
            self.system_info.set_default();
        };
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::string::String {
        self.system_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_system_info(&self) -> &str {
        match self.system_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_system_info_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.system_info
    }

    fn mut_system_info_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.system_info
    }

    // optional bool system_can_suspend = 2;

    pub fn clear_system_can_suspend(&mut self) {
        self.system_can_suspend = ::std::option::Option::None;
    }

    pub fn has_system_can_suspend(&self) -> bool {
        self.system_can_suspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_can_suspend(&mut self, v: bool) {
        self.system_can_suspend = ::std::option::Option::Some(v);
    }

    pub fn get_system_can_suspend(&self) -> bool {
        self.system_can_suspend.unwrap_or(false)
    }

    fn get_system_can_suspend_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.system_can_suspend
    }

    fn mut_system_can_suspend_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.system_can_suspend
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;

    pub fn clear_maximum_decode_bitrate_kbps(&mut self) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_decode_bitrate_kbps(&self) -> bool {
        self.maximum_decode_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_decode_bitrate_kbps(&mut self, v: i32) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_decode_bitrate_kbps(&self) -> i32 {
        self.maximum_decode_bitrate_kbps.unwrap_or(0)
    }

    fn get_maximum_decode_bitrate_kbps_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maximum_decode_bitrate_kbps
    }

    fn mut_maximum_decode_bitrate_kbps_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maximum_decode_bitrate_kbps
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;

    pub fn clear_maximum_burst_bitrate_kbps(&mut self) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_burst_bitrate_kbps(&self) -> bool {
        self.maximum_burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_burst_bitrate_kbps(&mut self, v: i32) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_burst_bitrate_kbps(&self) -> i32 {
        self.maximum_burst_bitrate_kbps.unwrap_or(0)
    }

    fn get_maximum_burst_bitrate_kbps_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maximum_burst_bitrate_kbps
    }

    fn mut_maximum_burst_bitrate_kbps_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maximum_burst_bitrate_kbps
    }
}

impl ::protobuf::Message for CStreamingClientCaps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.system_can_suspend = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        if let Some(v) = self.system_can_suspend {
            my_size += 2;
        };
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.system_info.as_ref() {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.system_can_suspend {
            os.write_bool(2, v)?;
        };
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            os.write_int32(3, v)?;
        };
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            os.write_int32(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamingClientCaps {
    fn new() -> CStreamingClientCaps {
        CStreamingClientCaps::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamingClientCaps>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "system_info",
                    CStreamingClientCaps::get_system_info_for_reflect,
                    CStreamingClientCaps::mut_system_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "system_can_suspend",
                    CStreamingClientCaps::get_system_can_suspend_for_reflect,
                    CStreamingClientCaps::mut_system_can_suspend_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maximum_decode_bitrate_kbps",
                    CStreamingClientCaps::get_maximum_decode_bitrate_kbps_for_reflect,
                    CStreamingClientCaps::mut_maximum_decode_bitrate_kbps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maximum_burst_bitrate_kbps",
                    CStreamingClientCaps::get_maximum_burst_bitrate_kbps_for_reflect,
                    CStreamingClientCaps::mut_maximum_burst_bitrate_kbps_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientCaps>(
                    "CStreamingClientCaps",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamingClientCaps {
    fn clear(&mut self) {
        self.clear_system_info();
        self.clear_system_can_suspend();
        self.clear_maximum_decode_bitrate_kbps();
        self.clear_maximum_burst_bitrate_kbps();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientCaps {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientConfig {
    // message fields
    quality: ::std::option::Option<EStreamQualityPreference>,
    maximum_resolution_x: ::std::option::Option<u32>,
    maximum_resolution_y: ::std::option::Option<u32>,
    maximum_framerate_numerator: ::std::option::Option<u32>,
    maximum_framerate_denominator: ::std::option::Option<u32>,
    maximum_bitrate_kbps: ::std::option::Option<i32>,
    enable_hardware_decoding: ::std::option::Option<bool>,
    enable_performance_overlay: ::std::option::Option<bool>,
    enable_video_streaming: ::std::option::Option<bool>,
    enable_audio_streaming: ::std::option::Option<bool>,
    enable_input_streaming: ::std::option::Option<bool>,
    audio_channels: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamingClientConfig {}

impl CStreamingClientConfig {
    pub fn new() -> CStreamingClientConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamingClientConfig {
        static mut instance: ::protobuf::lazy::Lazy<CStreamingClientConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamingClientConfig,
        };
        unsafe {
            instance.get(CStreamingClientConfig::new)
        }
    }

    // optional .EStreamQualityPreference quality = 1;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: EStreamQualityPreference) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> EStreamQualityPreference {
        self.quality.unwrap_or(EStreamQualityPreference::k_EStreamQualityBalanced)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<EStreamQualityPreference> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamQualityPreference> {
        &mut self.quality
    }

    // optional uint32 maximum_resolution_x = 2;

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: u32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_resolution_x(&self) -> u32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    fn get_maximum_resolution_x_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maximum_resolution_x
    }

    fn mut_maximum_resolution_x_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maximum_resolution_x
    }

    // optional uint32 maximum_resolution_y = 3;

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: u32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_resolution_y(&self) -> u32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    fn get_maximum_resolution_y_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maximum_resolution_y
    }

    fn mut_maximum_resolution_y_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maximum_resolution_y
    }

    // optional uint32 maximum_framerate_numerator = 4;

    pub fn clear_maximum_framerate_numerator(&mut self) {
        self.maximum_framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_numerator(&self) -> bool {
        self.maximum_framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_numerator(&mut self, v: u32) {
        self.maximum_framerate_numerator = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_framerate_numerator(&self) -> u32 {
        self.maximum_framerate_numerator.unwrap_or(0)
    }

    fn get_maximum_framerate_numerator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maximum_framerate_numerator
    }

    fn mut_maximum_framerate_numerator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maximum_framerate_numerator
    }

    // optional uint32 maximum_framerate_denominator = 5;

    pub fn clear_maximum_framerate_denominator(&mut self) {
        self.maximum_framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_denominator(&self) -> bool {
        self.maximum_framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_denominator(&mut self, v: u32) {
        self.maximum_framerate_denominator = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_framerate_denominator(&self) -> u32 {
        self.maximum_framerate_denominator.unwrap_or(0)
    }

    fn get_maximum_framerate_denominator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.maximum_framerate_denominator
    }

    fn mut_maximum_framerate_denominator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.maximum_framerate_denominator
    }

    // optional int32 maximum_bitrate_kbps = 6;

    pub fn clear_maximum_bitrate_kbps(&mut self) {
        self.maximum_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_bitrate_kbps(&self) -> bool {
        self.maximum_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_bitrate_kbps(&mut self, v: i32) {
        self.maximum_bitrate_kbps = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_bitrate_kbps(&self) -> i32 {
        self.maximum_bitrate_kbps.unwrap_or(-1i32)
    }

    fn get_maximum_bitrate_kbps_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maximum_bitrate_kbps
    }

    fn mut_maximum_bitrate_kbps_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maximum_bitrate_kbps
    }

    // optional bool enable_hardware_decoding = 7;

    pub fn clear_enable_hardware_decoding(&mut self) {
        self.enable_hardware_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_decoding(&mut self, v: bool) {
        self.enable_hardware_decoding = ::std::option::Option::Some(v);
    }

    pub fn get_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.unwrap_or(true)
    }

    fn get_enable_hardware_decoding_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_hardware_decoding
    }

    fn mut_enable_hardware_decoding_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_hardware_decoding
    }

    // optional bool enable_performance_overlay = 8;

    pub fn clear_enable_performance_overlay(&mut self) {
        self.enable_performance_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_overlay(&mut self, v: bool) {
        self.enable_performance_overlay = ::std::option::Option::Some(v);
    }

    pub fn get_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.unwrap_or(false)
    }

    fn get_enable_performance_overlay_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_performance_overlay
    }

    fn mut_enable_performance_overlay_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_performance_overlay
    }

    // optional bool enable_video_streaming = 9;

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    pub fn get_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    fn get_enable_video_streaming_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_video_streaming
    }

    fn mut_enable_video_streaming_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_video_streaming
    }

    // optional bool enable_audio_streaming = 10;

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    pub fn get_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    fn get_enable_audio_streaming_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_audio_streaming
    }

    fn mut_enable_audio_streaming_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_audio_streaming
    }

    // optional bool enable_input_streaming = 11;

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    pub fn get_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    fn get_enable_input_streaming_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_input_streaming
    }

    fn mut_enable_input_streaming_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_input_streaming
    }

    // optional int32 audio_channels = 12;

    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    pub fn get_audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(2i32)
    }

    fn get_audio_channels_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.audio_channels
    }

    fn mut_audio_channels_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.audio_channels
    }
}

impl ::protobuf::Message for CStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.maximum_resolution_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.maximum_resolution_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.maximum_framerate_numerator = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.maximum_framerate_denominator = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.maximum_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_hardware_decoding = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_performance_overlay = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_video_streaming = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_audio_streaming = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_input_streaming = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.audio_channels = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.maximum_framerate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.maximum_framerate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.maximum_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.enable_hardware_decoding {
            my_size += 2;
        };
        if let Some(v) = self.enable_performance_overlay {
            my_size += 2;
        };
        if let Some(v) = self.enable_video_streaming {
            my_size += 2;
        };
        if let Some(v) = self.enable_audio_streaming {
            my_size += 2;
        };
        if let Some(v) = self.enable_input_streaming {
            my_size += 2;
        };
        if let Some(v) = self.audio_channels {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quality {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.maximum_resolution_x {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.maximum_resolution_y {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.maximum_framerate_numerator {
            os.write_uint32(4, v)?;
        };
        if let Some(v) = self.maximum_framerate_denominator {
            os.write_uint32(5, v)?;
        };
        if let Some(v) = self.maximum_bitrate_kbps {
            os.write_int32(6, v)?;
        };
        if let Some(v) = self.enable_hardware_decoding {
            os.write_bool(7, v)?;
        };
        if let Some(v) = self.enable_performance_overlay {
            os.write_bool(8, v)?;
        };
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        };
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        };
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        };
        if let Some(v) = self.audio_channels {
            os.write_int32(12, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamingClientConfig {
    fn new() -> CStreamingClientConfig {
        CStreamingClientConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamingClientConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamQualityPreference>>(
                    "quality",
                    CStreamingClientConfig::get_quality_for_reflect,
                    CStreamingClientConfig::mut_quality_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_resolution_x",
                    CStreamingClientConfig::get_maximum_resolution_x_for_reflect,
                    CStreamingClientConfig::mut_maximum_resolution_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_resolution_y",
                    CStreamingClientConfig::get_maximum_resolution_y_for_reflect,
                    CStreamingClientConfig::mut_maximum_resolution_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_framerate_numerator",
                    CStreamingClientConfig::get_maximum_framerate_numerator_for_reflect,
                    CStreamingClientConfig::mut_maximum_framerate_numerator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_framerate_denominator",
                    CStreamingClientConfig::get_maximum_framerate_denominator_for_reflect,
                    CStreamingClientConfig::mut_maximum_framerate_denominator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maximum_bitrate_kbps",
                    CStreamingClientConfig::get_maximum_bitrate_kbps_for_reflect,
                    CStreamingClientConfig::mut_maximum_bitrate_kbps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_hardware_decoding",
                    CStreamingClientConfig::get_enable_hardware_decoding_for_reflect,
                    CStreamingClientConfig::mut_enable_hardware_decoding_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_performance_overlay",
                    CStreamingClientConfig::get_enable_performance_overlay_for_reflect,
                    CStreamingClientConfig::mut_enable_performance_overlay_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_video_streaming",
                    CStreamingClientConfig::get_enable_video_streaming_for_reflect,
                    CStreamingClientConfig::mut_enable_video_streaming_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_audio_streaming",
                    CStreamingClientConfig::get_enable_audio_streaming_for_reflect,
                    CStreamingClientConfig::mut_enable_audio_streaming_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_input_streaming",
                    CStreamingClientConfig::get_enable_input_streaming_for_reflect,
                    CStreamingClientConfig::mut_enable_input_streaming_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "audio_channels",
                    CStreamingClientConfig::get_audio_channels_for_reflect,
                    CStreamingClientConfig::mut_audio_channels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientConfig>(
                    "CStreamingClientConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamingClientConfig {
    fn clear(&mut self) {
        self.clear_quality();
        self.clear_maximum_resolution_x();
        self.clear_maximum_resolution_y();
        self.clear_maximum_framerate_numerator();
        self.clear_maximum_framerate_denominator();
        self.clear_maximum_bitrate_kbps();
        self.clear_enable_hardware_decoding();
        self.clear_enable_performance_overlay();
        self.clear_enable_video_streaming();
        self.clear_enable_audio_streaming();
        self.clear_enable_input_streaming();
        self.clear_audio_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerConfig {
    // message fields
    enable_hardware_encoding_nvidia: ::std::option::Option<bool>,
    enable_hardware_encoding_nvfbc_h264: ::std::option::Option<bool>,
    enable_hardware_encoding_amd: ::std::option::Option<bool>,
    enable_hardware_encoding_intel: ::std::option::Option<bool>,
    software_encoding_threads: ::std::option::Option<i32>,
    dynamically_adjust_resolution: ::std::option::Option<bool>,
    enable_traffic_priority: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamingServerConfig {}

impl CStreamingServerConfig {
    pub fn new() -> CStreamingServerConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamingServerConfig {
        static mut instance: ::protobuf::lazy::Lazy<CStreamingServerConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamingServerConfig,
        };
        unsafe {
            instance.get(CStreamingServerConfig::new)
        }
    }

    // optional bool enable_hardware_encoding_nvidia = 1;

    pub fn clear_enable_hardware_encoding_nvidia(&mut self) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvidia(&mut self, v: bool) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(v);
    }

    pub fn get_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.unwrap_or(false)
    }

    fn get_enable_hardware_encoding_nvidia_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_hardware_encoding_nvidia
    }

    fn mut_enable_hardware_encoding_nvidia_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_hardware_encoding_nvidia
    }

    // optional bool enable_hardware_encoding_nvfbc_h264 = 2;

    pub fn clear_enable_hardware_encoding_nvfbc_h264(&mut self) {
        self.enable_hardware_encoding_nvfbc_h264 = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvfbc_h264(&self) -> bool {
        self.enable_hardware_encoding_nvfbc_h264.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvfbc_h264(&mut self, v: bool) {
        self.enable_hardware_encoding_nvfbc_h264 = ::std::option::Option::Some(v);
    }

    pub fn get_enable_hardware_encoding_nvfbc_h264(&self) -> bool {
        self.enable_hardware_encoding_nvfbc_h264.unwrap_or(false)
    }

    fn get_enable_hardware_encoding_nvfbc_h264_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_hardware_encoding_nvfbc_h264
    }

    fn mut_enable_hardware_encoding_nvfbc_h264_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_hardware_encoding_nvfbc_h264
    }

    // optional bool enable_hardware_encoding_amd = 3;

    pub fn clear_enable_hardware_encoding_amd(&mut self) {
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_amd(&mut self, v: bool) {
        self.enable_hardware_encoding_amd = ::std::option::Option::Some(v);
    }

    pub fn get_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.unwrap_or(false)
    }

    fn get_enable_hardware_encoding_amd_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_hardware_encoding_amd
    }

    fn mut_enable_hardware_encoding_amd_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_hardware_encoding_amd
    }

    // optional bool enable_hardware_encoding_intel = 4;

    pub fn clear_enable_hardware_encoding_intel(&mut self) {
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_intel(&mut self, v: bool) {
        self.enable_hardware_encoding_intel = ::std::option::Option::Some(v);
    }

    pub fn get_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.unwrap_or(false)
    }

    fn get_enable_hardware_encoding_intel_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_hardware_encoding_intel
    }

    fn mut_enable_hardware_encoding_intel_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_hardware_encoding_intel
    }

    // optional int32 software_encoding_threads = 5;

    pub fn clear_software_encoding_threads(&mut self) {
        self.software_encoding_threads = ::std::option::Option::None;
    }

    pub fn has_software_encoding_threads(&self) -> bool {
        self.software_encoding_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_software_encoding_threads(&mut self, v: i32) {
        self.software_encoding_threads = ::std::option::Option::Some(v);
    }

    pub fn get_software_encoding_threads(&self) -> i32 {
        self.software_encoding_threads.unwrap_or(0)
    }

    fn get_software_encoding_threads_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.software_encoding_threads
    }

    fn mut_software_encoding_threads_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.software_encoding_threads
    }

    // optional bool dynamically_adjust_resolution = 6;

    pub fn clear_dynamically_adjust_resolution(&mut self) {
        self.dynamically_adjust_resolution = ::std::option::Option::None;
    }

    pub fn has_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamically_adjust_resolution(&mut self, v: bool) {
        self.dynamically_adjust_resolution = ::std::option::Option::Some(v);
    }

    pub fn get_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.unwrap_or(false)
    }

    fn get_dynamically_adjust_resolution_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.dynamically_adjust_resolution
    }

    fn mut_dynamically_adjust_resolution_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.dynamically_adjust_resolution
    }

    // optional bool enable_traffic_priority = 7;

    pub fn clear_enable_traffic_priority(&mut self) {
        self.enable_traffic_priority = ::std::option::Option::None;
    }

    pub fn has_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_traffic_priority(&mut self, v: bool) {
        self.enable_traffic_priority = ::std::option::Option::Some(v);
    }

    pub fn get_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.unwrap_or(false)
    }

    fn get_enable_traffic_priority_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable_traffic_priority
    }

    fn mut_enable_traffic_priority_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable_traffic_priority
    }
}

impl ::protobuf::Message for CStreamingServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_nvfbc_h264 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_amd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_intel = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.software_encoding_threads = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.dynamically_adjust_resolution = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enable_traffic_priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            my_size += 2;
        };
        if let Some(v) = self.enable_hardware_encoding_nvfbc_h264 {
            my_size += 2;
        };
        if let Some(v) = self.enable_hardware_encoding_amd {
            my_size += 2;
        };
        if let Some(v) = self.enable_hardware_encoding_intel {
            my_size += 2;
        };
        if let Some(v) = self.software_encoding_threads {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.dynamically_adjust_resolution {
            my_size += 2;
        };
        if let Some(v) = self.enable_traffic_priority {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            os.write_bool(1, v)?;
        };
        if let Some(v) = self.enable_hardware_encoding_nvfbc_h264 {
            os.write_bool(2, v)?;
        };
        if let Some(v) = self.enable_hardware_encoding_amd {
            os.write_bool(3, v)?;
        };
        if let Some(v) = self.enable_hardware_encoding_intel {
            os.write_bool(4, v)?;
        };
        if let Some(v) = self.software_encoding_threads {
            os.write_int32(5, v)?;
        };
        if let Some(v) = self.dynamically_adjust_resolution {
            os.write_bool(6, v)?;
        };
        if let Some(v) = self.enable_traffic_priority {
            os.write_bool(7, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamingServerConfig {
    fn new() -> CStreamingServerConfig {
        CStreamingServerConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamingServerConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_hardware_encoding_nvidia",
                    CStreamingServerConfig::get_enable_hardware_encoding_nvidia_for_reflect,
                    CStreamingServerConfig::mut_enable_hardware_encoding_nvidia_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_hardware_encoding_nvfbc_h264",
                    CStreamingServerConfig::get_enable_hardware_encoding_nvfbc_h264_for_reflect,
                    CStreamingServerConfig::mut_enable_hardware_encoding_nvfbc_h264_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_hardware_encoding_amd",
                    CStreamingServerConfig::get_enable_hardware_encoding_amd_for_reflect,
                    CStreamingServerConfig::mut_enable_hardware_encoding_amd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_hardware_encoding_intel",
                    CStreamingServerConfig::get_enable_hardware_encoding_intel_for_reflect,
                    CStreamingServerConfig::mut_enable_hardware_encoding_intel_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "software_encoding_threads",
                    CStreamingServerConfig::get_software_encoding_threads_for_reflect,
                    CStreamingServerConfig::mut_software_encoding_threads_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dynamically_adjust_resolution",
                    CStreamingServerConfig::get_dynamically_adjust_resolution_for_reflect,
                    CStreamingServerConfig::mut_dynamically_adjust_resolution_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_traffic_priority",
                    CStreamingServerConfig::get_enable_traffic_priority_for_reflect,
                    CStreamingServerConfig::mut_enable_traffic_priority_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamingServerConfig>(
                    "CStreamingServerConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamingServerConfig {
    fn clear(&mut self) {
        self.clear_enable_hardware_encoding_nvidia();
        self.clear_enable_hardware_encoding_nvfbc_h264();
        self.clear_enable_hardware_encoding_amd();
        self.clear_enable_hardware_encoding_intel();
        self.clear_software_encoding_threads();
        self.clear_dynamically_adjust_resolution();
        self.clear_enable_traffic_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiatedConfig {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    selected_audio_codec: ::std::option::Option<EStreamAudioCodec>,
    selected_video_codec: ::std::option::Option<EStreamVideoCodec>,
    available_video_modes: ::protobuf::RepeatedField<CStreamVideoMode>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CNegotiatedConfig {}

impl CNegotiatedConfig {
    pub fn new() -> CNegotiatedConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNegotiatedConfig {
        static mut instance: ::protobuf::lazy::Lazy<CNegotiatedConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CNegotiatedConfig,
        };
        unsafe {
            instance.get(CNegotiatedConfig::new)
        }
    }

    // optional bool reliable_data = 1;

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    fn get_reliable_data_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.reliable_data
    }

    fn mut_reliable_data_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.reliable_data
    }

    // optional .EStreamAudioCodec selected_audio_codec = 2;

    pub fn clear_selected_audio_codec(&mut self) {
        self.selected_audio_codec = ::std::option::Option::None;
    }

    pub fn has_selected_audio_codec(&self) -> bool {
        self.selected_audio_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_audio_codec(&mut self, v: EStreamAudioCodec) {
        self.selected_audio_codec = ::std::option::Option::Some(v);
    }

    pub fn get_selected_audio_codec(&self) -> EStreamAudioCodec {
        self.selected_audio_codec.unwrap_or(EStreamAudioCodec::k_EStreamAudioCodecNone)
    }

    fn get_selected_audio_codec_for_reflect(&self) -> &::std::option::Option<EStreamAudioCodec> {
        &self.selected_audio_codec
    }

    fn mut_selected_audio_codec_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamAudioCodec> {
        &mut self.selected_audio_codec
    }

    // optional .EStreamVideoCodec selected_video_codec = 3;

    pub fn clear_selected_video_codec(&mut self) {
        self.selected_video_codec = ::std::option::Option::None;
    }

    pub fn has_selected_video_codec(&self) -> bool {
        self.selected_video_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_video_codec(&mut self, v: EStreamVideoCodec) {
        self.selected_video_codec = ::std::option::Option::Some(v);
    }

    pub fn get_selected_video_codec(&self) -> EStreamVideoCodec {
        self.selected_video_codec.unwrap_or(EStreamVideoCodec::k_EStreamVideoCodecNone)
    }

    fn get_selected_video_codec_for_reflect(&self) -> &::std::option::Option<EStreamVideoCodec> {
        &self.selected_video_codec
    }

    fn mut_selected_video_codec_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamVideoCodec> {
        &mut self.selected_video_codec
    }

    // repeated .CStreamVideoMode available_video_modes = 4;

    pub fn clear_available_video_modes(&mut self) {
        self.available_video_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_video_modes(&mut self, v: ::protobuf::RepeatedField<CStreamVideoMode>) {
        self.available_video_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_video_modes(&mut self) -> &mut ::protobuf::RepeatedField<CStreamVideoMode> {
        &mut self.available_video_modes
    }

    // Take field
    pub fn take_available_video_modes(&mut self) -> ::protobuf::RepeatedField<CStreamVideoMode> {
        ::std::mem::replace(&mut self.available_video_modes, ::protobuf::RepeatedField::new())
    }

    pub fn get_available_video_modes(&self) -> &[CStreamVideoMode] {
        &self.available_video_modes
    }

    fn get_available_video_modes_for_reflect(&self) -> &::protobuf::RepeatedField<CStreamVideoMode> {
        &self.available_video_modes
    }

    fn mut_available_video_modes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CStreamVideoMode> {
        &mut self.available_video_modes
    }
}

impl ::protobuf::Message for CNegotiatedConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.reliable_data = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.selected_audio_codec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.selected_video_codec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.available_video_modes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        };
        if let Some(v) = self.selected_audio_codec {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        if let Some(v) = self.selected_video_codec {
            my_size += ::protobuf::rt::enum_size(3, v);
        };
        for value in &self.available_video_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        };
        if let Some(v) = self.selected_audio_codec {
            os.write_enum(2, v.value())?;
        };
        if let Some(v) = self.selected_video_codec {
            os.write_enum(3, v.value())?;
        };
        for v in &self.available_video_modes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CNegotiatedConfig {
    fn new() -> CNegotiatedConfig {
        CNegotiatedConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<CNegotiatedConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reliable_data",
                    CNegotiatedConfig::get_reliable_data_for_reflect,
                    CNegotiatedConfig::mut_reliable_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                    "selected_audio_codec",
                    CNegotiatedConfig::get_selected_audio_codec_for_reflect,
                    CNegotiatedConfig::mut_selected_audio_codec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                    "selected_video_codec",
                    CNegotiatedConfig::get_selected_video_codec_for_reflect,
                    CNegotiatedConfig::mut_selected_video_codec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamVideoMode>>(
                    "available_video_modes",
                    CNegotiatedConfig::get_available_video_modes_for_reflect,
                    CNegotiatedConfig::mut_available_video_modes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CNegotiatedConfig>(
                    "CNegotiatedConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CNegotiatedConfig {
    fn clear(&mut self) {
        self.clear_reliable_data();
        self.clear_selected_audio_codec();
        self.clear_selected_video_codec();
        self.clear_available_video_modes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiatedConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiatedConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationInitMsg {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    supported_audio_codecs: ::std::vec::Vec<EStreamAudioCodec>,
    supported_video_codecs: ::std::vec::Vec<EStreamVideoCodec>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CNegotiationInitMsg {}

impl CNegotiationInitMsg {
    pub fn new() -> CNegotiationInitMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNegotiationInitMsg {
        static mut instance: ::protobuf::lazy::Lazy<CNegotiationInitMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CNegotiationInitMsg,
        };
        unsafe {
            instance.get(CNegotiationInitMsg::new)
        }
    }

    // optional bool reliable_data = 1;

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    fn get_reliable_data_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.reliable_data
    }

    fn mut_reliable_data_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.reliable_data
    }

    // repeated .EStreamAudioCodec supported_audio_codecs = 2;

    pub fn clear_supported_audio_codecs(&mut self) {
        self.supported_audio_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_audio_codecs(&mut self, v: ::std::vec::Vec<EStreamAudioCodec>) {
        self.supported_audio_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_audio_codecs(&mut self) -> &mut ::std::vec::Vec<EStreamAudioCodec> {
        &mut self.supported_audio_codecs
    }

    // Take field
    pub fn take_supported_audio_codecs(&mut self) -> ::std::vec::Vec<EStreamAudioCodec> {
        ::std::mem::replace(&mut self.supported_audio_codecs, ::std::vec::Vec::new())
    }

    pub fn get_supported_audio_codecs(&self) -> &[EStreamAudioCodec] {
        &self.supported_audio_codecs
    }

    fn get_supported_audio_codecs_for_reflect(&self) -> &::std::vec::Vec<EStreamAudioCodec> {
        &self.supported_audio_codecs
    }

    fn mut_supported_audio_codecs_for_reflect(&mut self) -> &mut ::std::vec::Vec<EStreamAudioCodec> {
        &mut self.supported_audio_codecs
    }

    // repeated .EStreamVideoCodec supported_video_codecs = 3;

    pub fn clear_supported_video_codecs(&mut self) {
        self.supported_video_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_video_codecs(&mut self, v: ::std::vec::Vec<EStreamVideoCodec>) {
        self.supported_video_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_video_codecs(&mut self) -> &mut ::std::vec::Vec<EStreamVideoCodec> {
        &mut self.supported_video_codecs
    }

    // Take field
    pub fn take_supported_video_codecs(&mut self) -> ::std::vec::Vec<EStreamVideoCodec> {
        ::std::mem::replace(&mut self.supported_video_codecs, ::std::vec::Vec::new())
    }

    pub fn get_supported_video_codecs(&self) -> &[EStreamVideoCodec] {
        &self.supported_video_codecs
    }

    fn get_supported_video_codecs_for_reflect(&self) -> &::std::vec::Vec<EStreamVideoCodec> {
        &self.supported_video_codecs
    }

    fn mut_supported_video_codecs_for_reflect(&mut self) -> &mut ::std::vec::Vec<EStreamVideoCodec> {
        &mut self.supported_video_codecs
    }
}

impl ::protobuf::Message for CNegotiationInitMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.reliable_data = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.supported_audio_codecs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.supported_video_codecs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        };
        for value in &self.supported_audio_codecs {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.supported_video_codecs {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        };
        for v in &self.supported_audio_codecs {
            os.write_enum(2, v.value())?;
        };
        for v in &self.supported_video_codecs {
            os.write_enum(3, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CNegotiationInitMsg {
    fn new() -> CNegotiationInitMsg {
        CNegotiationInitMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CNegotiationInitMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reliable_data",
                    CNegotiationInitMsg::get_reliable_data_for_reflect,
                    CNegotiationInitMsg::mut_reliable_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                    "supported_audio_codecs",
                    CNegotiationInitMsg::get_supported_audio_codecs_for_reflect,
                    CNegotiationInitMsg::mut_supported_audio_codecs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                    "supported_video_codecs",
                    CNegotiationInitMsg::get_supported_video_codecs_for_reflect,
                    CNegotiationInitMsg::mut_supported_video_codecs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CNegotiationInitMsg>(
                    "CNegotiationInitMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CNegotiationInitMsg {
    fn clear(&mut self) {
        self.clear_reliable_data();
        self.clear_supported_audio_codecs();
        self.clear_supported_video_codecs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationInitMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationInitMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationSetConfigMsg {
    // message fields
    config: ::protobuf::SingularPtrField<CNegotiatedConfig>,
    streaming_client_config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    streaming_client_caps: ::protobuf::SingularPtrField<CStreamingClientCaps>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CNegotiationSetConfigMsg {}

impl CNegotiationSetConfigMsg {
    pub fn new() -> CNegotiationSetConfigMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNegotiationSetConfigMsg {
        static mut instance: ::protobuf::lazy::Lazy<CNegotiationSetConfigMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CNegotiationSetConfigMsg,
        };
        unsafe {
            instance.get(CNegotiationSetConfigMsg::new)
        }
    }

    // required .CNegotiatedConfig config = 1;

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CNegotiatedConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CNegotiatedConfig {
        if self.config.is_none() {
            self.config.set_default();
        };
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> CNegotiatedConfig {
        self.config.take().unwrap_or_else(|| CNegotiatedConfig::new())
    }

    pub fn get_config(&self) -> &CNegotiatedConfig {
        self.config.as_ref().unwrap_or_else(|| CNegotiatedConfig::default_instance())
    }

    fn get_config_for_reflect(&self) -> &::protobuf::SingularPtrField<CNegotiatedConfig> {
        &self.config
    }

    fn mut_config_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CNegotiatedConfig> {
        &mut self.config
    }

    // optional .CStreamingClientConfig streaming_client_config = 2;

    pub fn clear_streaming_client_config(&mut self) {
        self.streaming_client_config.clear();
    }

    pub fn has_streaming_client_config(&self) -> bool {
        self.streaming_client_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_config(&mut self, v: CStreamingClientConfig) {
        self.streaming_client_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_config(&mut self) -> &mut CStreamingClientConfig {
        if self.streaming_client_config.is_none() {
            self.streaming_client_config.set_default();
        };
        self.streaming_client_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_streaming_client_config(&mut self) -> CStreamingClientConfig {
        self.streaming_client_config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }

    pub fn get_streaming_client_config(&self) -> &CStreamingClientConfig {
        self.streaming_client_config.as_ref().unwrap_or_else(|| CStreamingClientConfig::default_instance())
    }

    fn get_streaming_client_config_for_reflect(&self) -> &::protobuf::SingularPtrField<CStreamingClientConfig> {
        &self.streaming_client_config
    }

    fn mut_streaming_client_config_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStreamingClientConfig> {
        &mut self.streaming_client_config
    }

    // optional .CStreamingClientCaps streaming_client_caps = 3;

    pub fn clear_streaming_client_caps(&mut self) {
        self.streaming_client_caps.clear();
    }

    pub fn has_streaming_client_caps(&self) -> bool {
        self.streaming_client_caps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_caps(&mut self, v: CStreamingClientCaps) {
        self.streaming_client_caps = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_caps(&mut self) -> &mut CStreamingClientCaps {
        if self.streaming_client_caps.is_none() {
            self.streaming_client_caps.set_default();
        };
        self.streaming_client_caps.as_mut().unwrap()
    }

    // Take field
    pub fn take_streaming_client_caps(&mut self) -> CStreamingClientCaps {
        self.streaming_client_caps.take().unwrap_or_else(|| CStreamingClientCaps::new())
    }

    pub fn get_streaming_client_caps(&self) -> &CStreamingClientCaps {
        self.streaming_client_caps.as_ref().unwrap_or_else(|| CStreamingClientCaps::default_instance())
    }

    fn get_streaming_client_caps_for_reflect(&self) -> &::protobuf::SingularPtrField<CStreamingClientCaps> {
        &self.streaming_client_caps
    }

    fn mut_streaming_client_caps_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStreamingClientCaps> {
        &mut self.streaming_client_caps
    }
}

impl ::protobuf::Message for CNegotiationSetConfigMsg {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.streaming_client_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.streaming_client_caps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.streaming_client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.streaming_client_caps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.streaming_client_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.streaming_client_caps.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CNegotiationSetConfigMsg {
    fn new() -> CNegotiationSetConfigMsg {
        CNegotiationSetConfigMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CNegotiationSetConfigMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CNegotiatedConfig>>(
                    "config",
                    CNegotiationSetConfigMsg::get_config_for_reflect,
                    CNegotiationSetConfigMsg::mut_config_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientConfig>>(
                    "streaming_client_config",
                    CNegotiationSetConfigMsg::get_streaming_client_config_for_reflect,
                    CNegotiationSetConfigMsg::mut_streaming_client_config_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientCaps>>(
                    "streaming_client_caps",
                    CNegotiationSetConfigMsg::get_streaming_client_caps_for_reflect,
                    CNegotiationSetConfigMsg::mut_streaming_client_caps_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CNegotiationSetConfigMsg>(
                    "CNegotiationSetConfigMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CNegotiationSetConfigMsg {
    fn clear(&mut self) {
        self.clear_config();
        self.clear_streaming_client_config();
        self.clear_streaming_client_caps();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationSetConfigMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationSetConfigMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationCompleteMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CNegotiationCompleteMsg {}

impl CNegotiationCompleteMsg {
    pub fn new() -> CNegotiationCompleteMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CNegotiationCompleteMsg {
        static mut instance: ::protobuf::lazy::Lazy<CNegotiationCompleteMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CNegotiationCompleteMsg,
        };
        unsafe {
            instance.get(CNegotiationCompleteMsg::new)
        }
    }
}

impl ::protobuf::Message for CNegotiationCompleteMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CNegotiationCompleteMsg {
    fn new() -> CNegotiationCompleteMsg {
        CNegotiationCompleteMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CNegotiationCompleteMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CNegotiationCompleteMsg>(
                    "CNegotiationCompleteMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CNegotiationCompleteMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationCompleteMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationCompleteMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartAudioDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<EStreamAudioCodec>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStartAudioDataMsg {}

impl CStartAudioDataMsg {
    pub fn new() -> CStartAudioDataMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStartAudioDataMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStartAudioDataMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStartAudioDataMsg,
        };
        unsafe {
            instance.get(CStartAudioDataMsg::new)
        }
    }

    // required uint32 channel = 2;

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    fn get_channel_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channel
    }

    fn mut_channel_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channel
    }

    // optional .EStreamAudioCodec codec = 3;

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamAudioCodec) {
        self.codec = ::std::option::Option::Some(v);
    }

    pub fn get_codec(&self) -> EStreamAudioCodec {
        self.codec.unwrap_or(EStreamAudioCodec::k_EStreamAudioCodecNone)
    }

    fn get_codec_for_reflect(&self) -> &::std::option::Option<EStreamAudioCodec> {
        &self.codec
    }

    fn mut_codec_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamAudioCodec> {
        &mut self.codec
    }

    // optional bytes codec_data = 4;

    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        };
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_codec_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.codec_data
    }

    fn mut_codec_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.codec_data
    }

    // optional uint32 frequency = 5;

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    fn get_frequency_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.frequency
    }

    fn mut_frequency_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.frequency
    }

    // optional uint32 channels = 6;

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }

    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    fn get_channels_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channels
    }

    fn mut_channels_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channels
    }
}

impl ::protobuf::Message for CStartAudioDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.codec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.channels = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_size(3, v);
        };
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        };
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.codec {
            os.write_enum(3, v.value())?;
        };
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.frequency {
            os.write_uint32(5, v)?;
        };
        if let Some(v) = self.channels {
            os.write_uint32(6, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStartAudioDataMsg {
    fn new() -> CStartAudioDataMsg {
        CStartAudioDataMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStartAudioDataMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel",
                    CStartAudioDataMsg::get_channel_for_reflect,
                    CStartAudioDataMsg::mut_channel_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                    "codec",
                    CStartAudioDataMsg::get_codec_for_reflect,
                    CStartAudioDataMsg::mut_codec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "codec_data",
                    CStartAudioDataMsg::get_codec_data_for_reflect,
                    CStartAudioDataMsg::mut_codec_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    CStartAudioDataMsg::get_frequency_for_reflect,
                    CStartAudioDataMsg::mut_frequency_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channels",
                    CStartAudioDataMsg::get_channels_for_reflect,
                    CStartAudioDataMsg::mut_channels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStartAudioDataMsg>(
                    "CStartAudioDataMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStartAudioDataMsg {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_codec();
        self.clear_codec_data();
        self.clear_frequency();
        self.clear_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartAudioDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopAudioDataMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStopAudioDataMsg {}

impl CStopAudioDataMsg {
    pub fn new() -> CStopAudioDataMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStopAudioDataMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStopAudioDataMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStopAudioDataMsg,
        };
        unsafe {
            instance.get(CStopAudioDataMsg::new)
        }
    }
}

impl ::protobuf::Message for CStopAudioDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStopAudioDataMsg {
    fn new() -> CStopAudioDataMsg {
        CStopAudioDataMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStopAudioDataMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CStopAudioDataMsg>(
                    "CStopAudioDataMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStopAudioDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopAudioDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartVideoDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<EStreamVideoCodec>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStartVideoDataMsg {}

impl CStartVideoDataMsg {
    pub fn new() -> CStartVideoDataMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStartVideoDataMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStartVideoDataMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStartVideoDataMsg,
        };
        unsafe {
            instance.get(CStartVideoDataMsg::new)
        }
    }

    // required uint32 channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    fn get_channel_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channel
    }

    fn mut_channel_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channel
    }

    // optional .EStreamVideoCodec codec = 2;

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(v);
    }

    pub fn get_codec(&self) -> EStreamVideoCodec {
        self.codec.unwrap_or(EStreamVideoCodec::k_EStreamVideoCodecNone)
    }

    fn get_codec_for_reflect(&self) -> &::std::option::Option<EStreamVideoCodec> {
        &self.codec
    }

    fn mut_codec_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamVideoCodec> {
        &mut self.codec
    }

    // optional bytes codec_data = 3;

    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        };
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_codec_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.codec_data
    }

    fn mut_codec_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.codec_data
    }

    // optional uint32 width = 4;

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    fn get_width_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.width
    }

    fn mut_width_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.width
    }

    // optional uint32 height = 5;

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    fn get_height_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.height
    }

    fn mut_height_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.height
    }
}

impl ::protobuf::Message for CStartVideoDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.codec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        };
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.codec {
            os.write_enum(2, v.value())?;
        };
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(3, &v)?;
        };
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        };
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStartVideoDataMsg {
    fn new() -> CStartVideoDataMsg {
        CStartVideoDataMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStartVideoDataMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel",
                    CStartVideoDataMsg::get_channel_for_reflect,
                    CStartVideoDataMsg::mut_channel_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                    "codec",
                    CStartVideoDataMsg::get_codec_for_reflect,
                    CStartVideoDataMsg::mut_codec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "codec_data",
                    CStartVideoDataMsg::get_codec_data_for_reflect,
                    CStartVideoDataMsg::mut_codec_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    CStartVideoDataMsg::get_width_for_reflect,
                    CStartVideoDataMsg::mut_width_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    CStartVideoDataMsg::get_height_for_reflect,
                    CStartVideoDataMsg::mut_height_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStartVideoDataMsg>(
                    "CStartVideoDataMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStartVideoDataMsg {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_codec();
        self.clear_codec_data();
        self.clear_width();
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartVideoDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopVideoDataMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStopVideoDataMsg {}

impl CStopVideoDataMsg {
    pub fn new() -> CStopVideoDataMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStopVideoDataMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStopVideoDataMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStopVideoDataMsg,
        };
        unsafe {
            instance.get(CStopVideoDataMsg::new)
        }
    }
}

impl ::protobuf::Message for CStopVideoDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStopVideoDataMsg {
    fn new() -> CStopVideoDataMsg {
        CStopVideoDataMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStopVideoDataMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CStopVideoDataMsg>(
                    "CStopVideoDataMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStopVideoDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopVideoDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputLatencyTestMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    color: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputLatencyTestMsg {}

impl CInputLatencyTestMsg {
    pub fn new() -> CInputLatencyTestMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputLatencyTestMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputLatencyTestMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputLatencyTestMsg,
        };
        unsafe {
            instance.get(CInputLatencyTestMsg::new)
        }
    }

    // required uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // optional uint32 color = 2;

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    fn get_color_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.color
    }

    fn mut_color_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.color
    }
}

impl ::protobuf::Message for CInputLatencyTestMsg {
    fn is_initialized(&self) -> bool {
        if self.input_mark.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputLatencyTestMsg {
    fn new() -> CInputLatencyTestMsg {
        CInputLatencyTestMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputLatencyTestMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputLatencyTestMsg::get_input_mark_for_reflect,
                    CInputLatencyTestMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "color",
                    CInputLatencyTestMsg::get_color_for_reflect,
                    CInputLatencyTestMsg::mut_color_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputLatencyTestMsg>(
                    "CInputLatencyTestMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputLatencyTestMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_color();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputLatencyTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputLatencyTestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseMotionMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    dx: ::std::option::Option<i32>,
    dy: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputMouseMotionMsg {}

impl CInputMouseMotionMsg {
    pub fn new() -> CInputMouseMotionMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputMouseMotionMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputMouseMotionMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputMouseMotionMsg,
        };
        unsafe {
            instance.get(CInputMouseMotionMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // optional float x_normalized = 2;

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    fn get_x_normalized_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x_normalized
    }

    fn mut_x_normalized_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x_normalized
    }

    // optional float y_normalized = 3;

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    fn get_y_normalized_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y_normalized
    }

    fn mut_y_normalized_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y_normalized
    }

    // optional int32 dx = 4;

    pub fn clear_dx(&mut self) {
        self.dx = ::std::option::Option::None;
    }

    pub fn has_dx(&self) -> bool {
        self.dx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = ::std::option::Option::Some(v);
    }

    pub fn get_dx(&self) -> i32 {
        self.dx.unwrap_or(0)
    }

    fn get_dx_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.dx
    }

    fn mut_dx_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.dx
    }

    // optional int32 dy = 5;

    pub fn clear_dy(&mut self) {
        self.dy = ::std::option::Option::None;
    }

    pub fn has_dy(&self) -> bool {
        self.dy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = ::std::option::Option::Some(v);
    }

    pub fn get_dy(&self) -> i32 {
        self.dy.unwrap_or(0)
    }

    fn get_dy_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.dy
    }

    fn mut_dy_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.dy
    }
}

impl ::protobuf::Message for CInputMouseMotionMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.dx = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.dy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.x_normalized {
            my_size += 5;
        };
        if let Some(v) = self.y_normalized {
            my_size += 5;
        };
        if let Some(v) = self.dx {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.dy {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.x_normalized {
            os.write_float(2, v)?;
        };
        if let Some(v) = self.y_normalized {
            os.write_float(3, v)?;
        };
        if let Some(v) = self.dx {
            os.write_int32(4, v)?;
        };
        if let Some(v) = self.dy {
            os.write_int32(5, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputMouseMotionMsg {
    fn new() -> CInputMouseMotionMsg {
        CInputMouseMotionMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputMouseMotionMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputMouseMotionMsg::get_input_mark_for_reflect,
                    CInputMouseMotionMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x_normalized",
                    CInputMouseMotionMsg::get_x_normalized_for_reflect,
                    CInputMouseMotionMsg::mut_x_normalized_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y_normalized",
                    CInputMouseMotionMsg::get_y_normalized_for_reflect,
                    CInputMouseMotionMsg::mut_y_normalized_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dx",
                    CInputMouseMotionMsg::get_dx_for_reflect,
                    CInputMouseMotionMsg::mut_dx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dy",
                    CInputMouseMotionMsg::get_dy_for_reflect,
                    CInputMouseMotionMsg::mut_dy_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputMouseMotionMsg>(
                    "CInputMouseMotionMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputMouseMotionMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_x_normalized();
        self.clear_y_normalized();
        self.clear_dx();
        self.clear_dy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseMotionMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseWheelMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    direction: ::std::option::Option<EStreamMouseWheelDirection>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputMouseWheelMsg {}

impl CInputMouseWheelMsg {
    pub fn new() -> CInputMouseWheelMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputMouseWheelMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputMouseWheelMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputMouseWheelMsg,
        };
        unsafe {
            instance.get(CInputMouseWheelMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required .EStreamMouseWheelDirection direction = 2;

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EStreamMouseWheelDirection) {
        self.direction = ::std::option::Option::Some(v);
    }

    pub fn get_direction(&self) -> EStreamMouseWheelDirection {
        self.direction.unwrap_or(EStreamMouseWheelDirection::k_EStreamMouseWheelUp)
    }

    fn get_direction_for_reflect(&self) -> &::std::option::Option<EStreamMouseWheelDirection> {
        &self.direction
    }

    fn mut_direction_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamMouseWheelDirection> {
        &mut self.direction
    }
}

impl ::protobuf::Message for CInputMouseWheelMsg {
    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.direction = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.direction {
            os.write_enum(2, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputMouseWheelMsg {
    fn new() -> CInputMouseWheelMsg {
        CInputMouseWheelMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputMouseWheelMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputMouseWheelMsg::get_input_mark_for_reflect,
                    CInputMouseWheelMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseWheelDirection>>(
                    "direction",
                    CInputMouseWheelMsg::get_direction_for_reflect,
                    CInputMouseWheelMsg::mut_direction_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputMouseWheelMsg>(
                    "CInputMouseWheelMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputMouseWheelMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_direction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseWheelMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseWheelMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<EStreamMouseButton>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputMouseDownMsg {}

impl CInputMouseDownMsg {
    pub fn new() -> CInputMouseDownMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputMouseDownMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputMouseDownMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputMouseDownMsg,
        };
        unsafe {
            instance.get(CInputMouseDownMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required .EStreamMouseButton button = 2;

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(v);
    }

    pub fn get_button(&self) -> EStreamMouseButton {
        self.button.unwrap_or(EStreamMouseButton::k_EStreamMouseButtonLeft)
    }

    fn get_button_for_reflect(&self) -> &::std::option::Option<EStreamMouseButton> {
        &self.button
    }

    fn mut_button_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamMouseButton> {
        &mut self.button
    }
}

impl ::protobuf::Message for CInputMouseDownMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.button = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.button {
            os.write_enum(2, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputMouseDownMsg {
    fn new() -> CInputMouseDownMsg {
        CInputMouseDownMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputMouseDownMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputMouseDownMsg::get_input_mark_for_reflect,
                    CInputMouseDownMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseButton>>(
                    "button",
                    CInputMouseDownMsg::get_button_for_reflect,
                    CInputMouseDownMsg::mut_button_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputMouseDownMsg>(
                    "CInputMouseDownMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputMouseDownMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_button();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseDownMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<EStreamMouseButton>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputMouseUpMsg {}

impl CInputMouseUpMsg {
    pub fn new() -> CInputMouseUpMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputMouseUpMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputMouseUpMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputMouseUpMsg,
        };
        unsafe {
            instance.get(CInputMouseUpMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required .EStreamMouseButton button = 2;

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(v);
    }

    pub fn get_button(&self) -> EStreamMouseButton {
        self.button.unwrap_or(EStreamMouseButton::k_EStreamMouseButtonLeft)
    }

    fn get_button_for_reflect(&self) -> &::std::option::Option<EStreamMouseButton> {
        &self.button
    }

    fn mut_button_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamMouseButton> {
        &mut self.button
    }
}

impl ::protobuf::Message for CInputMouseUpMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.button = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_size(2, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.button {
            os.write_enum(2, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputMouseUpMsg {
    fn new() -> CInputMouseUpMsg {
        CInputMouseUpMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputMouseUpMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputMouseUpMsg::get_input_mark_for_reflect,
                    CInputMouseUpMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseButton>>(
                    "button",
                    CInputMouseUpMsg::get_button_for_reflect,
                    CInputMouseUpMsg::mut_button_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputMouseUpMsg>(
                    "CInputMouseUpMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputMouseUpMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_button();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseUpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputKeyDownMsg {}

impl CInputKeyDownMsg {
    pub fn new() -> CInputKeyDownMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputKeyDownMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputKeyDownMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputKeyDownMsg,
        };
        unsafe {
            instance.get(CInputKeyDownMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required uint32 scancode = 2;

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    fn get_scancode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scancode
    }

    fn mut_scancode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scancode
    }
}

impl ::protobuf::Message for CInputKeyDownMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputKeyDownMsg {
    fn new() -> CInputKeyDownMsg {
        CInputKeyDownMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputKeyDownMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputKeyDownMsg::get_input_mark_for_reflect,
                    CInputKeyDownMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scancode",
                    CInputKeyDownMsg::get_scancode_for_reflect,
                    CInputKeyDownMsg::mut_scancode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputKeyDownMsg>(
                    "CInputKeyDownMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputKeyDownMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_scancode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyDownMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputKeyUpMsg {}

impl CInputKeyUpMsg {
    pub fn new() -> CInputKeyUpMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputKeyUpMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputKeyUpMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputKeyUpMsg,
        };
        unsafe {
            instance.get(CInputKeyUpMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required uint32 scancode = 2;

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    fn get_scancode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scancode
    }

    fn mut_scancode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scancode
    }
}

impl ::protobuf::Message for CInputKeyUpMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputKeyUpMsg {
    fn new() -> CInputKeyUpMsg {
        CInputKeyUpMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputKeyUpMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputKeyUpMsg::get_input_mark_for_reflect,
                    CInputKeyUpMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scancode",
                    CInputKeyUpMsg::get_scancode_for_reflect,
                    CInputKeyUpMsg::mut_scancode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputKeyUpMsg>(
                    "CInputKeyUpMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputKeyUpMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_scancode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyUpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputGamepadAttachedMsg {
    // message fields
    controller_id: ::std::option::Option<i32>,
    controller_type: ::std::option::Option<u32>,
    controller_subtype: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputGamepadAttachedMsg {}

impl CInputGamepadAttachedMsg {
    pub fn new() -> CInputGamepadAttachedMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputGamepadAttachedMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputGamepadAttachedMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputGamepadAttachedMsg,
        };
        unsafe {
            instance.get(CInputGamepadAttachedMsg::new)
        }
    }

    // required int32 controller_id = 1;

    pub fn clear_controller_id(&mut self) {
        self.controller_id = ::std::option::Option::None;
    }

    pub fn has_controller_id(&self) -> bool {
        self.controller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_id(&mut self, v: i32) {
        self.controller_id = ::std::option::Option::Some(v);
    }

    pub fn get_controller_id(&self) -> i32 {
        self.controller_id.unwrap_or(0)
    }

    fn get_controller_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_id
    }

    fn mut_controller_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_id
    }

    // optional uint32 controller_type = 2;

    pub fn clear_controller_type(&mut self) {
        self.controller_type = ::std::option::Option::None;
    }

    pub fn has_controller_type(&self) -> bool {
        self.controller_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_type(&mut self, v: u32) {
        self.controller_type = ::std::option::Option::Some(v);
    }

    pub fn get_controller_type(&self) -> u32 {
        self.controller_type.unwrap_or(0)
    }

    fn get_controller_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.controller_type
    }

    fn mut_controller_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.controller_type
    }

    // optional uint32 controller_subtype = 3;

    pub fn clear_controller_subtype(&mut self) {
        self.controller_subtype = ::std::option::Option::None;
    }

    pub fn has_controller_subtype(&self) -> bool {
        self.controller_subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_subtype(&mut self, v: u32) {
        self.controller_subtype = ::std::option::Option::Some(v);
    }

    pub fn get_controller_subtype(&self) -> u32 {
        self.controller_subtype.unwrap_or(0)
    }

    fn get_controller_subtype_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.controller_subtype
    }

    fn mut_controller_subtype_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.controller_subtype
    }
}

impl ::protobuf::Message for CInputGamepadAttachedMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.controller_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.controller_subtype = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.controller_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.controller_subtype {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_id {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.controller_type {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.controller_subtype {
            os.write_uint32(3, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputGamepadAttachedMsg {
    fn new() -> CInputGamepadAttachedMsg {
        CInputGamepadAttachedMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputGamepadAttachedMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_id",
                    CInputGamepadAttachedMsg::get_controller_id_for_reflect,
                    CInputGamepadAttachedMsg::mut_controller_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "controller_type",
                    CInputGamepadAttachedMsg::get_controller_type_for_reflect,
                    CInputGamepadAttachedMsg::mut_controller_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "controller_subtype",
                    CInputGamepadAttachedMsg::get_controller_subtype_for_reflect,
                    CInputGamepadAttachedMsg::mut_controller_subtype_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputGamepadAttachedMsg>(
                    "CInputGamepadAttachedMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputGamepadAttachedMsg {
    fn clear(&mut self) {
        self.clear_controller_id();
        self.clear_controller_type();
        self.clear_controller_subtype();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputGamepadAttachedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputGamepadAttachedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputGamepadEventMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    controller_id: ::std::option::Option<i32>,
    input: ::std::option::Option<EStreamGamepadInputType>,
    value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputGamepadEventMsg {}

impl CInputGamepadEventMsg {
    pub fn new() -> CInputGamepadEventMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputGamepadEventMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputGamepadEventMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputGamepadEventMsg,
        };
        unsafe {
            instance.get(CInputGamepadEventMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required int32 controller_id = 2;

    pub fn clear_controller_id(&mut self) {
        self.controller_id = ::std::option::Option::None;
    }

    pub fn has_controller_id(&self) -> bool {
        self.controller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_id(&mut self, v: i32) {
        self.controller_id = ::std::option::Option::Some(v);
    }

    pub fn get_controller_id(&self) -> i32 {
        self.controller_id.unwrap_or(0)
    }

    fn get_controller_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_id
    }

    fn mut_controller_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_id
    }

    // required .EStreamGamepadInputType input = 3;

    pub fn clear_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: EStreamGamepadInputType) {
        self.input = ::std::option::Option::Some(v);
    }

    pub fn get_input(&self) -> EStreamGamepadInputType {
        self.input.unwrap_or(EStreamGamepadInputType::k_EStreamGamepadInputInvalid)
    }

    fn get_input_for_reflect(&self) -> &::std::option::Option<EStreamGamepadInputType> {
        &self.input
    }

    fn mut_input_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamGamepadInputType> {
        &mut self.input
    }

    // required float value = 4;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CInputGamepadEventMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_id.is_none() {
            return false;
        };
        if self.input.is_none() {
            return false;
        };
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.input = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.controller_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.input {
            my_size += ::protobuf::rt::enum_size(3, v);
        };
        if let Some(v) = self.value {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.controller_id {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.input {
            os.write_enum(3, v.value())?;
        };
        if let Some(v) = self.value {
            os.write_float(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputGamepadEventMsg {
    fn new() -> CInputGamepadEventMsg {
        CInputGamepadEventMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputGamepadEventMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputGamepadEventMsg::get_input_mark_for_reflect,
                    CInputGamepadEventMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_id",
                    CInputGamepadEventMsg::get_controller_id_for_reflect,
                    CInputGamepadEventMsg::mut_controller_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamGamepadInputType>>(
                    "input",
                    CInputGamepadEventMsg::get_input_for_reflect,
                    CInputGamepadEventMsg::mut_input_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "value",
                    CInputGamepadEventMsg::get_value_for_reflect,
                    CInputGamepadEventMsg::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputGamepadEventMsg>(
                    "CInputGamepadEventMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputGamepadEventMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_controller_id();
        self.clear_input();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputGamepadEventMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputGamepadEventMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputGamepadDetachedMsg {
    // message fields
    controller_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputGamepadDetachedMsg {}

impl CInputGamepadDetachedMsg {
    pub fn new() -> CInputGamepadDetachedMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputGamepadDetachedMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputGamepadDetachedMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputGamepadDetachedMsg,
        };
        unsafe {
            instance.get(CInputGamepadDetachedMsg::new)
        }
    }

    // required int32 controller_id = 1;

    pub fn clear_controller_id(&mut self) {
        self.controller_id = ::std::option::Option::None;
    }

    pub fn has_controller_id(&self) -> bool {
        self.controller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_id(&mut self, v: i32) {
        self.controller_id = ::std::option::Option::Some(v);
    }

    pub fn get_controller_id(&self) -> i32 {
        self.controller_id.unwrap_or(0)
    }

    fn get_controller_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_id
    }

    fn mut_controller_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_id
    }
}

impl ::protobuf::Message for CInputGamepadDetachedMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_id {
            os.write_int32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputGamepadDetachedMsg {
    fn new() -> CInputGamepadDetachedMsg {
        CInputGamepadDetachedMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputGamepadDetachedMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_id",
                    CInputGamepadDetachedMsg::get_controller_id_for_reflect,
                    CInputGamepadDetachedMsg::mut_controller_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputGamepadDetachedMsg>(
                    "CInputGamepadDetachedMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputGamepadDetachedMsg {
    fn clear(&mut self) {
        self.clear_controller_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputGamepadDetachedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputGamepadDetachedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGamepadRumbleMsg {
    // message fields
    controller_id: ::std::option::Option<i32>,
    left_motor_speed: ::std::option::Option<i32>,
    right_motor_speed: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CGamepadRumbleMsg {}

impl CGamepadRumbleMsg {
    pub fn new() -> CGamepadRumbleMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGamepadRumbleMsg {
        static mut instance: ::protobuf::lazy::Lazy<CGamepadRumbleMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CGamepadRumbleMsg,
        };
        unsafe {
            instance.get(CGamepadRumbleMsg::new)
        }
    }

    // required int32 controller_id = 1;

    pub fn clear_controller_id(&mut self) {
        self.controller_id = ::std::option::Option::None;
    }

    pub fn has_controller_id(&self) -> bool {
        self.controller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_id(&mut self, v: i32) {
        self.controller_id = ::std::option::Option::Some(v);
    }

    pub fn get_controller_id(&self) -> i32 {
        self.controller_id.unwrap_or(0)
    }

    fn get_controller_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_id
    }

    fn mut_controller_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_id
    }

    // optional int32 left_motor_speed = 2;

    pub fn clear_left_motor_speed(&mut self) {
        self.left_motor_speed = ::std::option::Option::None;
    }

    pub fn has_left_motor_speed(&self) -> bool {
        self.left_motor_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_motor_speed(&mut self, v: i32) {
        self.left_motor_speed = ::std::option::Option::Some(v);
    }

    pub fn get_left_motor_speed(&self) -> i32 {
        self.left_motor_speed.unwrap_or(0)
    }

    fn get_left_motor_speed_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.left_motor_speed
    }

    fn mut_left_motor_speed_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.left_motor_speed
    }

    // optional int32 right_motor_speed = 3;

    pub fn clear_right_motor_speed(&mut self) {
        self.right_motor_speed = ::std::option::Option::None;
    }

    pub fn has_right_motor_speed(&self) -> bool {
        self.right_motor_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_motor_speed(&mut self, v: i32) {
        self.right_motor_speed = ::std::option::Option::Some(v);
    }

    pub fn get_right_motor_speed(&self) -> i32 {
        self.right_motor_speed.unwrap_or(0)
    }

    fn get_right_motor_speed_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.right_motor_speed
    }

    fn mut_right_motor_speed_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.right_motor_speed
    }
}

impl ::protobuf::Message for CGamepadRumbleMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.left_motor_speed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.right_motor_speed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.left_motor_speed {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.right_motor_speed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_id {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.left_motor_speed {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.right_motor_speed {
            os.write_int32(3, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CGamepadRumbleMsg {
    fn new() -> CGamepadRumbleMsg {
        CGamepadRumbleMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CGamepadRumbleMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_id",
                    CGamepadRumbleMsg::get_controller_id_for_reflect,
                    CGamepadRumbleMsg::mut_controller_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "left_motor_speed",
                    CGamepadRumbleMsg::get_left_motor_speed_for_reflect,
                    CGamepadRumbleMsg::mut_left_motor_speed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "right_motor_speed",
                    CGamepadRumbleMsg::get_right_motor_speed_for_reflect,
                    CGamepadRumbleMsg::mut_right_motor_speed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CGamepadRumbleMsg>(
                    "CGamepadRumbleMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CGamepadRumbleMsg {
    fn clear(&mut self) {
        self.clear_controller_id();
        self.clear_left_motor_speed();
        self.clear_right_motor_speed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGamepadRumbleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGamepadRumbleMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTitleMsg {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetTitleMsg {}

impl CSetTitleMsg {
    pub fn new() -> CSetTitleMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetTitleMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetTitleMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetTitleMsg,
        };
        unsafe {
            instance.get(CSetTitleMsg::new)
        }
    }

    // optional string text = 1;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }
}

impl ::protobuf::Message for CSetTitleMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetTitleMsg {
    fn new() -> CSetTitleMsg {
        CSetTitleMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetTitleMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CSetTitleMsg::get_text_for_reflect,
                    CSetTitleMsg::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetTitleMsg>(
                    "CSetTitleMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetTitleMsg {
    fn clear(&mut self) {
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTitleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTitleMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetIconMsg {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetIconMsg {}

impl CSetIconMsg {
    pub fn new() -> CSetIconMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetIconMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetIconMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetIconMsg,
        };
        unsafe {
            instance.get(CSetIconMsg::new)
        }
    }

    // optional int32 width = 1;

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    fn get_width_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.width
    }

    fn mut_width_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.width
    }

    // optional int32 height = 2;

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    fn get_height_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.height
    }

    fn mut_height_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.height
    }

    // optional bytes image = 3;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.image
    }
}

impl ::protobuf::Message for CSetIconMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetIconMsg {
    fn new() -> CSetIconMsg {
        CSetIconMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetIconMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    CSetIconMsg::get_width_for_reflect,
                    CSetIconMsg::mut_width_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    CSetIconMsg::get_height_for_reflect,
                    CSetIconMsg::mut_height_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "image",
                    CSetIconMsg::get_image_for_reflect,
                    CSetIconMsg::mut_image_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetIconMsg>(
                    "CSetIconMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetIconMsg {
    fn clear(&mut self) {
        self.clear_width();
        self.clear_height();
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetIconMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetIconMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CShowCursorMsg {
    // message fields
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CShowCursorMsg {}

impl CShowCursorMsg {
    pub fn new() -> CShowCursorMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CShowCursorMsg {
        static mut instance: ::protobuf::lazy::Lazy<CShowCursorMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CShowCursorMsg,
        };
        unsafe {
            instance.get(CShowCursorMsg::new)
        }
    }

    // optional float x_normalized = 1;

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    fn get_x_normalized_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x_normalized
    }

    fn mut_x_normalized_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x_normalized
    }

    // optional float y_normalized = 2;

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    fn get_y_normalized_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y_normalized
    }

    fn mut_y_normalized_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y_normalized
    }
}

impl ::protobuf::Message for CShowCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x_normalized {
            my_size += 5;
        };
        if let Some(v) = self.y_normalized {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x_normalized {
            os.write_float(1, v)?;
        };
        if let Some(v) = self.y_normalized {
            os.write_float(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CShowCursorMsg {
    fn new() -> CShowCursorMsg {
        CShowCursorMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CShowCursorMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x_normalized",
                    CShowCursorMsg::get_x_normalized_for_reflect,
                    CShowCursorMsg::mut_x_normalized_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y_normalized",
                    CShowCursorMsg::get_y_normalized_for_reflect,
                    CShowCursorMsg::mut_y_normalized_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CShowCursorMsg>(
                    "CShowCursorMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CShowCursorMsg {
    fn clear(&mut self) {
        self.clear_x_normalized();
        self.clear_y_normalized();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CShowCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CShowCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CHideCursorMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CHideCursorMsg {}

impl CHideCursorMsg {
    pub fn new() -> CHideCursorMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CHideCursorMsg {
        static mut instance: ::protobuf::lazy::Lazy<CHideCursorMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CHideCursorMsg,
        };
        unsafe {
            instance.get(CHideCursorMsg::new)
        }
    }
}

impl ::protobuf::Message for CHideCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CHideCursorMsg {
    fn new() -> CHideCursorMsg {
        CHideCursorMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CHideCursorMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CHideCursorMsg>(
                    "CHideCursorMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CHideCursorMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CHideCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHideCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetCursorMsg {}

impl CSetCursorMsg {
    pub fn new() -> CSetCursorMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetCursorMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetCursorMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetCursorMsg,
        };
        unsafe {
            instance.get(CSetCursorMsg::new)
        }
    }

    // required uint64 cursor_id = 1;

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    fn get_cursor_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cursor_id
    }

    fn mut_cursor_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cursor_id
    }
}

impl ::protobuf::Message for CSetCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetCursorMsg {
    fn new() -> CSetCursorMsg {
        CSetCursorMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetCursorMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cursor_id",
                    CSetCursorMsg::get_cursor_id_for_reflect,
                    CSetCursorMsg::mut_cursor_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetCursorMsg>(
                    "CSetCursorMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetCursorMsg {
    fn clear(&mut self) {
        self.clear_cursor_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CGetCursorImageMsg {}

impl CGetCursorImageMsg {
    pub fn new() -> CGetCursorImageMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGetCursorImageMsg {
        static mut instance: ::protobuf::lazy::Lazy<CGetCursorImageMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CGetCursorImageMsg,
        };
        unsafe {
            instance.get(CGetCursorImageMsg::new)
        }
    }

    // required uint64 cursor_id = 1;

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    fn get_cursor_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cursor_id
    }

    fn mut_cursor_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cursor_id
    }
}

impl ::protobuf::Message for CGetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CGetCursorImageMsg {
    fn new() -> CGetCursorImageMsg {
        CGetCursorImageMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CGetCursorImageMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cursor_id",
                    CGetCursorImageMsg::get_cursor_id_for_reflect,
                    CGetCursorImageMsg::mut_cursor_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CGetCursorImageMsg>(
                    "CGetCursorImageMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CGetCursorImageMsg {
    fn clear(&mut self) {
        self.clear_cursor_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetCursorImageMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    hot_x: ::std::option::Option<i32>,
    hot_y: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetCursorImageMsg {}

impl CSetCursorImageMsg {
    pub fn new() -> CSetCursorImageMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetCursorImageMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetCursorImageMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetCursorImageMsg,
        };
        unsafe {
            instance.get(CSetCursorImageMsg::new)
        }
    }

    // required uint64 cursor_id = 1;

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    fn get_cursor_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cursor_id
    }

    fn mut_cursor_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cursor_id
    }

    // optional int32 width = 2;

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    fn get_width_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.width
    }

    fn mut_width_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.width
    }

    // optional int32 height = 3;

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    fn get_height_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.height
    }

    fn mut_height_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.height
    }

    // optional int32 hot_x = 4;

    pub fn clear_hot_x(&mut self) {
        self.hot_x = ::std::option::Option::None;
    }

    pub fn has_hot_x(&self) -> bool {
        self.hot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_x(&mut self, v: i32) {
        self.hot_x = ::std::option::Option::Some(v);
    }

    pub fn get_hot_x(&self) -> i32 {
        self.hot_x.unwrap_or(0)
    }

    fn get_hot_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hot_x
    }

    fn mut_hot_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hot_x
    }

    // optional int32 hot_y = 5;

    pub fn clear_hot_y(&mut self) {
        self.hot_y = ::std::option::Option::None;
    }

    pub fn has_hot_y(&self) -> bool {
        self.hot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_y(&mut self, v: i32) {
        self.hot_y = ::std::option::Option::Some(v);
    }

    pub fn get_hot_y(&self) -> i32 {
        self.hot_y.unwrap_or(0)
    }

    fn get_hot_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hot_y
    }

    fn mut_hot_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hot_y
    }

    // optional bytes image = 6;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.image
    }
}

impl ::protobuf::Message for CSetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.hot_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.hot_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.hot_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.hot_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        };
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        };
        if let Some(v) = self.hot_x {
            os.write_int32(4, v)?;
        };
        if let Some(v) = self.hot_y {
            os.write_int32(5, v)?;
        };
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetCursorImageMsg {
    fn new() -> CSetCursorImageMsg {
        CSetCursorImageMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetCursorImageMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cursor_id",
                    CSetCursorImageMsg::get_cursor_id_for_reflect,
                    CSetCursorImageMsg::mut_cursor_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    CSetCursorImageMsg::get_width_for_reflect,
                    CSetCursorImageMsg::mut_width_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    CSetCursorImageMsg::get_height_for_reflect,
                    CSetCursorImageMsg::mut_height_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hot_x",
                    CSetCursorImageMsg::get_hot_x_for_reflect,
                    CSetCursorImageMsg::mut_hot_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hot_y",
                    CSetCursorImageMsg::get_hot_y_for_reflect,
                    CSetCursorImageMsg::mut_hot_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "image",
                    CSetCursorImageMsg::get_image_for_reflect,
                    CSetCursorImageMsg::mut_image_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetCursorImageMsg>(
                    "CSetCursorImageMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetCursorImageMsg {
    fn clear(&mut self) {
        self.clear_cursor_id();
        self.clear_width();
        self.clear_height();
        self.clear_hot_x();
        self.clear_hot_y();
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorImageMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoDecoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    threads: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVideoDecoderInfoMsg {}

impl CVideoDecoderInfoMsg {
    pub fn new() -> CVideoDecoderInfoMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVideoDecoderInfoMsg {
        static mut instance: ::protobuf::lazy::Lazy<CVideoDecoderInfoMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVideoDecoderInfoMsg,
        };
        unsafe {
            instance.get(CVideoDecoderInfoMsg::new)
        }
    }

    // optional string info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.info
    }

    // optional int32 threads = 2;

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: i32) {
        self.threads = ::std::option::Option::Some(v);
    }

    pub fn get_threads(&self) -> i32 {
        self.threads.unwrap_or(0)
    }

    fn get_threads_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.threads
    }

    fn mut_threads_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.threads
    }
}

impl ::protobuf::Message for CVideoDecoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.threads = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        if let Some(v) = self.threads {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.threads {
            os.write_int32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVideoDecoderInfoMsg {
    fn new() -> CVideoDecoderInfoMsg {
        CVideoDecoderInfoMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVideoDecoderInfoMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "info",
                    CVideoDecoderInfoMsg::get_info_for_reflect,
                    CVideoDecoderInfoMsg::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "threads",
                    CVideoDecoderInfoMsg::get_threads_for_reflect,
                    CVideoDecoderInfoMsg::mut_threads_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVideoDecoderInfoMsg>(
                    "CVideoDecoderInfoMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVideoDecoderInfoMsg {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_threads();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoDecoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoDecoderInfoMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoEncoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVideoEncoderInfoMsg {}

impl CVideoEncoderInfoMsg {
    pub fn new() -> CVideoEncoderInfoMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVideoEncoderInfoMsg {
        static mut instance: ::protobuf::lazy::Lazy<CVideoEncoderInfoMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVideoEncoderInfoMsg,
        };
        unsafe {
            instance.get(CVideoEncoderInfoMsg::new)
        }
    }

    // optional string info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        };
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.info
    }
}

impl ::protobuf::Message for CVideoEncoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVideoEncoderInfoMsg {
    fn new() -> CVideoEncoderInfoMsg {
        CVideoEncoderInfoMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVideoEncoderInfoMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "info",
                    CVideoEncoderInfoMsg::get_info_for_reflect,
                    CVideoEncoderInfoMsg::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVideoEncoderInfoMsg>(
                    "CVideoEncoderInfoMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVideoEncoderInfoMsg {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoEncoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoEncoderInfoMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CQuitRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CQuitRequest {}

impl CQuitRequest {
    pub fn new() -> CQuitRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CQuitRequest {
        static mut instance: ::protobuf::lazy::Lazy<CQuitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CQuitRequest,
        };
        unsafe {
            instance.get(CQuitRequest::new)
        }
    }
}

impl ::protobuf::Message for CQuitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CQuitRequest {
    fn new() -> CQuitRequest {
        CQuitRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CQuitRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CQuitRequest>(
                    "CQuitRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CQuitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CQuitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CQuitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDeleteCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDeleteCursorMsg {}

impl CDeleteCursorMsg {
    pub fn new() -> CDeleteCursorMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDeleteCursorMsg {
        static mut instance: ::protobuf::lazy::Lazy<CDeleteCursorMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDeleteCursorMsg,
        };
        unsafe {
            instance.get(CDeleteCursorMsg::new)
        }
    }

    // required uint64 cursor_id = 1;

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    fn get_cursor_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cursor_id
    }

    fn mut_cursor_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cursor_id
    }
}

impl ::protobuf::Message for CDeleteCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDeleteCursorMsg {
    fn new() -> CDeleteCursorMsg {
        CDeleteCursorMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDeleteCursorMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cursor_id",
                    CDeleteCursorMsg::get_cursor_id_for_reflect,
                    CDeleteCursorMsg::mut_cursor_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDeleteCursorMsg>(
                    "CDeleteCursorMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDeleteCursorMsg {
    fn clear(&mut self) {
        self.clear_cursor_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDeleteCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDeleteCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetStreamingClientConfig {
    // message fields
    config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetStreamingClientConfig {}

impl CSetStreamingClientConfig {
    pub fn new() -> CSetStreamingClientConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetStreamingClientConfig {
        static mut instance: ::protobuf::lazy::Lazy<CSetStreamingClientConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetStreamingClientConfig,
        };
        unsafe {
            instance.get(CSetStreamingClientConfig::new)
        }
    }

    // required .CStreamingClientConfig config = 1;

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CStreamingClientConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CStreamingClientConfig {
        if self.config.is_none() {
            self.config.set_default();
        };
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> CStreamingClientConfig {
        self.config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }

    pub fn get_config(&self) -> &CStreamingClientConfig {
        self.config.as_ref().unwrap_or_else(|| CStreamingClientConfig::default_instance())
    }

    fn get_config_for_reflect(&self) -> &::protobuf::SingularPtrField<CStreamingClientConfig> {
        &self.config
    }

    fn mut_config_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStreamingClientConfig> {
        &mut self.config
    }
}

impl ::protobuf::Message for CSetStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetStreamingClientConfig {
    fn new() -> CSetStreamingClientConfig {
        CSetStreamingClientConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetStreamingClientConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientConfig>>(
                    "config",
                    CSetStreamingClientConfig::get_config_for_reflect,
                    CSetStreamingClientConfig::mut_config_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetStreamingClientConfig>(
                    "CSetStreamingClientConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetStreamingClientConfig {
    fn clear(&mut self) {
        self.clear_config();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetStreamingClientConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetQoSMsg {
    // message fields
    use_qos: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetQoSMsg {}

impl CSetQoSMsg {
    pub fn new() -> CSetQoSMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetQoSMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetQoSMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetQoSMsg,
        };
        unsafe {
            instance.get(CSetQoSMsg::new)
        }
    }

    // required bool use_qos = 1;

    pub fn clear_use_qos(&mut self) {
        self.use_qos = ::std::option::Option::None;
    }

    pub fn has_use_qos(&self) -> bool {
        self.use_qos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_qos(&mut self, v: bool) {
        self.use_qos = ::std::option::Option::Some(v);
    }

    pub fn get_use_qos(&self) -> bool {
        self.use_qos.unwrap_or(false)
    }

    fn get_use_qos_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.use_qos
    }

    fn mut_use_qos_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.use_qos
    }
}

impl ::protobuf::Message for CSetQoSMsg {
    fn is_initialized(&self) -> bool {
        if self.use_qos.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.use_qos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.use_qos {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.use_qos {
            os.write_bool(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetQoSMsg {
    fn new() -> CSetQoSMsg {
        CSetQoSMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetQoSMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_qos",
                    CSetQoSMsg::get_use_qos_for_reflect,
                    CSetQoSMsg::mut_use_qos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetQoSMsg>(
                    "CSetQoSMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetQoSMsg {
    fn clear(&mut self) {
        self.clear_use_qos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetQoSMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetQoSMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetFramerateMsg {
    // message fields
    framerate: ::std::option::Option<u32>,
    reasons: ::std::option::Option<u32>,
    framerate_numerator: ::std::option::Option<u32>,
    framerate_denominator: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetTargetFramerateMsg {}

impl CSetTargetFramerateMsg {
    pub fn new() -> CSetTargetFramerateMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetTargetFramerateMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetTargetFramerateMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetTargetFramerateMsg,
        };
        unsafe {
            instance.get(CSetTargetFramerateMsg::new)
        }
    }

    // required uint32 framerate = 1;

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    fn get_framerate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.framerate
    }

    fn mut_framerate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.framerate
    }

    // optional uint32 reasons = 2;

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    pub fn get_reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    fn get_reasons_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reasons
    }

    fn mut_reasons_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reasons
    }

    // optional uint32 framerate_numerator = 3;

    pub fn clear_framerate_numerator(&mut self) {
        self.framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_framerate_numerator(&self) -> bool {
        self.framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_numerator(&mut self, v: u32) {
        self.framerate_numerator = ::std::option::Option::Some(v);
    }

    pub fn get_framerate_numerator(&self) -> u32 {
        self.framerate_numerator.unwrap_or(0)
    }

    fn get_framerate_numerator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.framerate_numerator
    }

    fn mut_framerate_numerator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.framerate_numerator
    }

    // optional uint32 framerate_denominator = 4;

    pub fn clear_framerate_denominator(&mut self) {
        self.framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_framerate_denominator(&self) -> bool {
        self.framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_denominator(&mut self, v: u32) {
        self.framerate_denominator = ::std::option::Option::Some(v);
    }

    pub fn get_framerate_denominator(&self) -> u32 {
        self.framerate_denominator.unwrap_or(0)
    }

    fn get_framerate_denominator_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.framerate_denominator
    }

    fn mut_framerate_denominator_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.framerate_denominator
    }
}

impl ::protobuf::Message for CSetTargetFramerateMsg {
    fn is_initialized(&self) -> bool {
        if self.framerate.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.framerate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.reasons = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.framerate_numerator = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.framerate_denominator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.reasons {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.framerate_numerator {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.framerate_denominator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framerate {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.reasons {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.framerate_numerator {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.framerate_denominator {
            os.write_uint32(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetTargetFramerateMsg {
    fn new() -> CSetTargetFramerateMsg {
        CSetTargetFramerateMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetTargetFramerateMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "framerate",
                    CSetTargetFramerateMsg::get_framerate_for_reflect,
                    CSetTargetFramerateMsg::mut_framerate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reasons",
                    CSetTargetFramerateMsg::get_reasons_for_reflect,
                    CSetTargetFramerateMsg::mut_reasons_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "framerate_numerator",
                    CSetTargetFramerateMsg::get_framerate_numerator_for_reflect,
                    CSetTargetFramerateMsg::mut_framerate_numerator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "framerate_denominator",
                    CSetTargetFramerateMsg::get_framerate_denominator_for_reflect,
                    CSetTargetFramerateMsg::mut_framerate_denominator_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetTargetFramerateMsg>(
                    "CSetTargetFramerateMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetTargetFramerateMsg {
    fn clear(&mut self) {
        self.clear_framerate();
        self.clear_reasons();
        self.clear_framerate_numerator();
        self.clear_framerate_denominator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetFramerateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetFramerateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetBitrateMsg {
    // message fields
    bitrate: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetTargetBitrateMsg {}

impl CSetTargetBitrateMsg {
    pub fn new() -> CSetTargetBitrateMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetTargetBitrateMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetTargetBitrateMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetTargetBitrateMsg,
        };
        unsafe {
            instance.get(CSetTargetBitrateMsg::new)
        }
    }

    // required int32 bitrate = 1;

    pub fn clear_bitrate(&mut self) {
        self.bitrate = ::std::option::Option::None;
    }

    pub fn has_bitrate(&self) -> bool {
        self.bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: i32) {
        self.bitrate = ::std::option::Option::Some(v);
    }

    pub fn get_bitrate(&self) -> i32 {
        self.bitrate.unwrap_or(0)
    }

    fn get_bitrate_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.bitrate
    }

    fn mut_bitrate_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.bitrate
    }
}

impl ::protobuf::Message for CSetTargetBitrateMsg {
    fn is_initialized(&self) -> bool {
        if self.bitrate.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.bitrate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bitrate {
            os.write_int32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetTargetBitrateMsg {
    fn new() -> CSetTargetBitrateMsg {
        CSetTargetBitrateMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetTargetBitrateMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bitrate",
                    CSetTargetBitrateMsg::get_bitrate_for_reflect,
                    CSetTargetBitrateMsg::mut_bitrate_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetTargetBitrateMsg>(
                    "CSetTargetBitrateMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetTargetBitrateMsg {
    fn clear(&mut self) {
        self.clear_bitrate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetBitrateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetBitrateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct COverlayEnabledMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for COverlayEnabledMsg {}

impl COverlayEnabledMsg {
    pub fn new() -> COverlayEnabledMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static COverlayEnabledMsg {
        static mut instance: ::protobuf::lazy::Lazy<COverlayEnabledMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const COverlayEnabledMsg,
        };
        unsafe {
            instance.get(COverlayEnabledMsg::new)
        }
    }

    // required bool enabled = 1;

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    fn get_enabled_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enabled
    }

    fn mut_enabled_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enabled
    }
}

impl ::protobuf::Message for COverlayEnabledMsg {
    fn is_initialized(&self) -> bool {
        if self.enabled.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for COverlayEnabledMsg {
    fn new() -> COverlayEnabledMsg {
        COverlayEnabledMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<COverlayEnabledMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    COverlayEnabledMsg::get_enabled_for_reflect,
                    COverlayEnabledMsg::mut_enabled_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<COverlayEnabledMsg>(
                    "COverlayEnabledMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for COverlayEnabledMsg {
    fn clear(&mut self) {
        self.clear_enabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for COverlayEnabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for COverlayEnabledMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputControllerAttachedMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    wireless: ::std::option::Option<bool>,
    pairing_in_progress: ::std::option::Option<bool>,
    bootloader_version: ::std::option::Option<u32>,
    firmware_version: ::std::option::Option<u32>,
    serial_number: ::protobuf::SingularField<::std::string::String>,
    chip_id: ::protobuf::SingularField<::std::string::String>,
    attributes: ::std::vec::Vec<u32>,
    dongle_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputControllerAttachedMsg {}

impl CInputControllerAttachedMsg {
    pub fn new() -> CInputControllerAttachedMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputControllerAttachedMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputControllerAttachedMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputControllerAttachedMsg,
        };
        unsafe {
            instance.get(CInputControllerAttachedMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // optional bool wireless = 2;

    pub fn clear_wireless(&mut self) {
        self.wireless = ::std::option::Option::None;
    }

    pub fn has_wireless(&self) -> bool {
        self.wireless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wireless(&mut self, v: bool) {
        self.wireless = ::std::option::Option::Some(v);
    }

    pub fn get_wireless(&self) -> bool {
        self.wireless.unwrap_or(false)
    }

    fn get_wireless_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.wireless
    }

    fn mut_wireless_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.wireless
    }

    // optional bool pairing_in_progress = 3;

    pub fn clear_pairing_in_progress(&mut self) {
        self.pairing_in_progress = ::std::option::Option::None;
    }

    pub fn has_pairing_in_progress(&self) -> bool {
        self.pairing_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pairing_in_progress(&mut self, v: bool) {
        self.pairing_in_progress = ::std::option::Option::Some(v);
    }

    pub fn get_pairing_in_progress(&self) -> bool {
        self.pairing_in_progress.unwrap_or(false)
    }

    fn get_pairing_in_progress_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.pairing_in_progress
    }

    fn mut_pairing_in_progress_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.pairing_in_progress
    }

    // optional uint32 bootloader_version = 4;

    pub fn clear_bootloader_version(&mut self) {
        self.bootloader_version = ::std::option::Option::None;
    }

    pub fn has_bootloader_version(&self) -> bool {
        self.bootloader_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_version(&mut self, v: u32) {
        self.bootloader_version = ::std::option::Option::Some(v);
    }

    pub fn get_bootloader_version(&self) -> u32 {
        self.bootloader_version.unwrap_or(0)
    }

    fn get_bootloader_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bootloader_version
    }

    fn mut_bootloader_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bootloader_version
    }

    // optional uint32 firmware_version = 5;

    pub fn clear_firmware_version(&mut self) {
        self.firmware_version = ::std::option::Option::None;
    }

    pub fn has_firmware_version(&self) -> bool {
        self.firmware_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmware_version(&mut self, v: u32) {
        self.firmware_version = ::std::option::Option::Some(v);
    }

    pub fn get_firmware_version(&self) -> u32 {
        self.firmware_version.unwrap_or(0)
    }

    fn get_firmware_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.firmware_version
    }

    fn mut_firmware_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.firmware_version
    }

    // optional string serial_number = 6;

    pub fn clear_serial_number(&mut self) {
        self.serial_number.clear();
    }

    pub fn has_serial_number(&self) -> bool {
        self.serial_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial_number(&mut self, v: ::std::string::String) {
        self.serial_number = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial_number(&mut self) -> &mut ::std::string::String {
        if self.serial_number.is_none() {
            self.serial_number.set_default();
        };
        self.serial_number.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial_number(&mut self) -> ::std::string::String {
        self.serial_number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_serial_number(&self) -> &str {
        match self.serial_number.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_serial_number_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.serial_number
    }

    fn mut_serial_number_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.serial_number
    }

    // optional string chip_id = 7;

    pub fn clear_chip_id(&mut self) {
        self.chip_id.clear();
    }

    pub fn has_chip_id(&self) -> bool {
        self.chip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chip_id(&mut self, v: ::std::string::String) {
        self.chip_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chip_id(&mut self) -> &mut ::std::string::String {
        if self.chip_id.is_none() {
            self.chip_id.set_default();
        };
        self.chip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chip_id(&mut self) -> ::std::string::String {
        self.chip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_chip_id(&self) -> &str {
        match self.chip_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_chip_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.chip_id
    }

    fn mut_chip_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.chip_id
    }

    // repeated uint32 attributes = 8;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::vec::Vec<u32>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.attributes, ::std::vec::Vec::new())
    }

    pub fn get_attributes(&self) -> &[u32] {
        &self.attributes
    }

    fn get_attributes_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.attributes
    }

    fn mut_attributes_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.attributes
    }

    // optional uint32 dongle_version = 9;

    pub fn clear_dongle_version(&mut self) {
        self.dongle_version = ::std::option::Option::None;
    }

    pub fn has_dongle_version(&self) -> bool {
        self.dongle_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dongle_version(&mut self, v: u32) {
        self.dongle_version = ::std::option::Option::Some(v);
    }

    pub fn get_dongle_version(&self) -> u32 {
        self.dongle_version.unwrap_or(0)
    }

    fn get_dongle_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dongle_version
    }

    fn mut_dongle_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dongle_version
    }
}

impl ::protobuf::Message for CInputControllerAttachedMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.wireless = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.pairing_in_progress = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.bootloader_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.firmware_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serial_number)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chip_id)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.attributes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.dongle_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.wireless {
            my_size += 2;
        };
        if let Some(v) = self.pairing_in_progress {
            my_size += 2;
        };
        if let Some(v) = self.bootloader_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.firmware_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.serial_number.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        };
        if let Some(v) = self.chip_id.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        };
        for value in &self.attributes {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.dongle_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.wireless {
            os.write_bool(2, v)?;
        };
        if let Some(v) = self.pairing_in_progress {
            os.write_bool(3, v)?;
        };
        if let Some(v) = self.bootloader_version {
            os.write_uint32(4, v)?;
        };
        if let Some(v) = self.firmware_version {
            os.write_uint32(5, v)?;
        };
        if let Some(v) = self.serial_number.as_ref() {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.chip_id.as_ref() {
            os.write_string(7, &v)?;
        };
        for v in &self.attributes {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.dongle_version {
            os.write_uint32(9, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputControllerAttachedMsg {
    fn new() -> CInputControllerAttachedMsg {
        CInputControllerAttachedMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputControllerAttachedMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CInputControllerAttachedMsg::get_controller_index_for_reflect,
                    CInputControllerAttachedMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wireless",
                    CInputControllerAttachedMsg::get_wireless_for_reflect,
                    CInputControllerAttachedMsg::mut_wireless_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pairing_in_progress",
                    CInputControllerAttachedMsg::get_pairing_in_progress_for_reflect,
                    CInputControllerAttachedMsg::mut_pairing_in_progress_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bootloader_version",
                    CInputControllerAttachedMsg::get_bootloader_version_for_reflect,
                    CInputControllerAttachedMsg::mut_bootloader_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "firmware_version",
                    CInputControllerAttachedMsg::get_firmware_version_for_reflect,
                    CInputControllerAttachedMsg::mut_firmware_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serial_number",
                    CInputControllerAttachedMsg::get_serial_number_for_reflect,
                    CInputControllerAttachedMsg::mut_serial_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chip_id",
                    CInputControllerAttachedMsg::get_chip_id_for_reflect,
                    CInputControllerAttachedMsg::mut_chip_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attributes",
                    CInputControllerAttachedMsg::get_attributes_for_reflect,
                    CInputControllerAttachedMsg::mut_attributes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dongle_version",
                    CInputControllerAttachedMsg::get_dongle_version_for_reflect,
                    CInputControllerAttachedMsg::mut_dongle_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputControllerAttachedMsg>(
                    "CInputControllerAttachedMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputControllerAttachedMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.clear_wireless();
        self.clear_pairing_in_progress();
        self.clear_bootloader_version();
        self.clear_firmware_version();
        self.clear_serial_number();
        self.clear_chip_id();
        self.clear_attributes();
        self.clear_dongle_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputControllerAttachedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputControllerAttachedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputControllerStateMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    controller_index: ::std::option::Option<i32>,
    buttons: ::std::option::Option<u64>,
    left_pad_x: ::std::option::Option<i32>,
    left_pad_y: ::std::option::Option<i32>,
    right_pad_x: ::std::option::Option<i32>,
    right_pad_y: ::std::option::Option<i32>,
    left_stick_x: ::std::option::Option<i32>,
    left_stick_y: ::std::option::Option<i32>,
    left_analog: ::std::option::Option<u32>,
    right_analog: ::std::option::Option<u32>,
    accel_x: ::std::option::Option<i32>,
    accel_y: ::std::option::Option<i32>,
    accel_z: ::std::option::Option<i32>,
    gyro_x: ::std::option::Option<i32>,
    gyro_y: ::std::option::Option<i32>,
    gyro_z: ::std::option::Option<i32>,
    gyroquat_w: ::std::option::Option<i32>,
    gyroquat_x: ::std::option::Option<i32>,
    gyroquat_y: ::std::option::Option<i32>,
    gyroquat_z: ::std::option::Option<i32>,
    gyrosteeringangle: ::std::option::Option<i32>,
    batterylevel: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputControllerStateMsg {}

impl CInputControllerStateMsg {
    pub fn new() -> CInputControllerStateMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputControllerStateMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputControllerStateMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputControllerStateMsg,
        };
        unsafe {
            instance.get(CInputControllerStateMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // required int32 controller_index = 2;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // optional uint64 buttons = 3;

    pub fn clear_buttons(&mut self) {
        self.buttons = ::std::option::Option::None;
    }

    pub fn has_buttons(&self) -> bool {
        self.buttons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttons(&mut self, v: u64) {
        self.buttons = ::std::option::Option::Some(v);
    }

    pub fn get_buttons(&self) -> u64 {
        self.buttons.unwrap_or(0)
    }

    fn get_buttons_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.buttons
    }

    fn mut_buttons_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.buttons
    }

    // optional sint32 left_pad_x = 4;

    pub fn clear_left_pad_x(&mut self) {
        self.left_pad_x = ::std::option::Option::None;
    }

    pub fn has_left_pad_x(&self) -> bool {
        self.left_pad_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_pad_x(&mut self, v: i32) {
        self.left_pad_x = ::std::option::Option::Some(v);
    }

    pub fn get_left_pad_x(&self) -> i32 {
        self.left_pad_x.unwrap_or(0)
    }

    fn get_left_pad_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.left_pad_x
    }

    fn mut_left_pad_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.left_pad_x
    }

    // optional sint32 left_pad_y = 5;

    pub fn clear_left_pad_y(&mut self) {
        self.left_pad_y = ::std::option::Option::None;
    }

    pub fn has_left_pad_y(&self) -> bool {
        self.left_pad_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_pad_y(&mut self, v: i32) {
        self.left_pad_y = ::std::option::Option::Some(v);
    }

    pub fn get_left_pad_y(&self) -> i32 {
        self.left_pad_y.unwrap_or(0)
    }

    fn get_left_pad_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.left_pad_y
    }

    fn mut_left_pad_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.left_pad_y
    }

    // optional sint32 right_pad_x = 6;

    pub fn clear_right_pad_x(&mut self) {
        self.right_pad_x = ::std::option::Option::None;
    }

    pub fn has_right_pad_x(&self) -> bool {
        self.right_pad_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_pad_x(&mut self, v: i32) {
        self.right_pad_x = ::std::option::Option::Some(v);
    }

    pub fn get_right_pad_x(&self) -> i32 {
        self.right_pad_x.unwrap_or(0)
    }

    fn get_right_pad_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.right_pad_x
    }

    fn mut_right_pad_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.right_pad_x
    }

    // optional sint32 right_pad_y = 7;

    pub fn clear_right_pad_y(&mut self) {
        self.right_pad_y = ::std::option::Option::None;
    }

    pub fn has_right_pad_y(&self) -> bool {
        self.right_pad_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_pad_y(&mut self, v: i32) {
        self.right_pad_y = ::std::option::Option::Some(v);
    }

    pub fn get_right_pad_y(&self) -> i32 {
        self.right_pad_y.unwrap_or(0)
    }

    fn get_right_pad_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.right_pad_y
    }

    fn mut_right_pad_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.right_pad_y
    }

    // optional sint32 left_stick_x = 8;

    pub fn clear_left_stick_x(&mut self) {
        self.left_stick_x = ::std::option::Option::None;
    }

    pub fn has_left_stick_x(&self) -> bool {
        self.left_stick_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_stick_x(&mut self, v: i32) {
        self.left_stick_x = ::std::option::Option::Some(v);
    }

    pub fn get_left_stick_x(&self) -> i32 {
        self.left_stick_x.unwrap_or(0)
    }

    fn get_left_stick_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.left_stick_x
    }

    fn mut_left_stick_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.left_stick_x
    }

    // optional sint32 left_stick_y = 9;

    pub fn clear_left_stick_y(&mut self) {
        self.left_stick_y = ::std::option::Option::None;
    }

    pub fn has_left_stick_y(&self) -> bool {
        self.left_stick_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_stick_y(&mut self, v: i32) {
        self.left_stick_y = ::std::option::Option::Some(v);
    }

    pub fn get_left_stick_y(&self) -> i32 {
        self.left_stick_y.unwrap_or(0)
    }

    fn get_left_stick_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.left_stick_y
    }

    fn mut_left_stick_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.left_stick_y
    }

    // optional uint32 left_analog = 10;

    pub fn clear_left_analog(&mut self) {
        self.left_analog = ::std::option::Option::None;
    }

    pub fn has_left_analog(&self) -> bool {
        self.left_analog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_analog(&mut self, v: u32) {
        self.left_analog = ::std::option::Option::Some(v);
    }

    pub fn get_left_analog(&self) -> u32 {
        self.left_analog.unwrap_or(0)
    }

    fn get_left_analog_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.left_analog
    }

    fn mut_left_analog_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.left_analog
    }

    // optional uint32 right_analog = 11;

    pub fn clear_right_analog(&mut self) {
        self.right_analog = ::std::option::Option::None;
    }

    pub fn has_right_analog(&self) -> bool {
        self.right_analog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_analog(&mut self, v: u32) {
        self.right_analog = ::std::option::Option::Some(v);
    }

    pub fn get_right_analog(&self) -> u32 {
        self.right_analog.unwrap_or(0)
    }

    fn get_right_analog_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.right_analog
    }

    fn mut_right_analog_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.right_analog
    }

    // optional sint32 accel_x = 12;

    pub fn clear_accel_x(&mut self) {
        self.accel_x = ::std::option::Option::None;
    }

    pub fn has_accel_x(&self) -> bool {
        self.accel_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accel_x(&mut self, v: i32) {
        self.accel_x = ::std::option::Option::Some(v);
    }

    pub fn get_accel_x(&self) -> i32 {
        self.accel_x.unwrap_or(0)
    }

    fn get_accel_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.accel_x
    }

    fn mut_accel_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.accel_x
    }

    // optional sint32 accel_y = 13;

    pub fn clear_accel_y(&mut self) {
        self.accel_y = ::std::option::Option::None;
    }

    pub fn has_accel_y(&self) -> bool {
        self.accel_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accel_y(&mut self, v: i32) {
        self.accel_y = ::std::option::Option::Some(v);
    }

    pub fn get_accel_y(&self) -> i32 {
        self.accel_y.unwrap_or(0)
    }

    fn get_accel_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.accel_y
    }

    fn mut_accel_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.accel_y
    }

    // optional sint32 accel_z = 14;

    pub fn clear_accel_z(&mut self) {
        self.accel_z = ::std::option::Option::None;
    }

    pub fn has_accel_z(&self) -> bool {
        self.accel_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accel_z(&mut self, v: i32) {
        self.accel_z = ::std::option::Option::Some(v);
    }

    pub fn get_accel_z(&self) -> i32 {
        self.accel_z.unwrap_or(0)
    }

    fn get_accel_z_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.accel_z
    }

    fn mut_accel_z_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.accel_z
    }

    // optional sint32 gyro_x = 15;

    pub fn clear_gyro_x(&mut self) {
        self.gyro_x = ::std::option::Option::None;
    }

    pub fn has_gyro_x(&self) -> bool {
        self.gyro_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyro_x(&mut self, v: i32) {
        self.gyro_x = ::std::option::Option::Some(v);
    }

    pub fn get_gyro_x(&self) -> i32 {
        self.gyro_x.unwrap_or(0)
    }

    fn get_gyro_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyro_x
    }

    fn mut_gyro_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyro_x
    }

    // optional sint32 gyro_y = 16;

    pub fn clear_gyro_y(&mut self) {
        self.gyro_y = ::std::option::Option::None;
    }

    pub fn has_gyro_y(&self) -> bool {
        self.gyro_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyro_y(&mut self, v: i32) {
        self.gyro_y = ::std::option::Option::Some(v);
    }

    pub fn get_gyro_y(&self) -> i32 {
        self.gyro_y.unwrap_or(0)
    }

    fn get_gyro_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyro_y
    }

    fn mut_gyro_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyro_y
    }

    // optional sint32 gyro_z = 17;

    pub fn clear_gyro_z(&mut self) {
        self.gyro_z = ::std::option::Option::None;
    }

    pub fn has_gyro_z(&self) -> bool {
        self.gyro_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyro_z(&mut self, v: i32) {
        self.gyro_z = ::std::option::Option::Some(v);
    }

    pub fn get_gyro_z(&self) -> i32 {
        self.gyro_z.unwrap_or(0)
    }

    fn get_gyro_z_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyro_z
    }

    fn mut_gyro_z_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyro_z
    }

    // optional sint32 gyroquat_w = 18;

    pub fn clear_gyroquat_w(&mut self) {
        self.gyroquat_w = ::std::option::Option::None;
    }

    pub fn has_gyroquat_w(&self) -> bool {
        self.gyroquat_w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyroquat_w(&mut self, v: i32) {
        self.gyroquat_w = ::std::option::Option::Some(v);
    }

    pub fn get_gyroquat_w(&self) -> i32 {
        self.gyroquat_w.unwrap_or(0)
    }

    fn get_gyroquat_w_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyroquat_w
    }

    fn mut_gyroquat_w_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyroquat_w
    }

    // optional sint32 gyroquat_x = 19;

    pub fn clear_gyroquat_x(&mut self) {
        self.gyroquat_x = ::std::option::Option::None;
    }

    pub fn has_gyroquat_x(&self) -> bool {
        self.gyroquat_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyroquat_x(&mut self, v: i32) {
        self.gyroquat_x = ::std::option::Option::Some(v);
    }

    pub fn get_gyroquat_x(&self) -> i32 {
        self.gyroquat_x.unwrap_or(0)
    }

    fn get_gyroquat_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyroquat_x
    }

    fn mut_gyroquat_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyroquat_x
    }

    // optional sint32 gyroquat_y = 20;

    pub fn clear_gyroquat_y(&mut self) {
        self.gyroquat_y = ::std::option::Option::None;
    }

    pub fn has_gyroquat_y(&self) -> bool {
        self.gyroquat_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyroquat_y(&mut self, v: i32) {
        self.gyroquat_y = ::std::option::Option::Some(v);
    }

    pub fn get_gyroquat_y(&self) -> i32 {
        self.gyroquat_y.unwrap_or(0)
    }

    fn get_gyroquat_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyroquat_y
    }

    fn mut_gyroquat_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyroquat_y
    }

    // optional sint32 gyroquat_z = 21;

    pub fn clear_gyroquat_z(&mut self) {
        self.gyroquat_z = ::std::option::Option::None;
    }

    pub fn has_gyroquat_z(&self) -> bool {
        self.gyroquat_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyroquat_z(&mut self, v: i32) {
        self.gyroquat_z = ::std::option::Option::Some(v);
    }

    pub fn get_gyroquat_z(&self) -> i32 {
        self.gyroquat_z.unwrap_or(0)
    }

    fn get_gyroquat_z_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyroquat_z
    }

    fn mut_gyroquat_z_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyroquat_z
    }

    // optional sint32 gyrosteeringangle = 22;

    pub fn clear_gyrosteeringangle(&mut self) {
        self.gyrosteeringangle = ::std::option::Option::None;
    }

    pub fn has_gyrosteeringangle(&self) -> bool {
        self.gyrosteeringangle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyrosteeringangle(&mut self, v: i32) {
        self.gyrosteeringangle = ::std::option::Option::Some(v);
    }

    pub fn get_gyrosteeringangle(&self) -> i32 {
        self.gyrosteeringangle.unwrap_or(0)
    }

    fn get_gyrosteeringangle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gyrosteeringangle
    }

    fn mut_gyrosteeringangle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gyrosteeringangle
    }

    // optional uint32 batterylevel = 23;

    pub fn clear_batterylevel(&mut self) {
        self.batterylevel = ::std::option::Option::None;
    }

    pub fn has_batterylevel(&self) -> bool {
        self.batterylevel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batterylevel(&mut self, v: u32) {
        self.batterylevel = ::std::option::Option::Some(v);
    }

    pub fn get_batterylevel(&self) -> u32 {
        self.batterylevel.unwrap_or(0)
    }

    fn get_batterylevel_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.batterylevel
    }

    fn mut_batterylevel_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.batterylevel
    }
}

impl ::protobuf::Message for CInputControllerStateMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint64()?;
                    self.buttons = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.left_pad_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.left_pad_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.right_pad_x = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.right_pad_y = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.left_stick_x = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.left_stick_y = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.left_analog = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.right_analog = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.accel_x = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.accel_y = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.accel_z = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyro_x = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyro_y = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyro_z = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyroquat_w = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyroquat_x = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyroquat_y = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyroquat_z = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_sint32()?;
                    self.gyrosteeringangle = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.batterylevel = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.buttons {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.left_pad_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        };
        if let Some(v) = self.left_pad_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, v);
        };
        if let Some(v) = self.right_pad_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
        };
        if let Some(v) = self.right_pad_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
        };
        if let Some(v) = self.left_stick_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
        };
        if let Some(v) = self.left_stick_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, v);
        };
        if let Some(v) = self.left_analog {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.right_analog {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.accel_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, v);
        };
        if let Some(v) = self.accel_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, v);
        };
        if let Some(v) = self.accel_z {
            my_size += ::protobuf::rt::value_varint_zigzag_size(14, v);
        };
        if let Some(v) = self.gyro_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(15, v);
        };
        if let Some(v) = self.gyro_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(16, v);
        };
        if let Some(v) = self.gyro_z {
            my_size += ::protobuf::rt::value_varint_zigzag_size(17, v);
        };
        if let Some(v) = self.gyroquat_w {
            my_size += ::protobuf::rt::value_varint_zigzag_size(18, v);
        };
        if let Some(v) = self.gyroquat_x {
            my_size += ::protobuf::rt::value_varint_zigzag_size(19, v);
        };
        if let Some(v) = self.gyroquat_y {
            my_size += ::protobuf::rt::value_varint_zigzag_size(20, v);
        };
        if let Some(v) = self.gyroquat_z {
            my_size += ::protobuf::rt::value_varint_zigzag_size(21, v);
        };
        if let Some(v) = self.gyrosteeringangle {
            my_size += ::protobuf::rt::value_varint_zigzag_size(22, v);
        };
        if let Some(v) = self.batterylevel {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.controller_index {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.buttons {
            os.write_uint64(3, v)?;
        };
        if let Some(v) = self.left_pad_x {
            os.write_sint32(4, v)?;
        };
        if let Some(v) = self.left_pad_y {
            os.write_sint32(5, v)?;
        };
        if let Some(v) = self.right_pad_x {
            os.write_sint32(6, v)?;
        };
        if let Some(v) = self.right_pad_y {
            os.write_sint32(7, v)?;
        };
        if let Some(v) = self.left_stick_x {
            os.write_sint32(8, v)?;
        };
        if let Some(v) = self.left_stick_y {
            os.write_sint32(9, v)?;
        };
        if let Some(v) = self.left_analog {
            os.write_uint32(10, v)?;
        };
        if let Some(v) = self.right_analog {
            os.write_uint32(11, v)?;
        };
        if let Some(v) = self.accel_x {
            os.write_sint32(12, v)?;
        };
        if let Some(v) = self.accel_y {
            os.write_sint32(13, v)?;
        };
        if let Some(v) = self.accel_z {
            os.write_sint32(14, v)?;
        };
        if let Some(v) = self.gyro_x {
            os.write_sint32(15, v)?;
        };
        if let Some(v) = self.gyro_y {
            os.write_sint32(16, v)?;
        };
        if let Some(v) = self.gyro_z {
            os.write_sint32(17, v)?;
        };
        if let Some(v) = self.gyroquat_w {
            os.write_sint32(18, v)?;
        };
        if let Some(v) = self.gyroquat_x {
            os.write_sint32(19, v)?;
        };
        if let Some(v) = self.gyroquat_y {
            os.write_sint32(20, v)?;
        };
        if let Some(v) = self.gyroquat_z {
            os.write_sint32(21, v)?;
        };
        if let Some(v) = self.gyrosteeringangle {
            os.write_sint32(22, v)?;
        };
        if let Some(v) = self.batterylevel {
            os.write_uint32(23, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputControllerStateMsg {
    fn new() -> CInputControllerStateMsg {
        CInputControllerStateMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputControllerStateMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputControllerStateMsg::get_input_mark_for_reflect,
                    CInputControllerStateMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CInputControllerStateMsg::get_controller_index_for_reflect,
                    CInputControllerStateMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "buttons",
                    CInputControllerStateMsg::get_buttons_for_reflect,
                    CInputControllerStateMsg::mut_buttons_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "left_pad_x",
                    CInputControllerStateMsg::get_left_pad_x_for_reflect,
                    CInputControllerStateMsg::mut_left_pad_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "left_pad_y",
                    CInputControllerStateMsg::get_left_pad_y_for_reflect,
                    CInputControllerStateMsg::mut_left_pad_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "right_pad_x",
                    CInputControllerStateMsg::get_right_pad_x_for_reflect,
                    CInputControllerStateMsg::mut_right_pad_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "right_pad_y",
                    CInputControllerStateMsg::get_right_pad_y_for_reflect,
                    CInputControllerStateMsg::mut_right_pad_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "left_stick_x",
                    CInputControllerStateMsg::get_left_stick_x_for_reflect,
                    CInputControllerStateMsg::mut_left_stick_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "left_stick_y",
                    CInputControllerStateMsg::get_left_stick_y_for_reflect,
                    CInputControllerStateMsg::mut_left_stick_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "left_analog",
                    CInputControllerStateMsg::get_left_analog_for_reflect,
                    CInputControllerStateMsg::mut_left_analog_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "right_analog",
                    CInputControllerStateMsg::get_right_analog_for_reflect,
                    CInputControllerStateMsg::mut_right_analog_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "accel_x",
                    CInputControllerStateMsg::get_accel_x_for_reflect,
                    CInputControllerStateMsg::mut_accel_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "accel_y",
                    CInputControllerStateMsg::get_accel_y_for_reflect,
                    CInputControllerStateMsg::mut_accel_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "accel_z",
                    CInputControllerStateMsg::get_accel_z_for_reflect,
                    CInputControllerStateMsg::mut_accel_z_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyro_x",
                    CInputControllerStateMsg::get_gyro_x_for_reflect,
                    CInputControllerStateMsg::mut_gyro_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyro_y",
                    CInputControllerStateMsg::get_gyro_y_for_reflect,
                    CInputControllerStateMsg::mut_gyro_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyro_z",
                    CInputControllerStateMsg::get_gyro_z_for_reflect,
                    CInputControllerStateMsg::mut_gyro_z_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyroquat_w",
                    CInputControllerStateMsg::get_gyroquat_w_for_reflect,
                    CInputControllerStateMsg::mut_gyroquat_w_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyroquat_x",
                    CInputControllerStateMsg::get_gyroquat_x_for_reflect,
                    CInputControllerStateMsg::mut_gyroquat_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyroquat_y",
                    CInputControllerStateMsg::get_gyroquat_y_for_reflect,
                    CInputControllerStateMsg::mut_gyroquat_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyroquat_z",
                    CInputControllerStateMsg::get_gyroquat_z_for_reflect,
                    CInputControllerStateMsg::mut_gyroquat_z_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "gyrosteeringangle",
                    CInputControllerStateMsg::get_gyrosteeringangle_for_reflect,
                    CInputControllerStateMsg::mut_gyrosteeringangle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "batterylevel",
                    CInputControllerStateMsg::get_batterylevel_for_reflect,
                    CInputControllerStateMsg::mut_batterylevel_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputControllerStateMsg>(
                    "CInputControllerStateMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputControllerStateMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_controller_index();
        self.clear_buttons();
        self.clear_left_pad_x();
        self.clear_left_pad_y();
        self.clear_right_pad_x();
        self.clear_right_pad_y();
        self.clear_left_stick_x();
        self.clear_left_stick_y();
        self.clear_left_analog();
        self.clear_right_analog();
        self.clear_accel_x();
        self.clear_accel_y();
        self.clear_accel_z();
        self.clear_gyro_x();
        self.clear_gyro_y();
        self.clear_gyro_z();
        self.clear_gyroquat_w();
        self.clear_gyroquat_x();
        self.clear_gyroquat_y();
        self.clear_gyroquat_z();
        self.clear_gyrosteeringangle();
        self.clear_batterylevel();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputControllerStateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputControllerStateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputControllerStateHIDMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    controller_index: ::std::option::Option<i32>,
    capabilities: ::std::option::Option<u32>,
    state_payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    status_payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    report_bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputControllerStateHIDMsg {}

impl CInputControllerStateHIDMsg {
    pub fn new() -> CInputControllerStateHIDMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputControllerStateHIDMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputControllerStateHIDMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputControllerStateHIDMsg,
        };
        unsafe {
            instance.get(CInputControllerStateHIDMsg::new)
        }
    }

    // optional uint32 input_mark = 1;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // optional int32 controller_index = 2;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // optional uint32 capabilities = 3;

    pub fn clear_capabilities(&mut self) {
        self.capabilities = ::std::option::Option::None;
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: u32) {
        self.capabilities = ::std::option::Option::Some(v);
    }

    pub fn get_capabilities(&self) -> u32 {
        self.capabilities.unwrap_or(0)
    }

    fn get_capabilities_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.capabilities
    }

    fn mut_capabilities_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.capabilities
    }

    // optional bytes state_payload = 4;

    pub fn clear_state_payload(&mut self) {
        self.state_payload.clear();
    }

    pub fn has_state_payload(&self) -> bool {
        self.state_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.state_payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state_payload.is_none() {
            self.state_payload.set_default();
        };
        self.state_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.state_payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_state_payload(&self) -> &[u8] {
        match self.state_payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_state_payload_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.state_payload
    }

    fn mut_state_payload_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.state_payload
    }

    // optional bytes status_payload = 5;

    pub fn clear_status_payload(&mut self) {
        self.status_payload.clear();
    }

    pub fn has_status_payload(&self) -> bool {
        self.status_payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.status_payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.status_payload.is_none() {
            self.status_payload.set_default();
        };
        self.status_payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.status_payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_status_payload(&self) -> &[u8] {
        match self.status_payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_status_payload_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.status_payload
    }

    fn mut_status_payload_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.status_payload
    }

    // optional bytes report_bytes = 6;

    pub fn clear_report_bytes(&mut self) {
        self.report_bytes.clear();
    }

    pub fn has_report_bytes(&self) -> bool {
        self.report_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.report_bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.report_bytes.is_none() {
            self.report_bytes.set_default();
        };
        self.report_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.report_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_report_bytes(&self) -> &[u8] {
        match self.report_bytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_report_bytes_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.report_bytes
    }

    fn mut_report_bytes_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.report_bytes
    }
}

impl ::protobuf::Message for CInputControllerStateHIDMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.capabilities = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.state_payload)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.status_payload)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.report_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.capabilities {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.state_payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        };
        if let Some(v) = self.status_payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        };
        if let Some(v) = self.report_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.controller_index {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.capabilities {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.state_payload.as_ref() {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.status_payload.as_ref() {
            os.write_bytes(5, &v)?;
        };
        if let Some(v) = self.report_bytes.as_ref() {
            os.write_bytes(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputControllerStateHIDMsg {
    fn new() -> CInputControllerStateHIDMsg {
        CInputControllerStateHIDMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputControllerStateHIDMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CInputControllerStateHIDMsg::get_input_mark_for_reflect,
                    CInputControllerStateHIDMsg::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CInputControllerStateHIDMsg::get_controller_index_for_reflect,
                    CInputControllerStateHIDMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "capabilities",
                    CInputControllerStateHIDMsg::get_capabilities_for_reflect,
                    CInputControllerStateHIDMsg::mut_capabilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "state_payload",
                    CInputControllerStateHIDMsg::get_state_payload_for_reflect,
                    CInputControllerStateHIDMsg::mut_state_payload_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "status_payload",
                    CInputControllerStateHIDMsg::get_status_payload_for_reflect,
                    CInputControllerStateHIDMsg::mut_status_payload_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "report_bytes",
                    CInputControllerStateHIDMsg::get_report_bytes_for_reflect,
                    CInputControllerStateHIDMsg::mut_report_bytes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputControllerStateHIDMsg>(
                    "CInputControllerStateHIDMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputControllerStateHIDMsg {
    fn clear(&mut self) {
        self.clear_input_mark();
        self.clear_controller_index();
        self.clear_capabilities();
        self.clear_state_payload();
        self.clear_status_payload();
        self.clear_report_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputControllerStateHIDMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputControllerStateHIDMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputControllerWirelessPresenceMsg {
    // message fields
    wireless_present: ::std::option::Option<bool>,
    wireless_available: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputControllerWirelessPresenceMsg {}

impl CInputControllerWirelessPresenceMsg {
    pub fn new() -> CInputControllerWirelessPresenceMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputControllerWirelessPresenceMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputControllerWirelessPresenceMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputControllerWirelessPresenceMsg,
        };
        unsafe {
            instance.get(CInputControllerWirelessPresenceMsg::new)
        }
    }

    // optional bool wireless_present = 1;

    pub fn clear_wireless_present(&mut self) {
        self.wireless_present = ::std::option::Option::None;
    }

    pub fn has_wireless_present(&self) -> bool {
        self.wireless_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wireless_present(&mut self, v: bool) {
        self.wireless_present = ::std::option::Option::Some(v);
    }

    pub fn get_wireless_present(&self) -> bool {
        self.wireless_present.unwrap_or(false)
    }

    fn get_wireless_present_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.wireless_present
    }

    fn mut_wireless_present_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.wireless_present
    }

    // optional bool wireless_available = 2;

    pub fn clear_wireless_available(&mut self) {
        self.wireless_available = ::std::option::Option::None;
    }

    pub fn has_wireless_available(&self) -> bool {
        self.wireless_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wireless_available(&mut self, v: bool) {
        self.wireless_available = ::std::option::Option::Some(v);
    }

    pub fn get_wireless_available(&self) -> bool {
        self.wireless_available.unwrap_or(false)
    }

    fn get_wireless_available_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.wireless_available
    }

    fn mut_wireless_available_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.wireless_available
    }
}

impl ::protobuf::Message for CInputControllerWirelessPresenceMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.wireless_present = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.wireless_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wireless_present {
            my_size += 2;
        };
        if let Some(v) = self.wireless_available {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wireless_present {
            os.write_bool(1, v)?;
        };
        if let Some(v) = self.wireless_available {
            os.write_bool(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputControllerWirelessPresenceMsg {
    fn new() -> CInputControllerWirelessPresenceMsg {
        CInputControllerWirelessPresenceMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputControllerWirelessPresenceMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wireless_present",
                    CInputControllerWirelessPresenceMsg::get_wireless_present_for_reflect,
                    CInputControllerWirelessPresenceMsg::mut_wireless_present_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "wireless_available",
                    CInputControllerWirelessPresenceMsg::get_wireless_available_for_reflect,
                    CInputControllerWirelessPresenceMsg::mut_wireless_available_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputControllerWirelessPresenceMsg>(
                    "CInputControllerWirelessPresenceMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputControllerWirelessPresenceMsg {
    fn clear(&mut self) {
        self.clear_wireless_present();
        self.clear_wireless_available();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputControllerWirelessPresenceMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputControllerWirelessPresenceMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputControllerDetachedMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CInputControllerDetachedMsg {}

impl CInputControllerDetachedMsg {
    pub fn new() -> CInputControllerDetachedMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CInputControllerDetachedMsg {
        static mut instance: ::protobuf::lazy::Lazy<CInputControllerDetachedMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CInputControllerDetachedMsg,
        };
        unsafe {
            instance.get(CInputControllerDetachedMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }
}

impl ::protobuf::Message for CInputControllerDetachedMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CInputControllerDetachedMsg {
    fn new() -> CInputControllerDetachedMsg {
        CInputControllerDetachedMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CInputControllerDetachedMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CInputControllerDetachedMsg::get_controller_index_for_reflect,
                    CInputControllerDetachedMsg::mut_controller_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CInputControllerDetachedMsg>(
                    "CInputControllerDetachedMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CInputControllerDetachedMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputControllerDetachedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputControllerDetachedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTriggerHapticPulseMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    pad_index: ::std::option::Option<i32>,
    duration_microsec: ::std::option::Option<u32>,
    interval_microsec: ::std::option::Option<u32>,
    repeat_count: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CTriggerHapticPulseMsg {}

impl CTriggerHapticPulseMsg {
    pub fn new() -> CTriggerHapticPulseMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CTriggerHapticPulseMsg {
        static mut instance: ::protobuf::lazy::Lazy<CTriggerHapticPulseMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CTriggerHapticPulseMsg,
        };
        unsafe {
            instance.get(CTriggerHapticPulseMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // required int32 pad_index = 2;

    pub fn clear_pad_index(&mut self) {
        self.pad_index = ::std::option::Option::None;
    }

    pub fn has_pad_index(&self) -> bool {
        self.pad_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_index(&mut self, v: i32) {
        self.pad_index = ::std::option::Option::Some(v);
    }

    pub fn get_pad_index(&self) -> i32 {
        self.pad_index.unwrap_or(0)
    }

    fn get_pad_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.pad_index
    }

    fn mut_pad_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.pad_index
    }

    // required uint32 duration_microsec = 3;

    pub fn clear_duration_microsec(&mut self) {
        self.duration_microsec = ::std::option::Option::None;
    }

    pub fn has_duration_microsec(&self) -> bool {
        self.duration_microsec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_microsec(&mut self, v: u32) {
        self.duration_microsec = ::std::option::Option::Some(v);
    }

    pub fn get_duration_microsec(&self) -> u32 {
        self.duration_microsec.unwrap_or(0)
    }

    fn get_duration_microsec_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.duration_microsec
    }

    fn mut_duration_microsec_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.duration_microsec
    }

    // optional uint32 interval_microsec = 4;

    pub fn clear_interval_microsec(&mut self) {
        self.interval_microsec = ::std::option::Option::None;
    }

    pub fn has_interval_microsec(&self) -> bool {
        self.interval_microsec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_microsec(&mut self, v: u32) {
        self.interval_microsec = ::std::option::Option::Some(v);
    }

    pub fn get_interval_microsec(&self) -> u32 {
        self.interval_microsec.unwrap_or(0)
    }

    fn get_interval_microsec_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.interval_microsec
    }

    fn mut_interval_microsec_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.interval_microsec
    }

    // optional uint32 repeat_count = 5;

    pub fn clear_repeat_count(&mut self) {
        self.repeat_count = ::std::option::Option::None;
    }

    pub fn has_repeat_count(&self) -> bool {
        self.repeat_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat_count(&mut self, v: u32) {
        self.repeat_count = ::std::option::Option::Some(v);
    }

    pub fn get_repeat_count(&self) -> u32 {
        self.repeat_count.unwrap_or(0)
    }

    fn get_repeat_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.repeat_count
    }

    fn mut_repeat_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.repeat_count
    }

    // optional uint32 flags = 6;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }
}

impl ::protobuf::Message for CTriggerHapticPulseMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        if self.pad_index.is_none() {
            return false;
        };
        if self.duration_microsec.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.pad_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.duration_microsec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.interval_microsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.repeat_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.pad_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.duration_microsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.interval_microsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.repeat_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.pad_index {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.duration_microsec {
            os.write_uint32(3, v)?;
        };
        if let Some(v) = self.interval_microsec {
            os.write_uint32(4, v)?;
        };
        if let Some(v) = self.repeat_count {
            os.write_uint32(5, v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CTriggerHapticPulseMsg {
    fn new() -> CTriggerHapticPulseMsg {
        CTriggerHapticPulseMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CTriggerHapticPulseMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CTriggerHapticPulseMsg::get_controller_index_for_reflect,
                    CTriggerHapticPulseMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pad_index",
                    CTriggerHapticPulseMsg::get_pad_index_for_reflect,
                    CTriggerHapticPulseMsg::mut_pad_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration_microsec",
                    CTriggerHapticPulseMsg::get_duration_microsec_for_reflect,
                    CTriggerHapticPulseMsg::mut_duration_microsec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "interval_microsec",
                    CTriggerHapticPulseMsg::get_interval_microsec_for_reflect,
                    CTriggerHapticPulseMsg::mut_interval_microsec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "repeat_count",
                    CTriggerHapticPulseMsg::get_repeat_count_for_reflect,
                    CTriggerHapticPulseMsg::mut_repeat_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    CTriggerHapticPulseMsg::get_flags_for_reflect,
                    CTriggerHapticPulseMsg::mut_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CTriggerHapticPulseMsg>(
                    "CTriggerHapticPulseMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CTriggerHapticPulseMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.clear_pad_index();
        self.clear_duration_microsec();
        self.clear_interval_microsec();
        self.clear_repeat_count();
        self.clear_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTriggerHapticPulseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTriggerHapticPulseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetControllerPairingEnabledMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    timeout: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetControllerPairingEnabledMsg {}

impl CSetControllerPairingEnabledMsg {
    pub fn new() -> CSetControllerPairingEnabledMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetControllerPairingEnabledMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetControllerPairingEnabledMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetControllerPairingEnabledMsg,
        };
        unsafe {
            instance.get(CSetControllerPairingEnabledMsg::new)
        }
    }

    // optional bool enabled = 1;

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    fn get_enabled_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enabled
    }

    fn mut_enabled_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enabled
    }

    // optional int32 timeout = 2;

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: i32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    pub fn get_timeout(&self) -> i32 {
        self.timeout.unwrap_or(0)
    }

    fn get_timeout_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.timeout
    }

    fn mut_timeout_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.timeout
    }
}

impl ::protobuf::Message for CSetControllerPairingEnabledMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.enabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        };
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        };
        if let Some(v) = self.timeout {
            os.write_int32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetControllerPairingEnabledMsg {
    fn new() -> CSetControllerPairingEnabledMsg {
        CSetControllerPairingEnabledMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetControllerPairingEnabledMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    CSetControllerPairingEnabledMsg::get_enabled_for_reflect,
                    CSetControllerPairingEnabledMsg::mut_enabled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timeout",
                    CSetControllerPairingEnabledMsg::get_timeout_for_reflect,
                    CSetControllerPairingEnabledMsg::mut_timeout_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetControllerPairingEnabledMsg>(
                    "CSetControllerPairingEnabledMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetControllerPairingEnabledMsg {
    fn clear(&mut self) {
        self.clear_enabled();
        self.clear_timeout();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetControllerPairingEnabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetControllerPairingEnabledMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetControllerPairingResultMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    commit_pairing: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetControllerPairingResultMsg {}

impl CSetControllerPairingResultMsg {
    pub fn new() -> CSetControllerPairingResultMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetControllerPairingResultMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetControllerPairingResultMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetControllerPairingResultMsg,
        };
        unsafe {
            instance.get(CSetControllerPairingResultMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // optional bool commit_pairing = 2;

    pub fn clear_commit_pairing(&mut self) {
        self.commit_pairing = ::std::option::Option::None;
    }

    pub fn has_commit_pairing(&self) -> bool {
        self.commit_pairing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_pairing(&mut self, v: bool) {
        self.commit_pairing = ::std::option::Option::Some(v);
    }

    pub fn get_commit_pairing(&self) -> bool {
        self.commit_pairing.unwrap_or(false)
    }

    fn get_commit_pairing_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.commit_pairing
    }

    fn mut_commit_pairing_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.commit_pairing
    }
}

impl ::protobuf::Message for CSetControllerPairingResultMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_bool()?;
                    self.commit_pairing = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.commit_pairing {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.commit_pairing {
            os.write_bool(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetControllerPairingResultMsg {
    fn new() -> CSetControllerPairingResultMsg {
        CSetControllerPairingResultMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetControllerPairingResultMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CSetControllerPairingResultMsg::get_controller_index_for_reflect,
                    CSetControllerPairingResultMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "commit_pairing",
                    CSetControllerPairingResultMsg::get_commit_pairing_for_reflect,
                    CSetControllerPairingResultMsg::mut_commit_pairing_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetControllerPairingResultMsg>(
                    "CSetControllerPairingResultMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetControllerPairingResultMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.clear_commit_pairing();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetControllerPairingResultMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetControllerPairingResultMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTriggerControllerDisconnectMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CTriggerControllerDisconnectMsg {}

impl CTriggerControllerDisconnectMsg {
    pub fn new() -> CTriggerControllerDisconnectMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CTriggerControllerDisconnectMsg {
        static mut instance: ::protobuf::lazy::Lazy<CTriggerControllerDisconnectMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CTriggerControllerDisconnectMsg,
        };
        unsafe {
            instance.get(CTriggerControllerDisconnectMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }
}

impl ::protobuf::Message for CTriggerControllerDisconnectMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CTriggerControllerDisconnectMsg {
    fn new() -> CTriggerControllerDisconnectMsg {
        CTriggerControllerDisconnectMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CTriggerControllerDisconnectMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CTriggerControllerDisconnectMsg::get_controller_index_for_reflect,
                    CTriggerControllerDisconnectMsg::mut_controller_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CTriggerControllerDisconnectMsg>(
                    "CTriggerControllerDisconnectMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CTriggerControllerDisconnectMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTriggerControllerDisconnectMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTriggerControllerDisconnectMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetControllerSettingsMsg {
    // message fields
    controller_index: ::std::option::Option<i32>,
    raw_settings: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetControllerSettingsMsg {}

impl CSetControllerSettingsMsg {
    pub fn new() -> CSetControllerSettingsMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetControllerSettingsMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetControllerSettingsMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetControllerSettingsMsg,
        };
        unsafe {
            instance.get(CSetControllerSettingsMsg::new)
        }
    }

    // required int32 controller_index = 1;

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    pub fn get_controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    fn get_controller_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.controller_index
    }

    fn mut_controller_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.controller_index
    }

    // optional bytes raw_settings = 2;

    pub fn clear_raw_settings(&mut self) {
        self.raw_settings.clear();
    }

    pub fn has_raw_settings(&self) -> bool {
        self.raw_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_settings(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_settings = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_settings(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_settings.is_none() {
            self.raw_settings.set_default();
        };
        self.raw_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_settings(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_settings.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_raw_settings(&self) -> &[u8] {
        match self.raw_settings.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_raw_settings_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.raw_settings
    }

    fn mut_raw_settings_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.raw_settings
    }
}

impl ::protobuf::Message for CSetControllerSettingsMsg {
    fn is_initialized(&self) -> bool {
        if self.controller_index.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.controller_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.raw_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.raw_settings.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.raw_settings.as_ref() {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetControllerSettingsMsg {
    fn new() -> CSetControllerSettingsMsg {
        CSetControllerSettingsMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetControllerSettingsMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller_index",
                    CSetControllerSettingsMsg::get_controller_index_for_reflect,
                    CSetControllerSettingsMsg::mut_controller_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "raw_settings",
                    CSetControllerSettingsMsg::get_raw_settings_for_reflect,
                    CSetControllerSettingsMsg::mut_raw_settings_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetControllerSettingsMsg>(
                    "CSetControllerSettingsMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetControllerSettingsMsg {
    fn clear(&mut self) {
        self.clear_controller_index();
        self.clear_raw_settings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetControllerSettingsMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetControllerSettingsMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetGammaRampMsg {
    // message fields
    gamma_ramp: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetGammaRampMsg {}

impl CSetGammaRampMsg {
    pub fn new() -> CSetGammaRampMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetGammaRampMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetGammaRampMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetGammaRampMsg,
        };
        unsafe {
            instance.get(CSetGammaRampMsg::new)
        }
    }

    // optional bytes gamma_ramp = 1;

    pub fn clear_gamma_ramp(&mut self) {
        self.gamma_ramp.clear();
    }

    pub fn has_gamma_ramp(&self) -> bool {
        self.gamma_ramp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma_ramp(&mut self, v: ::std::vec::Vec<u8>) {
        self.gamma_ramp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma_ramp(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gamma_ramp.is_none() {
            self.gamma_ramp.set_default();
        };
        self.gamma_ramp.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma_ramp(&mut self) -> ::std::vec::Vec<u8> {
        self.gamma_ramp.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_gamma_ramp(&self) -> &[u8] {
        match self.gamma_ramp.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_gamma_ramp_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.gamma_ramp
    }

    fn mut_gamma_ramp_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.gamma_ramp
    }
}

impl ::protobuf::Message for CSetGammaRampMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gamma_ramp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gamma_ramp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gamma_ramp.as_ref() {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetGammaRampMsg {
    fn new() -> CSetGammaRampMsg {
        CSetGammaRampMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetGammaRampMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gamma_ramp",
                    CSetGammaRampMsg::get_gamma_ramp_for_reflect,
                    CSetGammaRampMsg::mut_gamma_ramp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetGammaRampMsg>(
                    "CSetGammaRampMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetGammaRampMsg {
    fn clear(&mut self) {
        self.clear_gamma_ramp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetGammaRampMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetGammaRampMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetActivityMsg {
    // message fields
    activity: ::std::option::Option<EStreamActivity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSetActivityMsg {}

impl CSetActivityMsg {
    pub fn new() -> CSetActivityMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSetActivityMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSetActivityMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSetActivityMsg,
        };
        unsafe {
            instance.get(CSetActivityMsg::new)
        }
    }

    // optional .EStreamActivity activity = 1;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: EStreamActivity) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> EStreamActivity {
        self.activity.unwrap_or(EStreamActivity::k_EStreamActivityIdle)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<EStreamActivity> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamActivity> {
        &mut self.activity
    }
}

impl ::protobuf::Message for CSetActivityMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_enum(1, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSetActivityMsg {
    fn new() -> CSetActivityMsg {
        CSetActivityMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSetActivityMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamActivity>>(
                    "activity",
                    CSetActivityMsg::get_activity_for_reflect,
                    CSetActivityMsg::mut_activity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSetActivityMsg>(
                    "CSetActivityMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSetActivityMsg {
    fn clear(&mut self) {
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetActivityMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetActivityMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSystemSuspendMsg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSystemSuspendMsg {}

impl CSystemSuspendMsg {
    pub fn new() -> CSystemSuspendMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSystemSuspendMsg {
        static mut instance: ::protobuf::lazy::Lazy<CSystemSuspendMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSystemSuspendMsg,
        };
        unsafe {
            instance.get(CSystemSuspendMsg::new)
        }
    }
}

impl ::protobuf::Message for CSystemSuspendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSystemSuspendMsg {
    fn new() -> CSystemSuspendMsg {
        CSystemSuspendMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSystemSuspendMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CSystemSuspendMsg>(
                    "CSystemSuspendMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSystemSuspendMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSystemSuspendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSystemSuspendMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereRequestMsg {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVirtualHereRequestMsg {}

impl CVirtualHereRequestMsg {
    pub fn new() -> CVirtualHereRequestMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVirtualHereRequestMsg {
        static mut instance: ::protobuf::lazy::Lazy<CVirtualHereRequestMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVirtualHereRequestMsg,
        };
        unsafe {
            instance.get(CVirtualHereRequestMsg::new)
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }
}

impl ::protobuf::Message for CVirtualHereRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVirtualHereRequestMsg {
    fn new() -> CVirtualHereRequestMsg {
        CVirtualHereRequestMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVirtualHereRequestMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    CVirtualHereRequestMsg::get_hostname_for_reflect,
                    CVirtualHereRequestMsg::mut_hostname_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereRequestMsg>(
                    "CVirtualHereRequestMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVirtualHereRequestMsg {
    fn clear(&mut self) {
        self.clear_hostname();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereRequestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereReadyMsg {
    // message fields
    licensed_device_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVirtualHereReadyMsg {}

impl CVirtualHereReadyMsg {
    pub fn new() -> CVirtualHereReadyMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVirtualHereReadyMsg {
        static mut instance: ::protobuf::lazy::Lazy<CVirtualHereReadyMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVirtualHereReadyMsg,
        };
        unsafe {
            instance.get(CVirtualHereReadyMsg::new)
        }
    }

    // optional uint32 licensed_device_count = 1;

    pub fn clear_licensed_device_count(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
    }

    pub fn has_licensed_device_count(&self) -> bool {
        self.licensed_device_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_licensed_device_count(&mut self, v: u32) {
        self.licensed_device_count = ::std::option::Option::Some(v);
    }

    pub fn get_licensed_device_count(&self) -> u32 {
        self.licensed_device_count.unwrap_or(0)
    }

    fn get_licensed_device_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.licensed_device_count
    }

    fn mut_licensed_device_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.licensed_device_count
    }
}

impl ::protobuf::Message for CVirtualHereReadyMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.licensed_device_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.licensed_device_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.licensed_device_count {
            os.write_uint32(1, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVirtualHereReadyMsg {
    fn new() -> CVirtualHereReadyMsg {
        CVirtualHereReadyMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVirtualHereReadyMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "licensed_device_count",
                    CVirtualHereReadyMsg::get_licensed_device_count_for_reflect,
                    CVirtualHereReadyMsg::mut_licensed_device_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereReadyMsg>(
                    "CVirtualHereReadyMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVirtualHereReadyMsg {
    fn clear(&mut self) {
        self.clear_licensed_device_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereReadyMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereReadyMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereShareDeviceMsg {
    // message fields
    device_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVirtualHereShareDeviceMsg {}

impl CVirtualHereShareDeviceMsg {
    pub fn new() -> CVirtualHereShareDeviceMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVirtualHereShareDeviceMsg {
        static mut instance: ::protobuf::lazy::Lazy<CVirtualHereShareDeviceMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVirtualHereShareDeviceMsg,
        };
        unsafe {
            instance.get(CVirtualHereShareDeviceMsg::new)
        }
    }

    // optional string device_address = 1;

    pub fn clear_device_address(&mut self) {
        self.device_address.clear();
    }

    pub fn has_device_address(&self) -> bool {
        self.device_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_address(&mut self, v: ::std::string::String) {
        self.device_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_address(&mut self) -> &mut ::std::string::String {
        if self.device_address.is_none() {
            self.device_address.set_default();
        };
        self.device_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_address(&mut self) -> ::std::string::String {
        self.device_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_device_address(&self) -> &str {
        match self.device_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_device_address_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.device_address
    }

    fn mut_device_address_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.device_address
    }
}

impl ::protobuf::Message for CVirtualHereShareDeviceMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device_address.as_ref() {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVirtualHereShareDeviceMsg {
    fn new() -> CVirtualHereShareDeviceMsg {
        CVirtualHereShareDeviceMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVirtualHereShareDeviceMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_address",
                    CVirtualHereShareDeviceMsg::get_device_address_for_reflect,
                    CVirtualHereShareDeviceMsg::mut_device_address_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereShareDeviceMsg>(
                    "CVirtualHereShareDeviceMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVirtualHereShareDeviceMsg {
    fn clear(&mut self) {
        self.clear_device_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereShareDeviceMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereShareDeviceMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamDataLostMsg {
    // message fields
    packets: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStreamDataLostMsg {}

impl CStreamDataLostMsg {
    pub fn new() -> CStreamDataLostMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStreamDataLostMsg {
        static mut instance: ::protobuf::lazy::Lazy<CStreamDataLostMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStreamDataLostMsg,
        };
        unsafe {
            instance.get(CStreamDataLostMsg::new)
        }
    }

    // repeated uint32 packets = 1;

    pub fn clear_packets(&mut self) {
        self.packets.clear();
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: ::std::vec::Vec<u32>) {
        self.packets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packets
    }

    // Take field
    pub fn take_packets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packets, ::std::vec::Vec::new())
    }

    pub fn get_packets(&self) -> &[u32] {
        &self.packets
    }

    fn get_packets_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.packets
    }

    fn mut_packets_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packets
    }
}

impl ::protobuf::Message for CStreamDataLostMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packets {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packets {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStreamDataLostMsg {
    fn new() -> CStreamDataLostMsg {
        CStreamDataLostMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStreamDataLostMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "packets",
                    CStreamDataLostMsg::get_packets_for_reflect,
                    CStreamDataLostMsg::mut_packets_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStreamDataLostMsg>(
                    "CStreamDataLostMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStreamDataLostMsg {
    fn clear(&mut self) {
        self.clear_packets();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamDataLostMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamDataLostMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAudioFormat {
    // message fields
    format: ::std::option::Option<EAudioFormat>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAudioFormat {}

impl CAudioFormat {
    pub fn new() -> CAudioFormat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAudioFormat {
        static mut instance: ::protobuf::lazy::Lazy<CAudioFormat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAudioFormat,
        };
        unsafe {
            instance.get(CAudioFormat::new)
        }
    }

    // required .EAudioFormat format = 1;

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EAudioFormat) {
        self.format = ::std::option::Option::Some(v);
    }

    pub fn get_format(&self) -> EAudioFormat {
        self.format.unwrap_or(EAudioFormat::k_EAudioFormatNone)
    }

    fn get_format_for_reflect(&self) -> &::std::option::Option<EAudioFormat> {
        &self.format
    }

    fn mut_format_for_reflect(&mut self) -> &mut ::std::option::Option<EAudioFormat> {
        &mut self.format
    }

    // optional uint32 frequency = 2;

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    fn get_frequency_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.frequency
    }

    fn mut_frequency_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.frequency
    }

    // optional uint32 channels = 3;

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }

    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    fn get_channels_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channels
    }

    fn mut_channels_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channels
    }
}

impl ::protobuf::Message for CAudioFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.format = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.channels = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.frequency {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.channels {
            os.write_uint32(3, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAudioFormat {
    fn new() -> CAudioFormat {
        CAudioFormat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAudioFormat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EAudioFormat>>(
                    "format",
                    CAudioFormat::get_format_for_reflect,
                    CAudioFormat::mut_format_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    CAudioFormat::get_frequency_for_reflect,
                    CAudioFormat::mut_frequency_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channels",
                    CAudioFormat::get_channels_for_reflect,
                    CAudioFormat::mut_channels_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAudioFormat>(
                    "CAudioFormat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAudioFormat {
    fn clear(&mut self) {
        self.clear_format();
        self.clear_frequency();
        self.clear_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAudioFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoFormat {
    // message fields
    format: ::std::option::Option<EVideoFormat>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CVideoFormat {}

impl CVideoFormat {
    pub fn new() -> CVideoFormat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CVideoFormat {
        static mut instance: ::protobuf::lazy::Lazy<CVideoFormat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CVideoFormat,
        };
        unsafe {
            instance.get(CVideoFormat::new)
        }
    }

    // required .EVideoFormat format = 1;

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EVideoFormat) {
        self.format = ::std::option::Option::Some(v);
    }

    pub fn get_format(&self) -> EVideoFormat {
        self.format.unwrap_or(EVideoFormat::k_EVideoFormatNone)
    }

    fn get_format_for_reflect(&self) -> &::std::option::Option<EVideoFormat> {
        &self.format
    }

    fn mut_format_for_reflect(&mut self) -> &mut ::std::option::Option<EVideoFormat> {
        &mut self.format
    }

    // optional uint32 width = 2;

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    fn get_width_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.width
    }

    fn mut_width_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.width
    }

    // optional uint32 height = 3;

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    fn get_height_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.height
    }

    fn mut_height_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.height
    }
}

impl ::protobuf::Message for CVideoFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.format = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        };
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CVideoFormat {
    fn new() -> CVideoFormat {
        CVideoFormat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CVideoFormat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EVideoFormat>>(
                    "format",
                    CVideoFormat::get_format_for_reflect,
                    CVideoFormat::mut_format_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    CVideoFormat::get_width_for_reflect,
                    CVideoFormat::mut_width_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    CVideoFormat::get_height_for_reflect,
                    CVideoFormat::mut_height_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CVideoFormat>(
                    "CVideoFormat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CVideoFormat {
    fn clear(&mut self) {
        self.clear_format();
        self.clear_width();
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameEvent {
    // message fields
    event_id: ::std::option::Option<EStreamFrameEvent>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CFrameEvent {}

impl CFrameEvent {
    pub fn new() -> CFrameEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CFrameEvent {
        static mut instance: ::protobuf::lazy::Lazy<CFrameEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CFrameEvent,
        };
        unsafe {
            instance.get(CFrameEvent::new)
        }
    }

    // required .EStreamFrameEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EStreamFrameEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> EStreamFrameEvent {
        self.event_id.unwrap_or(EStreamFrameEvent::k_EStreamInputEventStart)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<EStreamFrameEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamFrameEvent> {
        &mut self.event_id
    }

    // required uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CFrameEvent {
    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        };
        if self.timestamp.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CFrameEvent {
    fn new() -> CFrameEvent {
        CFrameEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CFrameEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamFrameEvent>>(
                    "event_id",
                    CFrameEvent::get_event_id_for_reflect,
                    CFrameEvent::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CFrameEvent::get_timestamp_for_reflect,
                    CFrameEvent::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CFrameEvent>(
                    "CFrameEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CFrameEvent {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStats {
    // message fields
    frame_id: ::std::option::Option<u32>,
    input_mark: ::std::option::Option<u32>,
    events: ::protobuf::RepeatedField<CFrameEvent>,
    result: ::std::option::Option<EStreamFrameResult>,
    frame_start_delta: ::std::option::Option<f32>,
    frame_display_delta: ::std::option::Option<f32>,
    ping_time: ::std::option::Option<f32>,
    server_bitrate: ::std::option::Option<f32>,
    client_bitrate: ::std::option::Option<f32>,
    link_bandwidth: ::std::option::Option<f32>,
    packet_loss: ::std::option::Option<f32>,
    frame_size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CFrameStats {}

impl CFrameStats {
    pub fn new() -> CFrameStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CFrameStats {
        static mut instance: ::protobuf::lazy::Lazy<CFrameStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CFrameStats,
        };
        unsafe {
            instance.get(CFrameStats::new)
        }
    }

    // required uint32 frame_id = 1;

    pub fn clear_frame_id(&mut self) {
        self.frame_id = ::std::option::Option::None;
    }

    pub fn has_frame_id(&self) -> bool {
        self.frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: u32) {
        self.frame_id = ::std::option::Option::Some(v);
    }

    pub fn get_frame_id(&self) -> u32 {
        self.frame_id.unwrap_or(0)
    }

    fn get_frame_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.frame_id
    }

    fn mut_frame_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.frame_id
    }

    // optional uint32 input_mark = 2;

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    fn get_input_mark_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.input_mark
    }

    fn mut_input_mark_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.input_mark
    }

    // repeated .CFrameEvent events = 3;

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CFrameEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<CFrameEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<CFrameEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    pub fn get_events(&self) -> &[CFrameEvent] {
        &self.events
    }

    fn get_events_for_reflect(&self) -> &::protobuf::RepeatedField<CFrameEvent> {
        &self.events
    }

    fn mut_events_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CFrameEvent> {
        &mut self.events
    }

    // required .EStreamFrameResult result = 4;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStreamFrameResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> EStreamFrameResult {
        self.result.unwrap_or(EStreamFrameResult::k_EStreamFrameResultPending)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<EStreamFrameResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamFrameResult> {
        &mut self.result
    }

    // optional float frame_start_delta = 5;

    pub fn clear_frame_start_delta(&mut self) {
        self.frame_start_delta = ::std::option::Option::None;
    }

    pub fn has_frame_start_delta(&self) -> bool {
        self.frame_start_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_start_delta(&mut self, v: f32) {
        self.frame_start_delta = ::std::option::Option::Some(v);
    }

    pub fn get_frame_start_delta(&self) -> f32 {
        self.frame_start_delta.unwrap_or(0.)
    }

    fn get_frame_start_delta_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.frame_start_delta
    }

    fn mut_frame_start_delta_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.frame_start_delta
    }

    // optional float frame_display_delta = 6;

    pub fn clear_frame_display_delta(&mut self) {
        self.frame_display_delta = ::std::option::Option::None;
    }

    pub fn has_frame_display_delta(&self) -> bool {
        self.frame_display_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_display_delta(&mut self, v: f32) {
        self.frame_display_delta = ::std::option::Option::Some(v);
    }

    pub fn get_frame_display_delta(&self) -> f32 {
        self.frame_display_delta.unwrap_or(0.)
    }

    fn get_frame_display_delta_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.frame_display_delta
    }

    fn mut_frame_display_delta_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.frame_display_delta
    }

    // optional float ping_time = 7;

    pub fn clear_ping_time(&mut self) {
        self.ping_time = ::std::option::Option::None;
    }

    pub fn has_ping_time(&self) -> bool {
        self.ping_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: f32) {
        self.ping_time = ::std::option::Option::Some(v);
    }

    pub fn get_ping_time(&self) -> f32 {
        self.ping_time.unwrap_or(0.)
    }

    fn get_ping_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.ping_time
    }

    fn mut_ping_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.ping_time
    }

    // optional float server_bitrate = 8;

    pub fn clear_server_bitrate(&mut self) {
        self.server_bitrate = ::std::option::Option::None;
    }

    pub fn has_server_bitrate(&self) -> bool {
        self.server_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_bitrate(&mut self, v: f32) {
        self.server_bitrate = ::std::option::Option::Some(v);
    }

    pub fn get_server_bitrate(&self) -> f32 {
        self.server_bitrate.unwrap_or(0.)
    }

    fn get_server_bitrate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.server_bitrate
    }

    fn mut_server_bitrate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.server_bitrate
    }

    // optional float client_bitrate = 9;

    pub fn clear_client_bitrate(&mut self) {
        self.client_bitrate = ::std::option::Option::None;
    }

    pub fn has_client_bitrate(&self) -> bool {
        self.client_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_bitrate(&mut self, v: f32) {
        self.client_bitrate = ::std::option::Option::Some(v);
    }

    pub fn get_client_bitrate(&self) -> f32 {
        self.client_bitrate.unwrap_or(0.)
    }

    fn get_client_bitrate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.client_bitrate
    }

    fn mut_client_bitrate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.client_bitrate
    }

    // optional float link_bandwidth = 10;

    pub fn clear_link_bandwidth(&mut self) {
        self.link_bandwidth = ::std::option::Option::None;
    }

    pub fn has_link_bandwidth(&self) -> bool {
        self.link_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_bandwidth(&mut self, v: f32) {
        self.link_bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_link_bandwidth(&self) -> f32 {
        self.link_bandwidth.unwrap_or(0.)
    }

    fn get_link_bandwidth_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.link_bandwidth
    }

    fn mut_link_bandwidth_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.link_bandwidth
    }

    // optional float packet_loss = 11;

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    pub fn get_packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    fn get_packet_loss_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.packet_loss
    }

    fn mut_packet_loss_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.packet_loss
    }

    // optional uint32 frame_size = 12;

    pub fn clear_frame_size(&mut self) {
        self.frame_size = ::std::option::Option::None;
    }

    pub fn has_frame_size(&self) -> bool {
        self.frame_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_size(&mut self, v: u32) {
        self.frame_size = ::std::option::Option::Some(v);
    }

    pub fn get_frame_size(&self) -> u32 {
        self.frame_size.unwrap_or(0)
    }

    fn get_frame_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.frame_size
    }

    fn mut_frame_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.frame_size
    }
}

impl ::protobuf::Message for CFrameStats {
    fn is_initialized(&self) -> bool {
        if self.frame_id.is_none() {
            return false;
        };
        if self.result.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.frame_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.frame_start_delta = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.frame_display_delta = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.ping_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.server_bitrate = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.client_bitrate = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.link_bandwidth = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.packet_loss = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_uint32()?;
                    self.frame_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frame_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(4, v);
        };
        if let Some(v) = self.frame_start_delta {
            my_size += 5;
        };
        if let Some(v) = self.frame_display_delta {
            my_size += 5;
        };
        if let Some(v) = self.ping_time {
            my_size += 5;
        };
        if let Some(v) = self.server_bitrate {
            my_size += 5;
        };
        if let Some(v) = self.client_bitrate {
            my_size += 5;
        };
        if let Some(v) = self.link_bandwidth {
            my_size += 5;
        };
        if let Some(v) = self.packet_loss {
            my_size += 5;
        };
        if let Some(v) = self.frame_size {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frame_id {
            os.write_uint32(1, v)?;
        };
        if let Some(v) = self.input_mark {
            os.write_uint32(2, v)?;
        };
        for v in &self.events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(4, v.value())?;
        };
        if let Some(v) = self.frame_start_delta {
            os.write_float(5, v)?;
        };
        if let Some(v) = self.frame_display_delta {
            os.write_float(6, v)?;
        };
        if let Some(v) = self.ping_time {
            os.write_float(7, v)?;
        };
        if let Some(v) = self.server_bitrate {
            os.write_float(8, v)?;
        };
        if let Some(v) = self.client_bitrate {
            os.write_float(9, v)?;
        };
        if let Some(v) = self.link_bandwidth {
            os.write_float(10, v)?;
        };
        if let Some(v) = self.packet_loss {
            os.write_float(11, v)?;
        };
        if let Some(v) = self.frame_size {
            os.write_uint32(12, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CFrameStats {
    fn new() -> CFrameStats {
        CFrameStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CFrameStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frame_id",
                    CFrameStats::get_frame_id_for_reflect,
                    CFrameStats::mut_frame_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input_mark",
                    CFrameStats::get_input_mark_for_reflect,
                    CFrameStats::mut_input_mark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameEvent>>(
                    "events",
                    CFrameStats::get_events_for_reflect,
                    CFrameStats::mut_events_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamFrameResult>>(
                    "result",
                    CFrameStats::get_result_for_reflect,
                    CFrameStats::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "frame_start_delta",
                    CFrameStats::get_frame_start_delta_for_reflect,
                    CFrameStats::mut_frame_start_delta_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "frame_display_delta",
                    CFrameStats::get_frame_display_delta_for_reflect,
                    CFrameStats::mut_frame_display_delta_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "ping_time",
                    CFrameStats::get_ping_time_for_reflect,
                    CFrameStats::mut_ping_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "server_bitrate",
                    CFrameStats::get_server_bitrate_for_reflect,
                    CFrameStats::mut_server_bitrate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "client_bitrate",
                    CFrameStats::get_client_bitrate_for_reflect,
                    CFrameStats::mut_client_bitrate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "link_bandwidth",
                    CFrameStats::get_link_bandwidth_for_reflect,
                    CFrameStats::mut_link_bandwidth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "packet_loss",
                    CFrameStats::get_packet_loss_for_reflect,
                    CFrameStats::mut_packet_loss_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frame_size",
                    CFrameStats::get_frame_size_for_reflect,
                    CFrameStats::mut_frame_size_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CFrameStats>(
                    "CFrameStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CFrameStats {
    fn clear(&mut self) {
        self.clear_frame_id();
        self.clear_input_mark();
        self.clear_events();
        self.clear_result();
        self.clear_frame_start_delta();
        self.clear_frame_display_delta();
        self.clear_ping_time();
        self.clear_server_bitrate();
        self.clear_client_bitrate();
        self.clear_link_bandwidth();
        self.clear_packet_loss();
        self.clear_frame_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatAccumulatedValue {
    // message fields
    stat_type: ::std::option::Option<EFrameAccumulatedStat>,
    count: ::std::option::Option<i32>,
    average: ::std::option::Option<f32>,
    stddev: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CFrameStatAccumulatedValue {}

impl CFrameStatAccumulatedValue {
    pub fn new() -> CFrameStatAccumulatedValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CFrameStatAccumulatedValue {
        static mut instance: ::protobuf::lazy::Lazy<CFrameStatAccumulatedValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CFrameStatAccumulatedValue,
        };
        unsafe {
            instance.get(CFrameStatAccumulatedValue::new)
        }
    }

    // required .EFrameAccumulatedStat stat_type = 1;

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EFrameAccumulatedStat) {
        self.stat_type = ::std::option::Option::Some(v);
    }

    pub fn get_stat_type(&self) -> EFrameAccumulatedStat {
        self.stat_type.unwrap_or(EFrameAccumulatedStat::k_EFrameStatFPS)
    }

    fn get_stat_type_for_reflect(&self) -> &::std::option::Option<EFrameAccumulatedStat> {
        &self.stat_type
    }

    fn mut_stat_type_for_reflect(&mut self) -> &mut ::std::option::Option<EFrameAccumulatedStat> {
        &mut self.stat_type
    }

    // required int32 count = 2;

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    fn get_count_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.count
    }

    fn mut_count_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.count
    }

    // required float average = 3;

    pub fn clear_average(&mut self) {
        self.average = ::std::option::Option::None;
    }

    pub fn has_average(&self) -> bool {
        self.average.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = ::std::option::Option::Some(v);
    }

    pub fn get_average(&self) -> f32 {
        self.average.unwrap_or(0.)
    }

    fn get_average_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.average
    }

    fn mut_average_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.average
    }

    // optional float stddev = 4;

    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }

    pub fn get_stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }

    fn get_stddev_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.stddev
    }

    fn mut_stddev_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.stddev
    }
}

impl ::protobuf::Message for CFrameStatAccumulatedValue {
    fn is_initialized(&self) -> bool {
        if self.stat_type.is_none() {
            return false;
        };
        if self.count.is_none() {
            return false;
        };
        if self.average.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.stat_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.average = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_float()?;
                    self.stddev = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.average {
            my_size += 5;
        };
        if let Some(v) = self.stddev {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        };
        if let Some(v) = self.average {
            os.write_float(3, v)?;
        };
        if let Some(v) = self.stddev {
            os.write_float(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CFrameStatAccumulatedValue {
    fn new() -> CFrameStatAccumulatedValue {
        CFrameStatAccumulatedValue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CFrameStatAccumulatedValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EFrameAccumulatedStat>>(
                    "stat_type",
                    CFrameStatAccumulatedValue::get_stat_type_for_reflect,
                    CFrameStatAccumulatedValue::mut_stat_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    CFrameStatAccumulatedValue::get_count_for_reflect,
                    CFrameStatAccumulatedValue::mut_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "average",
                    CFrameStatAccumulatedValue::get_average_for_reflect,
                    CFrameStatAccumulatedValue::mut_average_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stddev",
                    CFrameStatAccumulatedValue::get_stddev_for_reflect,
                    CFrameStatAccumulatedValue::mut_stddev_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CFrameStatAccumulatedValue>(
                    "CFrameStatAccumulatedValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CFrameStatAccumulatedValue {
    fn clear(&mut self) {
        self.clear_stat_type();
        self.clear_count();
        self.clear_average();
        self.clear_stddev();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatAccumulatedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatAccumulatedValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatsListMsg {
    // message fields
    data_type: ::std::option::Option<EStreamingDataType>,
    stats: ::protobuf::RepeatedField<CFrameStats>,
    accumulated_stats: ::protobuf::RepeatedField<CFrameStatAccumulatedValue>,
    latest_frame_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CFrameStatsListMsg {}

impl CFrameStatsListMsg {
    pub fn new() -> CFrameStatsListMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CFrameStatsListMsg {
        static mut instance: ::protobuf::lazy::Lazy<CFrameStatsListMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CFrameStatsListMsg,
        };
        unsafe {
            instance.get(CFrameStatsListMsg::new)
        }
    }

    // required .EStreamingDataType data_type = 1;

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EStreamingDataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    pub fn get_data_type(&self) -> EStreamingDataType {
        self.data_type.unwrap_or(EStreamingDataType::k_EStreamingAudioData)
    }

    fn get_data_type_for_reflect(&self) -> &::std::option::Option<EStreamingDataType> {
        &self.data_type
    }

    fn mut_data_type_for_reflect(&mut self) -> &mut ::std::option::Option<EStreamingDataType> {
        &mut self.data_type
    }

    // repeated .CFrameStats stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CFrameStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CFrameStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats(&self) -> &[CFrameStats] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CFrameStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStats> {
        &mut self.stats
    }

    // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;

    pub fn clear_accumulated_stats(&mut self) {
        self.accumulated_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_accumulated_stats(&mut self, v: ::protobuf::RepeatedField<CFrameStatAccumulatedValue>) {
        self.accumulated_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accumulated_stats(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        &mut self.accumulated_stats
    }

    // Take field
    pub fn take_accumulated_stats(&mut self) -> ::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        ::std::mem::replace(&mut self.accumulated_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_accumulated_stats(&self) -> &[CFrameStatAccumulatedValue] {
        &self.accumulated_stats
    }

    fn get_accumulated_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        &self.accumulated_stats
    }

    fn mut_accumulated_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        &mut self.accumulated_stats
    }

    // required int32 latest_frame_id = 4;

    pub fn clear_latest_frame_id(&mut self) {
        self.latest_frame_id = ::std::option::Option::None;
    }

    pub fn has_latest_frame_id(&self) -> bool {
        self.latest_frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_frame_id(&mut self, v: i32) {
        self.latest_frame_id = ::std::option::Option::Some(v);
    }

    pub fn get_latest_frame_id(&self) -> i32 {
        self.latest_frame_id.unwrap_or(0)
    }

    fn get_latest_frame_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.latest_frame_id
    }

    fn mut_latest_frame_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.latest_frame_id
    }
}

impl ::protobuf::Message for CFrameStatsListMsg {
    fn is_initialized(&self) -> bool {
        if self.data_type.is_none() {
            return false;
        };
        if self.latest_frame_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.data_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accumulated_stats)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.latest_frame_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.accumulated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.latest_frame_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, v.value())?;
        };
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.accumulated_stats {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.latest_frame_id {
            os.write_int32(4, v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CFrameStatsListMsg {
    fn new() -> CFrameStatsListMsg {
        CFrameStatsListMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CFrameStatsListMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamingDataType>>(
                    "data_type",
                    CFrameStatsListMsg::get_data_type_for_reflect,
                    CFrameStatsListMsg::mut_data_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameStats>>(
                    "stats",
                    CFrameStatsListMsg::get_stats_for_reflect,
                    CFrameStatsListMsg::mut_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameStatAccumulatedValue>>(
                    "accumulated_stats",
                    CFrameStatsListMsg::get_accumulated_stats_for_reflect,
                    CFrameStatsListMsg::mut_accumulated_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "latest_frame_id",
                    CFrameStatsListMsg::get_latest_frame_id_for_reflect,
                    CFrameStatsListMsg::mut_latest_frame_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CFrameStatsListMsg>(
                    "CFrameStatsListMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CFrameStatsListMsg {
    fn clear(&mut self) {
        self.clear_data_type();
        self.clear_stats();
        self.clear_accumulated_stats();
        self.clear_latest_frame_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatsListMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatsListMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDebugDumpMsg {
    // message fields
    screenshot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDebugDumpMsg {}

impl CDebugDumpMsg {
    pub fn new() -> CDebugDumpMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDebugDumpMsg {
        static mut instance: ::protobuf::lazy::Lazy<CDebugDumpMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDebugDumpMsg,
        };
        unsafe {
            instance.get(CDebugDumpMsg::new)
        }
    }

    // optional bytes screenshot = 1;

    pub fn clear_screenshot(&mut self) {
        self.screenshot.clear();
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot.set_default();
        };
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_screenshot_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.screenshot
    }

    fn mut_screenshot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.screenshot
    }
}

impl ::protobuf::Message for CDebugDumpMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDebugDumpMsg {
    fn new() -> CDebugDumpMsg {
        CDebugDumpMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDebugDumpMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "screenshot",
                    CDebugDumpMsg::get_screenshot_for_reflect,
                    CDebugDumpMsg::mut_screenshot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDebugDumpMsg>(
                    "CDebugDumpMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDebugDumpMsg {
    fn clear(&mut self) {
        self.clear_screenshot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDebugDumpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDebugDumpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogMsg {
    // message fields
    field_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CLogMsg {}

impl CLogMsg {
    pub fn new() -> CLogMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CLogMsg {
        static mut instance: ::protobuf::lazy::Lazy<CLogMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CLogMsg,
        };
        unsafe {
            instance.get(CLogMsg::new)
        }
    }

    // optional int32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.field_type
    }

    // optional string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for CLogMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        };
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CLogMsg {
    fn new() -> CLogMsg {
        CLogMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CLogMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    CLogMsg::get_field_type_for_reflect,
                    CLogMsg::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CLogMsg::get_message_for_reflect,
                    CLogMsg::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CLogMsg>(
                    "CLogMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CLogMsg {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogUploadMsg {
    // message fields
    field_type: ::std::option::Option<ELogFileType>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CLogUploadMsg {}

impl CLogUploadMsg {
    pub fn new() -> CLogUploadMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CLogUploadMsg {
        static mut instance: ::protobuf::lazy::Lazy<CLogUploadMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CLogUploadMsg,
        };
        unsafe {
            instance.get(CLogUploadMsg::new)
        }
    }

    // optional .ELogFileType type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ELogFileType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> ELogFileType {
        self.field_type.unwrap_or(ELogFileType::k_ELogFileSystemBoot)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<ELogFileType> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<ELogFileType> {
        &mut self.field_type
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for CLogUploadMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        };
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        };
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CLogUploadMsg {
    fn new() -> CLogUploadMsg {
        CLogUploadMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CLogUploadMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ELogFileType>>(
                    "type",
                    CLogUploadMsg::get_field_type_for_reflect,
                    CLogUploadMsg::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    CLogUploadMsg::get_data_for_reflect,
                    CLogUploadMsg::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CLogUploadMsg>(
                    "CLogUploadMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CLogUploadMsg {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogUploadMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogUploadMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamChannel {
    k_EStreamChannelInvalid = -1,
    k_EStreamChannelDiscovery = 0,
    k_EStreamChannelControl = 1,
    k_EStreamChannelStats = 2,
    k_EStreamChannelDataChannelStart = 3,
}

impl ::protobuf::ProtobufEnum for EStreamChannel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamChannel> {
        match value {
            -1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            0 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            2 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            3 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamChannel] = &[
            EStreamChannel::k_EStreamChannelInvalid,
            EStreamChannel::k_EStreamChannelDiscovery,
            EStreamChannel::k_EStreamChannelControl,
            EStreamChannel::k_EStreamChannelStats,
            EStreamChannel::k_EStreamChannelDataChannelStart,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamChannel>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamChannel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamChannel {
}

impl ::protobuf::reflect::ProtobufValue for EStreamChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDiscoveryMessage {
    k_EStreamDiscoveryPingRequest = 1,
    k_EStreamDiscoveryPingResponse = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDiscoveryMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            2 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDiscoveryMessage] = &[
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest,
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamDiscoveryMessage>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamDiscoveryMessage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamDiscoveryMessage {
}

impl ::protobuf::reflect::ProtobufValue for EStreamDiscoveryMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamControlMessage {
    k_EStreamControlAuthenticationRequest = 1,
    k_EStreamControlAuthenticationResponse = 2,
    k_EStreamControlNegotiationInit = 3,
    k_EStreamControlNegotiationSetConfig = 4,
    k_EStreamControlNegotiationComplete = 5,
    k_EStreamControlClientHandshake = 6,
    k_EStreamControlServerHandshake = 7,
    k_EStreamControlStartNetworkTest = 8,
    k_EStreamControlKeepAlive = 9,
    k_EStreamControl_LAST_SETUP_MESSAGE = 15,
    k_EStreamControlStartAudioData = 50,
    k_EStreamControlStopAudioData = 51,
    k_EStreamControlStartVideoData = 52,
    k_EStreamControlStopVideoData = 53,
    k_EStreamControlInputMouseMotion = 54,
    k_EStreamControlInputMouseWheel = 55,
    k_EStreamControlInputMouseDown = 56,
    k_EStreamControlInputMouseUp = 57,
    k_EStreamControlInputKeyDown = 58,
    k_EStreamControlInputKeyUp = 59,
    k_EStreamControlInputGamepadAttached = 60,
    k_EStreamControlInputGamepadEvent = 61,
    k_EStreamControlInputGamepadDetached = 62,
    k_EStreamControlShowCursor = 63,
    k_EStreamControlHideCursor = 64,
    k_EStreamControlSetCursor = 65,
    k_EStreamControlGetCursorImage = 66,
    k_EStreamControlSetCursorImage = 67,
    k_EStreamControlDeleteCursor = 68,
    k_EStreamControlSetTargetFramerate = 69,
    k_EStreamControlInputLatencyTest = 70,
    k_EStreamControlGamepadRumble = 71,
    k_EStreamControlOverlayEnabled = 74,
    k_EStreamControlInputControllerAttached = 75,
    k_EStreamControlInputControllerState = 76,
    k_EStreamControlTriggerHapticPulse = 77,
    k_EStreamControlInputControllerDetached = 78,
    k_EStreamControlVideoDecoderInfo = 80,
    k_EStreamControlSetTitle = 81,
    k_EStreamControlSetIcon = 82,
    k_EStreamControlQuitRequest = 83,
    k_EStreamControlSetQoS = 87,
    k_EStreamControlInputControllerWirelessPresence = 88,
    k_EStreamControlSetGammaRamp = 89,
    k_EStreamControlVideoEncoderInfo = 90,
    k_EStreamControlInputControllerStateHID = 93,
    k_EStreamControlSetTargetBitrate = 94,
    k_EStreamControlSetControllerPairingEnabled = 95,
    k_EStreamControlSetControllerPairingResult = 96,
    k_EStreamControlTriggerControllerDisconnect = 97,
    k_EStreamControlSetActivity = 98,
    k_EStreamControlSetStreamingClientConfig = 99,
    k_EStreamControlSystemSuspend = 100,
    k_EStreamControlSetControllerSettings = 101,
    k_EStreamControlVirtualHereRequest = 102,
    k_EStreamControlVirtualHereReady = 103,
    k_EStreamControlVirtualHereShareDevice = 104,
}

impl ::protobuf::ProtobufEnum for EStreamControlMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControlMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            2 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            3 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            4 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            5 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            6 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            7 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            8 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            9 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            15 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            50 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            51 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            52 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            53 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            54 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            55 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            56 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            57 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            58 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            59 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            60 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached),
            61 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent),
            62 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached),
            63 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            64 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            65 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            66 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            67 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            68 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            69 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            70 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            71 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble),
            74 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            75 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached),
            76 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState),
            77 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse),
            78 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached),
            80 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            81 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            82 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            83 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            87 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            88 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence),
            89 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            90 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            93 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID),
            94 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            95 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled),
            96 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult),
            97 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect),
            98 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            99 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            100 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            101 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings),
            102 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            103 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            104 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamControlMessage] = &[
            EStreamControlMessage::k_EStreamControlAuthenticationRequest,
            EStreamControlMessage::k_EStreamControlAuthenticationResponse,
            EStreamControlMessage::k_EStreamControlNegotiationInit,
            EStreamControlMessage::k_EStreamControlNegotiationSetConfig,
            EStreamControlMessage::k_EStreamControlNegotiationComplete,
            EStreamControlMessage::k_EStreamControlClientHandshake,
            EStreamControlMessage::k_EStreamControlServerHandshake,
            EStreamControlMessage::k_EStreamControlStartNetworkTest,
            EStreamControlMessage::k_EStreamControlKeepAlive,
            EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE,
            EStreamControlMessage::k_EStreamControlStartAudioData,
            EStreamControlMessage::k_EStreamControlStopAudioData,
            EStreamControlMessage::k_EStreamControlStartVideoData,
            EStreamControlMessage::k_EStreamControlStopVideoData,
            EStreamControlMessage::k_EStreamControlInputMouseMotion,
            EStreamControlMessage::k_EStreamControlInputMouseWheel,
            EStreamControlMessage::k_EStreamControlInputMouseDown,
            EStreamControlMessage::k_EStreamControlInputMouseUp,
            EStreamControlMessage::k_EStreamControlInputKeyDown,
            EStreamControlMessage::k_EStreamControlInputKeyUp,
            EStreamControlMessage::k_EStreamControlInputGamepadAttached,
            EStreamControlMessage::k_EStreamControlInputGamepadEvent,
            EStreamControlMessage::k_EStreamControlInputGamepadDetached,
            EStreamControlMessage::k_EStreamControlShowCursor,
            EStreamControlMessage::k_EStreamControlHideCursor,
            EStreamControlMessage::k_EStreamControlSetCursor,
            EStreamControlMessage::k_EStreamControlGetCursorImage,
            EStreamControlMessage::k_EStreamControlSetCursorImage,
            EStreamControlMessage::k_EStreamControlDeleteCursor,
            EStreamControlMessage::k_EStreamControlSetTargetFramerate,
            EStreamControlMessage::k_EStreamControlInputLatencyTest,
            EStreamControlMessage::k_EStreamControlGamepadRumble,
            EStreamControlMessage::k_EStreamControlOverlayEnabled,
            EStreamControlMessage::k_EStreamControlInputControllerAttached,
            EStreamControlMessage::k_EStreamControlInputControllerState,
            EStreamControlMessage::k_EStreamControlTriggerHapticPulse,
            EStreamControlMessage::k_EStreamControlInputControllerDetached,
            EStreamControlMessage::k_EStreamControlVideoDecoderInfo,
            EStreamControlMessage::k_EStreamControlSetTitle,
            EStreamControlMessage::k_EStreamControlSetIcon,
            EStreamControlMessage::k_EStreamControlQuitRequest,
            EStreamControlMessage::k_EStreamControlSetQoS,
            EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence,
            EStreamControlMessage::k_EStreamControlSetGammaRamp,
            EStreamControlMessage::k_EStreamControlVideoEncoderInfo,
            EStreamControlMessage::k_EStreamControlInputControllerStateHID,
            EStreamControlMessage::k_EStreamControlSetTargetBitrate,
            EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled,
            EStreamControlMessage::k_EStreamControlSetControllerPairingResult,
            EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect,
            EStreamControlMessage::k_EStreamControlSetActivity,
            EStreamControlMessage::k_EStreamControlSetStreamingClientConfig,
            EStreamControlMessage::k_EStreamControlSystemSuspend,
            EStreamControlMessage::k_EStreamControlSetControllerSettings,
            EStreamControlMessage::k_EStreamControlVirtualHereRequest,
            EStreamControlMessage::k_EStreamControlVirtualHereReady,
            EStreamControlMessage::k_EStreamControlVirtualHereShareDevice,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamControlMessage>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamControlMessage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamControlMessage {
}

impl ::protobuf::reflect::ProtobufValue for EStreamControlMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVersion {
    k_EStreamVersionNone = 0,
    k_EStreamVersionCurrent = 1,
}

impl ::protobuf::ProtobufEnum for EStreamVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVersion> {
        match value {
            0 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            1 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVersion] = &[
            EStreamVersion::k_EStreamVersionNone,
            EStreamVersion::k_EStreamVersionCurrent,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamVersion>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamVersion", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamVersion {
}

impl ::protobuf::reflect::ProtobufValue for EStreamVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamAudioCodec {
    k_EStreamAudioCodecNone = 0,
    k_EStreamAudioCodecRaw = 1,
    k_EStreamAudioCodecVorbis = 2,
    k_EStreamAudioCodecOpus = 3,
    k_EStreamAudioCodecMP3 = 4,
    k_EStreamAudioCodecAAC = 5,
}

impl ::protobuf::ProtobufEnum for EStreamAudioCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamAudioCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            1 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            2 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            3 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            4 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            5 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamAudioCodec] = &[
            EStreamAudioCodec::k_EStreamAudioCodecNone,
            EStreamAudioCodec::k_EStreamAudioCodecRaw,
            EStreamAudioCodec::k_EStreamAudioCodecVorbis,
            EStreamAudioCodec::k_EStreamAudioCodecOpus,
            EStreamAudioCodec::k_EStreamAudioCodecMP3,
            EStreamAudioCodec::k_EStreamAudioCodecAAC,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamAudioCodec>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamAudioCodec", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamAudioCodec {
}

impl ::protobuf::reflect::ProtobufValue for EStreamAudioCodec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVideoCodec {
    k_EStreamVideoCodecNone = 0,
    k_EStreamVideoCodecRaw = 1,
    k_EStreamVideoCodecVP8 = 2,
    k_EStreamVideoCodecVP9 = 3,
    k_EStreamVideoCodecH264 = 4,
    k_EStreamVideoCodecH265 = 5,
    k_EStreamVideoCodecORBX1 = 6,
    k_EStreamVideoCodecORBX2 = 7,
}

impl ::protobuf::ProtobufEnum for EStreamVideoCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            1 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            2 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            3 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            4 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            5 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH265),
            6 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            7 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVideoCodec] = &[
            EStreamVideoCodec::k_EStreamVideoCodecNone,
            EStreamVideoCodec::k_EStreamVideoCodecRaw,
            EStreamVideoCodec::k_EStreamVideoCodecVP8,
            EStreamVideoCodec::k_EStreamVideoCodecVP9,
            EStreamVideoCodec::k_EStreamVideoCodecH264,
            EStreamVideoCodec::k_EStreamVideoCodecH265,
            EStreamVideoCodec::k_EStreamVideoCodecORBX1,
            EStreamVideoCodec::k_EStreamVideoCodecORBX2,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamVideoCodec>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamVideoCodec", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamVideoCodec {
}

impl ::protobuf::reflect::ProtobufValue for EStreamVideoCodec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamQualityPreference {
    k_EStreamQualityFast = 1,
    k_EStreamQualityBalanced = 2,
    k_EStreamQualityBeautiful = 3,
}

impl ::protobuf::ProtobufEnum for EStreamQualityPreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamQualityPreference> {
        match value {
            1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            2 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            3 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamQualityPreference] = &[
            EStreamQualityPreference::k_EStreamQualityFast,
            EStreamQualityPreference::k_EStreamQualityBalanced,
            EStreamQualityPreference::k_EStreamQualityBeautiful,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamQualityPreference>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamQualityPreference", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamQualityPreference {
}

impl ::protobuf::reflect::ProtobufValue for EStreamQualityPreference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamBitrate {
    k_EStreamBitrateAutodetect = -1,
    k_EStreamBitrateUnlimited = 0,
}

impl ::protobuf::ProtobufEnum for EStreamBitrate {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamBitrate> {
        match value {
            -1 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            0 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamBitrate] = &[
            EStreamBitrate::k_EStreamBitrateAutodetect,
            EStreamBitrate::k_EStreamBitrateUnlimited,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamBitrate>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamBitrate", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamBitrate {
}

impl ::protobuf::reflect::ProtobufValue for EStreamBitrate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamingDataType {
    k_EStreamingAudioData = 0,
    k_EStreamingVideoData = 1,
}

impl ::protobuf::ProtobufEnum for EStreamingDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamingDataType> {
        match value {
            0 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            1 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamingDataType] = &[
            EStreamingDataType::k_EStreamingAudioData,
            EStreamingDataType::k_EStreamingVideoData,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamingDataType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamingDataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamingDataType {
}

impl ::protobuf::reflect::ProtobufValue for EStreamingDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseButton {
    k_EStreamMouseButtonLeft = 1,
    k_EStreamMouseButtonRight = 2,
    k_EStreamMouseButtonMiddle = 16,
    k_EStreamMouseButtonX1 = 32,
    k_EStreamMouseButtonX2 = 64,
    k_EStreamMouseButtonUnknown = 4096,
}

impl ::protobuf::ProtobufEnum for EStreamMouseButton {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseButton> {
        match value {
            1 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            2 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            16 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            32 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            64 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            4096 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseButton] = &[
            EStreamMouseButton::k_EStreamMouseButtonLeft,
            EStreamMouseButton::k_EStreamMouseButtonRight,
            EStreamMouseButton::k_EStreamMouseButtonMiddle,
            EStreamMouseButton::k_EStreamMouseButtonX1,
            EStreamMouseButton::k_EStreamMouseButtonX2,
            EStreamMouseButton::k_EStreamMouseButtonUnknown,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamMouseButton>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamMouseButton", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamMouseButton {
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseButton {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseWheelDirection {
    k_EStreamMouseWheelUp = 120,
    k_EStreamMouseWheelDown = -120,
    k_EStreamMouseWheelLeft = 3,
    k_EStreamMouseWheelRight = 4,
}

impl ::protobuf::ProtobufEnum for EStreamMouseWheelDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match value {
            120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            -120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            3 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            4 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseWheelDirection] = &[
            EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
            EStreamMouseWheelDirection::k_EStreamMouseWheelDown,
            EStreamMouseWheelDirection::k_EStreamMouseWheelLeft,
            EStreamMouseWheelDirection::k_EStreamMouseWheelRight,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamMouseWheelDirection>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamMouseWheelDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamMouseWheelDirection {
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseWheelDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamGamepadInputType {
    k_EStreamGamepadInputInvalid = 0,
    k_EStreamGamepadInputDPadUp = 1,
    k_EStreamGamepadInputDPadDown = 2,
    k_EStreamGamepadInputDPadLeft = 4,
    k_EStreamGamepadInputDPadRight = 8,
    k_EStreamGamepadInputStart = 16,
    k_EStreamGamepadInputBack = 32,
    k_EStreamGamepadInputLeftThumb = 64,
    k_EStreamGamepadInputRightThumb = 128,
    k_EStreamGamepadInputLeftShoulder = 256,
    k_EStreamGamepadInputRightShoulder = 512,
    k_EStreamGamepadInputGuide = 1024,
    k_EStreamGamepadInputA = 4096,
    k_EStreamGamepadInputB = 8192,
    k_EStreamGamepadInputX = 16384,
    k_EStreamGamepadInputY = 32768,
    k_EStreamGamepadInputLeftThumbX = 65536,
    k_EStreamGamepadInputLeftThumbY = 131072,
    k_EStreamGamepadInputRightThumbX = 262144,
    k_EStreamGamepadInputRightThumbY = 524288,
    k_EStreamGamepadInputLeftTrigger = 1048576,
    k_EStreamGamepadInputRightTrigger = 2097152,
}

impl ::protobuf::ProtobufEnum for EStreamGamepadInputType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamGamepadInputType> {
        match value {
            0 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputInvalid),
            1 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadUp),
            2 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadDown),
            4 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadLeft),
            8 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadRight),
            16 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputStart),
            32 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputBack),
            64 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumb),
            128 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumb),
            256 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftShoulder),
            512 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightShoulder),
            1024 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputGuide),
            4096 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputA),
            8192 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputB),
            16384 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputX),
            32768 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputY),
            65536 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbX),
            131072 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbY),
            262144 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumbX),
            524288 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumbY),
            1048576 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftTrigger),
            2097152 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightTrigger),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamGamepadInputType] = &[
            EStreamGamepadInputType::k_EStreamGamepadInputInvalid,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadUp,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadDown,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadLeft,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadRight,
            EStreamGamepadInputType::k_EStreamGamepadInputStart,
            EStreamGamepadInputType::k_EStreamGamepadInputBack,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumb,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumb,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftShoulder,
            EStreamGamepadInputType::k_EStreamGamepadInputRightShoulder,
            EStreamGamepadInputType::k_EStreamGamepadInputGuide,
            EStreamGamepadInputType::k_EStreamGamepadInputA,
            EStreamGamepadInputType::k_EStreamGamepadInputB,
            EStreamGamepadInputType::k_EStreamGamepadInputX,
            EStreamGamepadInputType::k_EStreamGamepadInputY,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbX,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbY,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumbX,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumbY,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftTrigger,
            EStreamGamepadInputType::k_EStreamGamepadInputRightTrigger,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamGamepadInputType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamGamepadInputType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamGamepadInputType {
}

impl ::protobuf::reflect::ProtobufValue for EStreamGamepadInputType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFramerateLimiter {
    k_EStreamFramerateSlowCapture = 1,
    k_EStreamFramerateSlowConvert = 2,
    k_EStreamFramerateSlowEncode = 4,
    k_EStreamFramerateSlowNetwork = 8,
    k_EStreamFramerateSlowDecode = 16,
    k_EStreamFramerateSlowGame = 32,
    k_EStreamFramerateSlowDisplay = 64,
}

impl ::protobuf::ProtobufEnum for EStreamFramerateLimiter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFramerateLimiter> {
        match value {
            1 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            2 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            4 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            8 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            16 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            32 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            64 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFramerateLimiter] = &[
            EStreamFramerateLimiter::k_EStreamFramerateSlowCapture,
            EStreamFramerateLimiter::k_EStreamFramerateSlowConvert,
            EStreamFramerateLimiter::k_EStreamFramerateSlowEncode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDecode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowGame,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamFramerateLimiter>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamFramerateLimiter", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamFramerateLimiter {
}

impl ::protobuf::reflect::ProtobufValue for EStreamFramerateLimiter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamActivity {
    k_EStreamActivityIdle = 1,
    k_EStreamActivityGame = 2,
    k_EStreamActivityDesktop = 3,
}

impl ::protobuf::ProtobufEnum for EStreamActivity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamActivity> {
        match value {
            1 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            2 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            3 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamActivity] = &[
            EStreamActivity::k_EStreamActivityIdle,
            EStreamActivity::k_EStreamActivityGame,
            EStreamActivity::k_EStreamActivityDesktop,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamActivity>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamActivity", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamActivity {
}

impl ::protobuf::reflect::ProtobufValue for EStreamActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDataMessage {
    k_EStreamDataPacket = 1,
    k_EStreamDataLost = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDataMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDataMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            2 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDataMessage] = &[
            EStreamDataMessage::k_EStreamDataPacket,
            EStreamDataMessage::k_EStreamDataLost,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamDataMessage>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamDataMessage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamDataMessage {
}

impl ::protobuf::reflect::ProtobufValue for EStreamDataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EAudioFormat {
    k_EAudioFormatNone = 0,
    k_EAudioFormat16BitLittleEndian = 1,
    k_EAudioFormatFloat = 2,
}

impl ::protobuf::ProtobufEnum for EAudioFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAudioFormat> {
        match value {
            0 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            1 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            2 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EAudioFormat] = &[
            EAudioFormat::k_EAudioFormatNone,
            EAudioFormat::k_EAudioFormat16BitLittleEndian,
            EAudioFormat::k_EAudioFormatFloat,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EAudioFormat>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EAudioFormat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EAudioFormat {
}

impl ::protobuf::reflect::ProtobufValue for EAudioFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EVideoFormat {
    k_EVideoFormatNone = 0,
    k_EVideoFormatYV12 = 1,
    k_EVideoFormatAccel = 2,
}

impl ::protobuf::ProtobufEnum for EVideoFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVideoFormat> {
        match value {
            0 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            1 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            2 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EVideoFormat] = &[
            EVideoFormat::k_EVideoFormatNone,
            EVideoFormat::k_EVideoFormatYV12,
            EVideoFormat::k_EVideoFormatAccel,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EVideoFormat>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EVideoFormat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EVideoFormat {
}

impl ::protobuf::reflect::ProtobufValue for EVideoFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamStatsMessage {
    k_EStreamStatsFrameEvents = 1,
    k_EStreamStatsDebugDump = 2,
    k_EStreamStatsLogMessage = 3,
    k_EStreamStatsLogUploadBegin = 4,
    k_EStreamStatsLogUploadData = 5,
    k_EStreamStatsLogUploadComplete = 6,
}

impl ::protobuf::ProtobufEnum for EStreamStatsMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamStatsMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            2 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            3 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            4 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            5 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            6 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamStatsMessage] = &[
            EStreamStatsMessage::k_EStreamStatsFrameEvents,
            EStreamStatsMessage::k_EStreamStatsDebugDump,
            EStreamStatsMessage::k_EStreamStatsLogMessage,
            EStreamStatsMessage::k_EStreamStatsLogUploadBegin,
            EStreamStatsMessage::k_EStreamStatsLogUploadData,
            EStreamStatsMessage::k_EStreamStatsLogUploadComplete,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamStatsMessage>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamStatsMessage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamStatsMessage {
}

impl ::protobuf::reflect::ProtobufValue for EStreamStatsMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameEvent {
    k_EStreamInputEventStart = 0,
    k_EStreamInputEventSend = 1,
    k_EStreamInputEventRecv = 2,
    k_EStreamInputEventQueued = 3,
    k_EStreamInputEventHandled = 4,
    k_EStreamFrameEventStart = 5,
    k_EStreamFrameEventCaptureBegin = 6,
    k_EStreamFrameEventCaptureEnd = 7,
    k_EStreamFrameEventConvertBegin = 8,
    k_EStreamFrameEventConvertEnd = 9,
    k_EStreamFrameEventEncodeBegin = 10,
    k_EStreamFrameEventEncodeEnd = 11,
    k_EStreamFrameEventSend = 12,
    k_EStreamFrameEventRecv = 13,
    k_EStreamFrameEventDecodeBegin = 14,
    k_EStreamFrameEventDecodeEnd = 15,
    k_EStreamFrameEventUploadBegin = 16,
    k_EStreamFrameEventUploadEnd = 17,
    k_EStreamFrameEventComplete = 18,
}

impl ::protobuf::ProtobufEnum for EStreamFrameEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameEvent> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            1 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            2 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            3 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            4 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            5 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            6 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            7 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            8 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            9 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            10 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            11 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            12 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            13 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            14 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            15 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            16 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            17 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            18 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameEvent] = &[
            EStreamFrameEvent::k_EStreamInputEventStart,
            EStreamFrameEvent::k_EStreamInputEventSend,
            EStreamFrameEvent::k_EStreamInputEventRecv,
            EStreamFrameEvent::k_EStreamInputEventQueued,
            EStreamFrameEvent::k_EStreamInputEventHandled,
            EStreamFrameEvent::k_EStreamFrameEventStart,
            EStreamFrameEvent::k_EStreamFrameEventCaptureBegin,
            EStreamFrameEvent::k_EStreamFrameEventCaptureEnd,
            EStreamFrameEvent::k_EStreamFrameEventConvertBegin,
            EStreamFrameEvent::k_EStreamFrameEventConvertEnd,
            EStreamFrameEvent::k_EStreamFrameEventEncodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventEncodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventSend,
            EStreamFrameEvent::k_EStreamFrameEventRecv,
            EStreamFrameEvent::k_EStreamFrameEventDecodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventDecodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventUploadBegin,
            EStreamFrameEvent::k_EStreamFrameEventUploadEnd,
            EStreamFrameEvent::k_EStreamFrameEventComplete,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamFrameEvent>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamFrameEvent", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamFrameEvent {
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameResult {
    k_EStreamFrameResultPending = 0,
    k_EStreamFrameResultDisplayed = 1,
    k_EStreamFrameResultDroppedNetworkSlow = 2,
    k_EStreamFrameResultDroppedNetworkLost = 3,
    k_EStreamFrameResultDroppedDecodeSlow = 4,
    k_EStreamFrameResultDroppedDecodeCorrupt = 5,
    k_EStreamFrameResultDroppedLate = 6,
    k_EStreamFrameResultDroppedReset = 7,
}

impl ::protobuf::ProtobufEnum for EStreamFrameResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameResult> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            1 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            2 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            3 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            4 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            5 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            6 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            7 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameResult] = &[
            EStreamFrameResult::k_EStreamFrameResultPending,
            EStreamFrameResult::k_EStreamFrameResultDisplayed,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt,
            EStreamFrameResult::k_EStreamFrameResultDroppedLate,
            EStreamFrameResult::k_EStreamFrameResultDroppedReset,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EStreamFrameResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EStreamFrameResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EStreamFrameResult {
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EFrameAccumulatedStat {
    k_EFrameStatFPS = 0,
    k_EFrameStatCaptureDurationMS = 1,
    k_EFrameStatConvertDurationMS = 2,
    k_EFrameStatEncodeDurationMS = 3,
    k_EFrameStatSteamDurationMS = 4,
    k_EFrameStatServerDurationMS = 5,
    k_EFrameStatNetworkDurationMS = 6,
    k_EFrameStatDecodeDurationMS = 7,
    k_EFrameStatDisplayDurationMS = 8,
    k_EFrameStatClientDurationMS = 9,
    k_EFrameStatFrameDurationMS = 10,
    k_EFrameStatInputLatencyMS = 11,
    k_EFrameStatGameLatencyMS = 12,
    k_EFrameStatRoundTripLatencyMS = 13,
    k_EFrameStatPingTimeMS = 14,
    k_EFrameStatServerBitrateKbitPerSec = 15,
    k_EFrameStatClientBitrateKbitPerSec = 16,
    k_EFrameStatLinkBandwidthKbitPerSec = 17,
    k_EFrameStatPacketLossPercentage = 18,
}

impl ::protobuf::ProtobufEnum for EFrameAccumulatedStat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFrameAccumulatedStat> {
        match value {
            0 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            1 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            2 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            3 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            4 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            5 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            6 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            7 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            8 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            9 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            10 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            11 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            12 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            13 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            14 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            15 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            16 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            17 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            18 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EFrameAccumulatedStat] = &[
            EFrameAccumulatedStat::k_EFrameStatFPS,
            EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS,
            EFrameAccumulatedStat::k_EFrameStatConvertDurationMS,
            EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatSteamDurationMS,
            EFrameAccumulatedStat::k_EFrameStatServerDurationMS,
            EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS,
            EFrameAccumulatedStat::k_EFrameStatClientDurationMS,
            EFrameAccumulatedStat::k_EFrameStatFrameDurationMS,
            EFrameAccumulatedStat::k_EFrameStatInputLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatGameLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatPingTimeMS,
            EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<EFrameAccumulatedStat>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EFrameAccumulatedStat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EFrameAccumulatedStat {
}

impl ::protobuf::reflect::ProtobufValue for EFrameAccumulatedStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ELogFileType {
    k_ELogFileSystemBoot = 0,
    k_ELogFileSystemReset = 1,
    k_ELogFileSystemDebug = 2,
}

impl ::protobuf::ProtobufEnum for ELogFileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELogFileType> {
        match value {
            0 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            1 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            2 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ELogFileType] = &[
            ELogFileType::k_ELogFileSystemBoot,
            ELogFileType::k_ELogFileSystemReset,
            ELogFileType::k_ELogFileSystemDebug,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ELogFileType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ELogFileType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ELogFileType {
}

impl ::protobuf::reflect::ProtobufValue for ELogFileType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x73, 0x2f, 0x73, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x67, 0x0a, 0x15, 0x43, 0x44, 0x69, 0x73,
    0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x50, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x32, 0x0a,
    0x15, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x13, 0x70, 0x61,
    0x63, 0x6b, 0x65, 0x74, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65,
    0x64, 0x22, 0x66, 0x0a, 0x16, 0x43, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x50,
    0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x73,
    0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x73,
    0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x30, 0x0a, 0x14, 0x70, 0x61, 0x63, 0x6b, 0x65,
    0x74, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x69, 0x7a,
    0x65, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x22, 0x42, 0x0a, 0x1d, 0x43, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x6e,
    0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x52, 0x0b, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54, 0x65, 0x73, 0x74, 0x22, 0x49, 0x0a,
    0x13, 0x43, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b,
    0x65, 0x4d, 0x73, 0x67, 0x12, 0x32, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x49, 0x6e,
    0x66, 0x6f, 0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x31, 0x0a, 0x1d, 0x43, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x48, 0x61, 0x6e, 0x64,
    0x73, 0x68, 0x61, 0x6b, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x74, 0x75,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75, 0x22, 0x49, 0x0a, 0x13, 0x43,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x4d,
    0x73, 0x67, 0x12, 0x32, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b,
    0x32, 0x1e, 0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x49, 0x6e, 0x66, 0x6f,
    0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x72, 0x0a, 0x19, 0x43, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x4d, 0x73, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0c, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x3f, 0x0a, 0x07, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x14, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x6f, 0x6e,
    0x65, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xe5, 0x01, 0x0a, 0x1a, 0x43,
    0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x53, 0x0a, 0x06, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x30, 0x2e, 0x43, 0x41, 0x75, 0x74,
    0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x4d, 0x73, 0x67, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x3a, 0x09, 0x53, 0x55, 0x43,
    0x43, 0x45, 0x45, 0x44, 0x45, 0x44, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x3f,
    0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,
    0x0f, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x3a, 0x14, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69,
    0x6f, 0x6e, 0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22,
    0x31, 0x0a, 0x14, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x0d, 0x0a, 0x09, 0x53, 0x55, 0x43, 0x43, 0x45,
    0x45, 0x44, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44,
    0x10, 0x01, 0x22, 0x0f, 0x0a, 0x0d, 0x43, 0x4b, 0x65, 0x65, 0x70, 0x41, 0x6c, 0x69, 0x76, 0x65,
    0x4d, 0x73, 0x67, 0x22, 0x9d, 0x01, 0x0a, 0x14, 0x43, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x16, 0x0a, 0x06,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74,
    0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61,
    0x74, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6b, 0x62,
    0x70, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74,
    0x65, 0x4b, 0x62, 0x70, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x62, 0x75, 0x72, 0x73, 0x74, 0x5f, 0x62,
    0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6b, 0x62, 0x70, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0d, 0x52, 0x10, 0x62, 0x75, 0x72, 0x73, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x4b,
    0x62, 0x70, 0x73, 0x22, 0xd3, 0x01, 0x0a, 0x10, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56,
    0x69, 0x64, 0x65, 0x6f, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74,
    0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x16,
    0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x06,
    0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73,
    0x68, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x65,
    0x66, 0x72, 0x65, 0x73, 0x68, 0x52, 0x61, 0x74, 0x65, 0x12, 0x34, 0x0a, 0x16, 0x72, 0x65, 0x66,
    0x72, 0x65, 0x73, 0x68, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x65, 0x72, 0x61,
    0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x14, 0x72, 0x65, 0x66, 0x72, 0x65,
    0x73, 0x68, 0x52, 0x61, 0x74, 0x65, 0x4e, 0x75, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x12,
    0x38, 0x0a, 0x18, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f,
    0x64, 0x65, 0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x0d, 0x52, 0x16, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x52, 0x61, 0x74, 0x65, 0x44, 0x65,
    0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x22, 0xe1, 0x01, 0x0a, 0x14, 0x43, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x61,
    0x70, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x69, 0x6e, 0x66,
    0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x49,
    0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a, 0x12, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x63, 0x61,
    0x6e, 0x5f, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
    0x10, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x43, 0x61, 0x6e, 0x53, 0x75, 0x73, 0x70, 0x65, 0x6e,
    0x64, 0x12, 0x3d, 0x0a, 0x1b, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x64, 0x65, 0x63,
    0x6f, 0x64, 0x65, 0x5f, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6b, 0x62, 0x70, 0x73,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x18, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x44,
    0x65, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x4b, 0x62, 0x70, 0x73,
    0x12, 0x3b, 0x0a, 0x1a, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x62, 0x75, 0x72, 0x73,
    0x74, 0x5f, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6b, 0x62, 0x70, 0x73, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x05, 0x52, 0x17, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x42, 0x75, 0x72,
    0x73, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x4b, 0x62, 0x70, 0x73, 0x22, 0xe8, 0x05,
    0x0a, 0x16, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4d, 0x0a, 0x07, 0x71, 0x75, 0x61, 0x6c,
    0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72,
    0x65, 0x6e, 0x63, 0x65, 0x3a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x51,
    0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x64, 0x52, 0x07,
    0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x61, 0x78, 0x69, 0x6d,
    0x75, 0x6d, 0x5f, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x78, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x52, 0x65,
    0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x58, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x61, 0x78,
    0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
    0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d,
    0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x59, 0x12, 0x3e, 0x0a, 0x1b, 0x6d,
    0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65,
    0x5f, 0x6e, 0x75, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d,
    0x52, 0x19, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61,
    0x74, 0x65, 0x4e, 0x75, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x42, 0x0a, 0x1d, 0x6d,
    0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65,
    0x5f, 0x64, 0x65, 0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01,
    0x28, 0x0d, 0x52, 0x1b, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x72, 0x61, 0x74, 0x65, 0x44, 0x65, 0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x12,
    0x34, 0x0a, 0x14, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x62, 0x69, 0x74, 0x72, 0x61,
    0x74, 0x65, 0x5f, 0x6b, 0x62, 0x70, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x02, 0x2d,
    0x31, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74,
    0x65, 0x4b, 0x62, 0x70, 0x73, 0x12, 0x3e, 0x0a, 0x18, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f,
    0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x69, 0x6e,
    0x67, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x52, 0x16, 0x65,
    0x6e, 0x61, 0x62, 0x6c, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x44, 0x65, 0x63,
    0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x43, 0x0a, 0x1a, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f,
    0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x6f, 0x76, 0x65, 0x72,
    0x6c, 0x61, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65,
    0x52, 0x18, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61,
    0x6e, 0x63, 0x65, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x79, 0x12, 0x3a, 0x0a, 0x16, 0x65, 0x6e,
    0x61, 0x62, 0x6c, 0x65, 0x5f, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x69, 0x6e, 0x67, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65,
    0x52, 0x14, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x12, 0x3a, 0x0a, 0x16, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,
    0x5f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67,
    0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x52, 0x14, 0x65, 0x6e,
    0x61, 0x62, 0x6c, 0x65, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,
    0x6e, 0x67, 0x12, 0x3a, 0x0a, 0x16, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x70,
    0x75, 0x74, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x18, 0x0b, 0x20, 0x01,
    0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x52, 0x14, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,
    0x49, 0x6e, 0x70, 0x75, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x12, 0x28,
    0x0a, 0x0e, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x52, 0x0d, 0x61, 0x75, 0x64, 0x69, 0x6f,
    0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x22, 0xeb, 0x03, 0x0a, 0x16, 0x43, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x6f, 0x6e,
    0x66, 0x69, 0x67, 0x12, 0x45, 0x0a, 0x1f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x68, 0x61,
    0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x5f,
    0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1c, 0x65, 0x6e,
    0x61, 0x62, 0x6c, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x45, 0x6e, 0x63, 0x6f,
    0x64, 0x69, 0x6e, 0x67, 0x4e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x12, 0x4c, 0x0a, 0x23, 0x65, 0x6e,
    0x61, 0x62, 0x6c, 0x65, 0x5f, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x65, 0x6e,
    0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x6e, 0x76, 0x66, 0x62, 0x63, 0x5f, 0x68, 0x32, 0x36,
    0x34, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x48,
    0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x4e,
    0x76, 0x66, 0x62, 0x63, 0x48, 0x32, 0x36, 0x34, 0x12, 0x3f, 0x0a, 0x1c, 0x65, 0x6e, 0x61, 0x62,
    0x6c, 0x65, 0x5f, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x65, 0x6e, 0x63, 0x6f,
    0x64, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x6d, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x19,
    0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x45, 0x6e,
    0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x41, 0x6d, 0x64, 0x12, 0x43, 0x0a, 0x1e, 0x65, 0x6e, 0x61,
    0x62, 0x6c, 0x65, 0x5f, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x65, 0x6e, 0x63,
    0x6f, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x08, 0x52, 0x1b, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
    0x65, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x74, 0x65, 0x6c, 0x12, 0x3a,
    0x0a, 0x19, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64,
    0x69, 0x6e, 0x67, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x05, 0x52, 0x17, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x45, 0x6e, 0x63, 0x6f, 0x64,
    0x69, 0x6e, 0x67, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x12, 0x42, 0x0a, 0x1d, 0x64, 0x79,
    0x6e, 0x61, 0x6d, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x5f, 0x61, 0x64, 0x6a, 0x75, 0x73, 0x74,
    0x5f, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x08, 0x52, 0x1b, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x41, 0x64,
    0x6a, 0x75, 0x73, 0x74, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x36,
    0x0a, 0x17, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63,
    0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52,
    0x15, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x50, 0x72,
    0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x22, 0xbd, 0x02, 0x0a, 0x11, 0x43, 0x4e, 0x65, 0x67, 0x6f,
    0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x23, 0x0a, 0x0d,
    0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x08, 0x52, 0x0c, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x61, 0x74,
    0x61, 0x12, 0x5d, 0x0a, 0x14, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x75,
    0x64, 0x69, 0x6f, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,
    0x12, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f,
    0x64, 0x65, 0x63, 0x3a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75,
    0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x12, 0x73, 0x65,
    0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63,
    0x12, 0x5d, 0x0a, 0x14, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x76, 0x69, 0x64,
    0x65, 0x6f, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12,
    0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64,
    0x65, 0x63, 0x3a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64,
    0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x12, 0x73, 0x65, 0x6c,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x12,
    0x45, 0x0a, 0x15, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x76, 0x69, 0x64,
    0x65, 0x6f, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11,
    0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x6f, 0x64,
    0x65, 0x52, 0x13, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x69, 0x64, 0x65,
    0x6f, 0x4d, 0x6f, 0x64, 0x65, 0x73, 0x22, 0xce, 0x01, 0x0a, 0x13, 0x43, 0x4e, 0x65, 0x67, 0x6f,
    0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x69, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x23,
    0x0a, 0x0d, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x44,
    0x61, 0x74, 0x61, 0x12, 0x48, 0x0a, 0x16, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
    0x5f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x18, 0x02, 0x20,
    0x03, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64,
    0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x52, 0x14, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74,
    0x65, 0x64, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x12, 0x48, 0x0a,
    0x16, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x76, 0x69, 0x64, 0x65, 0x6f,
    0x5f, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x12, 0x2e,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65,
    0x63, 0x52, 0x14, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x56, 0x69, 0x64, 0x65,
    0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x73, 0x22, 0xe2, 0x01, 0x0a, 0x18, 0x43, 0x4e, 0x65, 0x67,
    0x6f, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,
    0x67, 0x4d, 0x73, 0x67, 0x12, 0x2a, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x43, 0x4e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74,
    0x65, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
    0x12, 0x4f, 0x0a, 0x17, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x17, 0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x15, 0x73, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,
    0x67, 0x12, 0x49, 0x0a, 0x15, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x15, 0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x43, 0x61, 0x70, 0x73, 0x52, 0x13, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,
    0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x61, 0x70, 0x73, 0x22, 0x19, 0x0a, 0x17,
    0x43, 0x4e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6d, 0x70,
    0x6c, 0x65, 0x74, 0x65, 0x4d, 0x73, 0x67, 0x22, 0xca, 0x01, 0x0a, 0x12, 0x43, 0x53, 0x74, 0x61,
    0x72, 0x74, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x73, 0x67, 0x12, 0x18,
    0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x52,
    0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x41, 0x0a, 0x05, 0x63, 0x6f, 0x64, 0x65,
    0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x3a, 0x17, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63,
    0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x05, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x12, 0x1d, 0x0a, 0x0a, 0x63,
    0x6f, 0x64, 0x65, 0x63, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52,
    0x09, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1c, 0x0a, 0x09, 0x66, 0x72,
    0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x66,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x73, 0x22, 0x13, 0x0a, 0x11, 0x43, 0x53, 0x74, 0x6f, 0x70, 0x41, 0x75, 0x64,
    0x69, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x73, 0x67, 0x22, 0xbe, 0x01, 0x0a, 0x12, 0x43, 0x53,
    0x74, 0x61, 0x72, 0x74, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x73, 0x67,
    0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x41, 0x0a, 0x05, 0x63, 0x6f,
    0x64, 0x65, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x3a, 0x17, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64,
    0x65, 0x63, 0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x05, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x12, 0x1d, 0x0a,
    0x0a, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0c, 0x52, 0x09, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x44, 0x61, 0x74, 0x61, 0x12, 0x14, 0x0a, 0x05,
    0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x77, 0x69, 0x64,
    0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x05, 0x20, 0x01,
    0x28, 0x0d, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x13, 0x0a, 0x11, 0x43, 0x53,
    0x74, 0x6f, 0x70, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x4d, 0x73, 0x67, 0x22,
    0x4b, 0x0a, 0x14, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79,
    0x54, 0x65, 0x73, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74,
    0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70,
    0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x22, 0x9b, 0x01, 0x0a,
    0x14, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x4d, 0x6f, 0x74, 0x69,
    0x6f, 0x6e, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d,
    0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74,
    0x4d, 0x61, 0x72, 0x6b, 0x12, 0x21, 0x0a, 0x0c, 0x78, 0x5f, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c,
    0x69, 0x7a, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x78, 0x4e, 0x6f, 0x72,
    0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x79, 0x5f, 0x6e, 0x6f, 0x72,
    0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x79,
    0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x64, 0x78,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x64, 0x78, 0x12, 0x0e, 0x0a, 0x02, 0x64, 0x79,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x64, 0x79, 0x22, 0x86, 0x01, 0x0a, 0x13, 0x43,
    0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c, 0x4d,
    0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72,
    0x6b, 0x12, 0x50, 0x0a, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f,
    0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x3a, 0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73,
    0x65, 0x57, 0x68, 0x65, 0x65, 0x6c, 0x55, 0x70, 0x52, 0x09, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x22, 0x7a, 0x0a, 0x12, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75,
    0x73, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70,
    0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69,
    0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x45, 0x0a, 0x06, 0x62, 0x75, 0x74, 0x74,
    0x6f, 0x6e, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x18, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74,
    0x74, 0x6f, 0x6e, 0x4c, 0x65, 0x66, 0x74, 0x52, 0x06, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x22,
    0x78, 0x0a, 0x10, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x55, 0x70,
    0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72,
    0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61,
    0x72, 0x6b, 0x12, 0x45, 0x0a, 0x06, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x02,
    0x28, 0x0e, 0x32, 0x13, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73,
    0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x3a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x4c, 0x65, 0x66,
    0x74, 0x52, 0x06, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x22, 0x4d, 0x0a, 0x10, 0x43, 0x49, 0x6e,
    0x70, 0x75, 0x74, 0x4b, 0x65, 0x79, 0x44, 0x6f, 0x77, 0x6e, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a,
    0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x1a, 0x0a, 0x08,
    0x73, 0x63, 0x61, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x08,
    0x73, 0x63, 0x61, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x22, 0x4b, 0x0a, 0x0e, 0x43, 0x49, 0x6e, 0x70,
    0x75, 0x74, 0x4b, 0x65, 0x79, 0x55, 0x70, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e,
    0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09,
    0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x63, 0x61,
    0x6e, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x08, 0x73, 0x63, 0x61,
    0x6e, 0x63, 0x6f, 0x64, 0x65, 0x22, 0x97, 0x01, 0x0a, 0x18, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x4d,
    0x73, 0x67, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x52, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x2d, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x73,
    0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x63, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x22,
    0xbf, 0x01, 0x0a, 0x15, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61,
    0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70,
    0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69,
    0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x52,
    0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x4c, 0x0a,
    0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70,
    0x75, 0x74, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x49, 0x6e, 0x76,
    0x61, 0x6c, 0x69, 0x64, 0x52, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x02, 0x28, 0x02, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x22, 0x3f, 0x0a, 0x18, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x70,
    0x61, 0x64, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x4d, 0x73, 0x67, 0x12, 0x23, 0x0a,
    0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x05, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
    0x49, 0x64, 0x22, 0x8e, 0x01, 0x0a, 0x11, 0x43, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x52,
    0x75, 0x6d, 0x62, 0x6c, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x52,
    0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x64, 0x12, 0x28, 0x0a,
    0x10, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x70, 0x65, 0x65,
    0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x6c, 0x65, 0x66, 0x74, 0x4d, 0x6f, 0x74,
    0x6f, 0x72, 0x53, 0x70, 0x65, 0x65, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x72, 0x69, 0x67, 0x68, 0x74,
    0x5f, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x70, 0x65, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x05, 0x52, 0x0f, 0x72, 0x69, 0x67, 0x68, 0x74, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x53, 0x70,
    0x65, 0x65, 0x64, 0x22, 0x22, 0x0a, 0x0c, 0x43, 0x53, 0x65, 0x74, 0x54, 0x69, 0x74, 0x6c, 0x65,
    0x4d, 0x73, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x22, 0x51, 0x0a, 0x0b, 0x43, 0x53, 0x65, 0x74, 0x49,
    0x63, 0x6f, 0x6e, 0x4d, 0x73, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x16, 0x0a, 0x06,
    0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x68, 0x65,
    0x69, 0x67, 0x68, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0c, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x56, 0x0a, 0x0e, 0x43, 0x53,
    0x68, 0x6f, 0x77, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x4d, 0x73, 0x67, 0x12, 0x21, 0x0a, 0x0c,
    0x78, 0x5f, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x02, 0x52, 0x0b, 0x78, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x12,
    0x21, 0x0a, 0x0c, 0x79, 0x5f, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0b, 0x79, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x69, 0x7a,
    0x65, 0x64, 0x22, 0x10, 0x0a, 0x0e, 0x43, 0x48, 0x69, 0x64, 0x65, 0x43, 0x75, 0x72, 0x73, 0x6f,
    0x72, 0x4d, 0x73, 0x67, 0x22, 0x2c, 0x0a, 0x0d, 0x43, 0x53, 0x65, 0x74, 0x43, 0x75, 0x72, 0x73,
    0x6f, 0x72, 0x4d, 0x73, 0x67, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x52, 0x08, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72,
    0x49, 0x64, 0x22, 0x31, 0x0a, 0x12, 0x43, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72,
    0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x75, 0x72, 0x73,
    0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x52, 0x08, 0x63, 0x75, 0x72,
    0x73, 0x6f, 0x72, 0x49, 0x64, 0x22, 0x9f, 0x01, 0x0a, 0x12, 0x43, 0x53, 0x65, 0x74, 0x43, 0x75,
    0x72, 0x73, 0x6f, 0x72, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x1b, 0x0a, 0x09,
    0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04, 0x52,
    0x08, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64,
    0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12,
    0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
    0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x13, 0x0a, 0x05, 0x68, 0x6f, 0x74, 0x5f, 0x78,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x68, 0x6f, 0x74, 0x58, 0x12, 0x13, 0x0a, 0x05,
    0x68, 0x6f, 0x74, 0x5f, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x68, 0x6f, 0x74,
    0x59, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c,
    0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x44, 0x0a, 0x14, 0x43, 0x56, 0x69, 0x64, 0x65,
    0x6f, 0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x4d, 0x73, 0x67, 0x12,
    0x12, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x69,
    0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x22, 0x2a, 0x0a,
    0x14, 0x43, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x4d, 0x73, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x09, 0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x0e, 0x0a, 0x0c, 0x43, 0x51, 0x75,
    0x69, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2f, 0x0a, 0x10, 0x43, 0x44, 0x65,
    0x6c, 0x65, 0x74, 0x65, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x4d, 0x73, 0x67, 0x12, 0x1b, 0x0a,
    0x09, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x04,
    0x52, 0x08, 0x63, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x49, 0x64, 0x22, 0x4c, 0x0a, 0x19, 0x43, 0x53,
    0x65, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2f, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69,
    0x67, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x43, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
    0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x25, 0x0a, 0x0a, 0x43, 0x53, 0x65, 0x74,
    0x51, 0x6f, 0x53, 0x4d, 0x73, 0x67, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x5f, 0x71, 0x6f,
    0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x08, 0x52, 0x06, 0x75, 0x73, 0x65, 0x51, 0x6f, 0x73, 0x22,
    0xb6, 0x01, 0x0a, 0x16, 0x43, 0x53, 0x65, 0x74, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x1c, 0x0a, 0x09, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x09, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x65, 0x61, 0x73,
    0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x72, 0x65, 0x61, 0x73, 0x6f,
    0x6e, 0x73, 0x12, 0x2f, 0x0a, 0x13, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x5f,
    0x6e, 0x75, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52,
    0x12, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x4e, 0x75, 0x6d, 0x65, 0x72, 0x61,
    0x74, 0x6f, 0x72, 0x12, 0x33, 0x0a, 0x15, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65,
    0x5f, 0x64, 0x65, 0x6e, 0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0d, 0x52, 0x14, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x44, 0x65, 0x6e,
    0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x22, 0x30, 0x0a, 0x14, 0x43, 0x53, 0x65, 0x74,
    0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x4d, 0x73, 0x67,
    0x12, 0x18, 0x0a, 0x07, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x05, 0x52, 0x07, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x22, 0x2e, 0x0a, 0x12, 0x43, 0x4f,
    0x76, 0x65, 0x72, 0x6c, 0x61, 0x79, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x4d, 0x73, 0x67,
    0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0xf3, 0x02, 0x0a, 0x1b, 0x43,
    0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x41,
    0x74, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x4d, 0x73, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
    0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x1a, 0x0a, 0x08, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73,
    0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73,
    0x73, 0x12, 0x2e, 0x0a, 0x13, 0x70, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x5f, 0x69, 0x6e, 0x5f,
    0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11,
    0x70, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x50, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73,
    0x73, 0x12, 0x2d, 0x0a, 0x12, 0x62, 0x6f, 0x6f, 0x74, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x5f,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x62,
    0x6f, 0x6f, 0x74, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x12, 0x29, 0x0a, 0x10, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d,
    0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x73,
    0x65, 0x72, 0x69, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x09, 0x52, 0x0c, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72,
    0x12, 0x17, 0x0a, 0x07, 0x63, 0x68, 0x69, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x09, 0x52, 0x06, 0x63, 0x68, 0x69, 0x70, 0x49, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x74, 0x74,
    0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0a, 0x61,
    0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x6f, 0x6e,
    0x67, 0x6c, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x0d, 0x52, 0x0d, 0x64, 0x6f, 0x6e, 0x67, 0x6c, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x22, 0xe0, 0x05, 0x0a, 0x18, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a,
    0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x29, 0x0a, 0x10,
    0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c,
    0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x74, 0x74, 0x6f,
    0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e,
    0x73, 0x12, 0x1c, 0x0a, 0x0a, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x70, 0x61, 0x64, 0x5f, 0x78, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x11, 0x52, 0x08, 0x6c, 0x65, 0x66, 0x74, 0x50, 0x61, 0x64, 0x58, 0x12,
    0x1c, 0x0a, 0x0a, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x70, 0x61, 0x64, 0x5f, 0x79, 0x18, 0x05, 0x20,
    0x01, 0x28, 0x11, 0x52, 0x08, 0x6c, 0x65, 0x66, 0x74, 0x50, 0x61, 0x64, 0x59, 0x12, 0x1e, 0x0a,
    0x0b, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x70, 0x61, 0x64, 0x5f, 0x78, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x11, 0x52, 0x09, 0x72, 0x69, 0x67, 0x68, 0x74, 0x50, 0x61, 0x64, 0x58, 0x12, 0x1e, 0x0a,
    0x0b, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x70, 0x61, 0x64, 0x5f, 0x79, 0x18, 0x07, 0x20, 0x01,
    0x28, 0x11, 0x52, 0x09, 0x72, 0x69, 0x67, 0x68, 0x74, 0x50, 0x61, 0x64, 0x59, 0x12, 0x20, 0x0a,
    0x0c, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x73, 0x74, 0x69, 0x63, 0x6b, 0x5f, 0x78, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x11, 0x52, 0x0a, 0x6c, 0x65, 0x66, 0x74, 0x53, 0x74, 0x69, 0x63, 0x6b, 0x58, 0x12,
    0x20, 0x0a, 0x0c, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x73, 0x74, 0x69, 0x63, 0x6b, 0x5f, 0x79, 0x18,
    0x09, 0x20, 0x01, 0x28, 0x11, 0x52, 0x0a, 0x6c, 0x65, 0x66, 0x74, 0x53, 0x74, 0x69, 0x63, 0x6b,
    0x59, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x6e, 0x61, 0x6c, 0x6f, 0x67,
    0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6c, 0x65, 0x66, 0x74, 0x41, 0x6e, 0x61, 0x6c,
    0x6f, 0x67, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x6e, 0x61, 0x6c,
    0x6f, 0x67, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x69, 0x67, 0x68, 0x74, 0x41,
    0x6e, 0x61, 0x6c, 0x6f, 0x67, 0x12, 0x17, 0x0a, 0x07, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x5f, 0x78,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x11, 0x52, 0x06, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x58, 0x12, 0x17,
    0x0a, 0x07, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x5f, 0x79, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x11, 0x52,
    0x06, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x59, 0x12, 0x17, 0x0a, 0x07, 0x61, 0x63, 0x63, 0x65, 0x6c,
    0x5f, 0x7a, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x11, 0x52, 0x06, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x5a,
    0x12, 0x15, 0x0a, 0x06, 0x67, 0x79, 0x72, 0x6f, 0x5f, 0x78, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x11,
    0x52, 0x05, 0x67, 0x79, 0x72, 0x6f, 0x58, 0x12, 0x15, 0x0a, 0x06, 0x67, 0x79, 0x72, 0x6f, 0x5f,
    0x79, 0x18, 0x10, 0x20, 0x01, 0x28, 0x11, 0x52, 0x05, 0x67, 0x79, 0x72, 0x6f, 0x59, 0x12, 0x15,
    0x0a, 0x06, 0x67, 0x79, 0x72, 0x6f, 0x5f, 0x7a, 0x18, 0x11, 0x20, 0x01, 0x28, 0x11, 0x52, 0x05,
    0x67, 0x79, 0x72, 0x6f, 0x5a, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61,
    0x74, 0x5f, 0x77, 0x18, 0x12, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x67, 0x79, 0x72, 0x6f, 0x71,
    0x75, 0x61, 0x74, 0x57, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61, 0x74,
    0x5f, 0x78, 0x18, 0x13, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75,
    0x61, 0x74, 0x58, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61, 0x74, 0x5f,
    0x79, 0x18, 0x14, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61,
    0x74, 0x59, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61, 0x74, 0x5f, 0x7a,
    0x18, 0x15, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x67, 0x79, 0x72, 0x6f, 0x71, 0x75, 0x61, 0x74,
    0x5a, 0x12, 0x2c, 0x0a, 0x11, 0x67, 0x79, 0x72, 0x6f, 0x73, 0x74, 0x65, 0x65, 0x72, 0x69, 0x6e,
    0x67, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x18, 0x16, 0x20, 0x01, 0x28, 0x11, 0x52, 0x11, 0x67, 0x79,
    0x72, 0x6f, 0x73, 0x74, 0x65, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x61, 0x6e, 0x67, 0x6c, 0x65, 0x12,
    0x22, 0x0a, 0x0c, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18,
    0x17, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x6c, 0x65,
    0x76, 0x65, 0x6c, 0x22, 0xfa, 0x01, 0x0a, 0x1b, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x48, 0x49, 0x44,
    0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72,
    0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61,
    0x72, 0x6b, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
    0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x22, 0x0a,
    0x0c, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0d, 0x52, 0x0c, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65,
    0x73, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x79, 0x6c, 0x6f,
    0x61, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x73, 0x74, 0x61, 0x74, 0x65, 0x50,
    0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x5f, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d,
    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x21, 0x0a,
    0x0c, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0c, 0x52, 0x0b, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x42, 0x79, 0x74, 0x65, 0x73,
    0x22, 0x7f, 0x0a, 0x23, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x6c, 0x65, 0x72, 0x57, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x50, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x63, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x77, 0x69, 0x72, 0x65, 0x6c,
    0x65, 0x73, 0x73, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x08, 0x52, 0x0f, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x50, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x12, 0x2d, 0x0a, 0x12, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x5f, 0x61,
    0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11,
    0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
    0x65, 0x22, 0x48, 0x0a, 0x1b, 0x43, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x4d, 0x73, 0x67,
    0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69,
    0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0xf3, 0x01, 0x0a, 0x16,
    0x43, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x48, 0x61, 0x70, 0x74, 0x69, 0x63, 0x50, 0x75,
    0x6c, 0x73, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05,
    0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65,
    0x78, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x64, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x05, 0x52, 0x08, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x2b,
    0x0a, 0x11, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f,
    0x73, 0x65, 0x63, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x10, 0x64, 0x75, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x12, 0x2b, 0x0a, 0x11, 0x69,
    0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x70, 0x65,
    0x61, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b,
    0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x66,
    0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x66, 0x6c, 0x61, 0x67,
    0x73, 0x22, 0x55, 0x0a, 0x1f, 0x43, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x6c, 0x65, 0x72, 0x50, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,
    0x64, 0x4d, 0x73, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x18,
    0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
    0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x22, 0x72, 0x0a, 0x1e, 0x43, 0x53, 0x65, 0x74,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x50, 0x61, 0x69, 0x72, 0x69, 0x6e,
    0x67, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
    0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x5f,
    0x70, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x63,
    0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x50, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x4c, 0x0a, 0x1f,
    0x43, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c,
    0x65, 0x72, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d, 0x73, 0x67, 0x12,
    0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e,
    0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0x69, 0x0a, 0x19, 0x43, 0x53,
    0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x65, 0x74, 0x74,
    0x69, 0x6e, 0x67, 0x73, 0x4d, 0x73, 0x67, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x05, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x49, 0x6e, 0x64,
    0x65, 0x78, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x61, 0x77, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e,
    0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0b, 0x72, 0x61, 0x77, 0x53, 0x65, 0x74,
    0x74, 0x69, 0x6e, 0x67, 0x73, 0x22, 0x31, 0x0a, 0x10, 0x43, 0x53, 0x65, 0x74, 0x47, 0x61, 0x6d,
    0x6d, 0x61, 0x52, 0x61, 0x6d, 0x70, 0x4d, 0x73, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x61, 0x6d,
    0x6d, 0x61, 0x5f, 0x72, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x67,
    0x61, 0x6d, 0x6d, 0x61, 0x52, 0x61, 0x6d, 0x70, 0x22, 0x56, 0x0a, 0x0f, 0x43, 0x53, 0x65, 0x74,
    0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x4d, 0x73, 0x67, 0x12, 0x43, 0x0a, 0x08, 0x61,
    0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x3a,
    0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69,
    0x74, 0x79, 0x49, 0x64, 0x6c, 0x65, 0x52, 0x08, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,
    0x22, 0x13, 0x0a, 0x11, 0x43, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x53, 0x75, 0x73, 0x70, 0x65,
    0x6e, 0x64, 0x4d, 0x73, 0x67, 0x22, 0x34, 0x0a, 0x16, 0x43, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61,
    0x6c, 0x48, 0x65, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x4d, 0x73, 0x67, 0x12,
    0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x4a, 0x0a, 0x14, 0x43,
    0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x65, 0x72, 0x65, 0x52, 0x65, 0x61, 0x64, 0x79,
    0x4d, 0x73, 0x67, 0x12, 0x32, 0x0a, 0x15, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f,
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x52, 0x13, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x44, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x43, 0x0a, 0x1a, 0x43, 0x56, 0x69, 0x72, 0x74,
    0x75, 0x61, 0x6c, 0x48, 0x65, 0x72, 0x65, 0x53, 0x68, 0x61, 0x72, 0x65, 0x44, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x4d, 0x73, 0x67, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x64,
    0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x2e, 0x0a, 0x12,
    0x43, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x4c, 0x6f, 0x73, 0x74, 0x4d,
    0x73, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0d, 0x52, 0x07, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x22, 0x83, 0x01, 0x0a,
    0x0c, 0x43, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x39, 0x0a,
    0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x0d, 0x2e,
    0x45, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x3a, 0x12, 0x6b, 0x5f,
    0x45, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x4e, 0x6f, 0x6e, 0x65,
    0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x66, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x66, 0x72, 0x65,
    0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x73, 0x22, 0x77, 0x0a, 0x0c, 0x43, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x12, 0x39, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x45, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61,
    0x74, 0x3a, 0x12, 0x6b, 0x5f, 0x45, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61,
    0x74, 0x4e, 0x6f, 0x6e, 0x65, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x14, 0x0a,
    0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x77, 0x69,
    0x64, 0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0d, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x74, 0x0a, 0x0b, 0x43,
    0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x08, 0x65, 0x76,
    0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x3a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x07, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
    0x70, 0x22, 0xe5, 0x03, 0x0a, 0x0b, 0x43, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74,
    0x73, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0d, 0x52, 0x07, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a,
    0x69, 0x6e, 0x70, 0x75, 0x74, 0x5f, 0x6d, 0x61, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x52, 0x09, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x61, 0x72, 0x6b, 0x12, 0x24, 0x0a, 0x06, 0x65,
    0x76, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x43, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74,
    0x73, 0x12, 0x48, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x04, 0x20, 0x02, 0x28,
    0x0e, 0x32, 0x13, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x3a, 0x1b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x50, 0x65, 0x6e, 0x64,
    0x69, 0x6e, 0x67, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x2a, 0x0a, 0x11, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61,
    0x72, 0x74, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x12, 0x2e, 0x0a, 0x13, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x5f, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x02, 0x52, 0x11, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x44, 0x69, 0x73, 0x70, 0x6c,
    0x61, 0x79, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x69, 0x6e, 0x67, 0x5f,
    0x74, 0x69, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x08, 0x70, 0x69, 0x6e, 0x67,
    0x54, 0x69, 0x6d, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x62,
    0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x18, 0x09, 0x20,
    0x01, 0x28, 0x02, 0x52, 0x0d, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61,
    0x74, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x77,
    0x69, 0x64, 0x74, 0x68, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0d, 0x6c, 0x69, 0x6e, 0x6b,
    0x42, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x61, 0x63,
    0x6b, 0x65, 0x74, 0x5f, 0x6c, 0x6f, 0x73, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0a,
    0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x4c, 0x6f, 0x73, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x22, 0xaa, 0x01, 0x0a, 0x1a, 0x43, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x41, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61,
    0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x44, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x74,
    0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x45, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x41, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x53,
    0x74, 0x61, 0x74, 0x3a, 0x0f, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61,
    0x74, 0x46, 0x50, 0x53, 0x52, 0x08, 0x73, 0x74, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14,
    0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x52, 0x05, 0x63,
    0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x18,
    0x03, 0x20, 0x02, 0x28, 0x02, 0x52, 0x07, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x12, 0x16,
    0x0a, 0x06, 0x73, 0x74, 0x64, 0x64, 0x65, 0x76, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x06,
    0x73, 0x74, 0x64, 0x64, 0x65, 0x76, 0x22, 0xf3, 0x01, 0x0a, 0x12, 0x43, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x47, 0x0a,
    0x09, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e,
    0x32, 0x13, 0x2e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74,
    0x61, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x69, 0x6e, 0x67, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x52, 0x08, 0x64, 0x61,
    0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x22, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18,
    0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x43, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74,
    0x61, 0x74, 0x73, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x73, 0x12, 0x48, 0x0a, 0x11, 0x61, 0x63,
    0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18,
    0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x43, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74,
    0x61, 0x74, 0x41, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c,
    0x75, 0x65, 0x52, 0x10, 0x61, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x53,
    0x74, 0x61, 0x74, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x5f, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x02, 0x28, 0x05, 0x52, 0x0d, 0x6c,
    0x61, 0x74, 0x65, 0x73, 0x74, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x49, 0x64, 0x22, 0x2f, 0x0a, 0x0d,
    0x43, 0x44, 0x65, 0x62, 0x75, 0x67, 0x44, 0x75, 0x6d, 0x70, 0x4d, 0x73, 0x67, 0x12, 0x1e, 0x0a,
    0x0a, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0c, 0x52, 0x0a, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x22, 0x37, 0x0a,
    0x07, 0x43, 0x4c, 0x6f, 0x67, 0x4d, 0x73, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x07,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x5c, 0x0a, 0x0d, 0x43, 0x4c, 0x6f, 0x67, 0x55, 0x70,
    0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x73, 0x67, 0x12, 0x37, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x45, 0x4c, 0x6f, 0x67, 0x46, 0x69, 0x6c, 0x65,
    0x54, 0x79, 0x70, 0x65, 0x3a, 0x14, 0x6b, 0x5f, 0x45, 0x4c, 0x6f, 0x67, 0x46, 0x69, 0x6c, 0x65,
    0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x42, 0x6f, 0x6f, 0x74, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65,
    0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04,
    0x64, 0x61, 0x74, 0x61, 0x2a, 0xb3, 0x01, 0x0a, 0x0e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x24, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x6e, 0x76, 0x61, 0x6c,
    0x69, 0x64, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x1d, 0x0a,
    0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61,
    0x74, 0x73, 0x10, 0x02, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x44, 0x61, 0x74, 0x61, 0x43, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x10, 0x03, 0x2a, 0x60, 0x0a, 0x17, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x4d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x50, 0x69, 0x6e, 0x67, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x10, 0x01, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x50, 0x69,
    0x6e, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x10, 0x02, 0x2a, 0x9b, 0x11, 0x0a,
    0x15, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x29, 0x0a, 0x25, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e,
    0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x10,
    0x01, 0x12, 0x2a, 0x0a, 0x26, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x10, 0x02, 0x12, 0x23, 0x0a,
    0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x4e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x69, 0x74,
    0x10, 0x03, 0x12, 0x28, 0x0a, 0x24, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x10, 0x04, 0x12, 0x27, 0x0a, 0x23,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x4e, 0x65, 0x67, 0x6f, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6d, 0x70, 0x6c,
    0x65, 0x74, 0x65, 0x10, 0x05, 0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48,
    0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x10, 0x06, 0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x10, 0x07, 0x12,
    0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54,
    0x65, 0x73, 0x74, 0x10, 0x08, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4b, 0x65, 0x65, 0x70, 0x41, 0x6c, 0x69,
    0x76, 0x65, 0x10, 0x09, 0x12, 0x27, 0x0a, 0x23, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x4c, 0x41, 0x53, 0x54, 0x5f, 0x53, 0x45,
    0x54, 0x55, 0x50, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x10, 0x0f, 0x12, 0x22, 0x0a,
    0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x10,
    0x32, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x6f, 0x70, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x44, 0x61,
    0x74, 0x61, 0x10, 0x33, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x72, 0x74, 0x56, 0x69, 0x64,
    0x65, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x10, 0x34, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x6f, 0x70,
    0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x10, 0x35, 0x12, 0x24, 0x0a, 0x20, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49,
    0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x4d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x10,
    0x36, 0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57,
    0x68, 0x65, 0x65, 0x6c, 0x10, 0x37, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4d,
    0x6f, 0x75, 0x73, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x10, 0x38, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e,
    0x70, 0x75, 0x74, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x55, 0x70, 0x10, 0x39, 0x12, 0x20, 0x0a, 0x1c,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x49, 0x6e, 0x70, 0x75, 0x74, 0x4b, 0x65, 0x79, 0x44, 0x6f, 0x77, 0x6e, 0x10, 0x3a, 0x12, 0x1e,
    0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4b, 0x65, 0x79, 0x55, 0x70, 0x10, 0x3b, 0x12, 0x28,
    0x0a, 0x24, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x41, 0x74,
    0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x10, 0x3c, 0x12, 0x25, 0x0a, 0x21, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75,
    0x74, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x10, 0x3d, 0x12,
    0x28, 0x0a, 0x24, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x44,
    0x65, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x10, 0x3e, 0x12, 0x1e, 0x0a, 0x1a, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x68, 0x6f,
    0x77, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x10, 0x3f, 0x12, 0x1e, 0x0a, 0x1a, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x48, 0x69, 0x64,
    0x65, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x10, 0x40, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74,
    0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x10, 0x41, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x47, 0x65, 0x74, 0x43,
    0x75, 0x72, 0x73, 0x6f, 0x72, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x10, 0x42, 0x12, 0x22, 0x0a, 0x1e,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x53, 0x65, 0x74, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x10, 0x43,
    0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x75, 0x72, 0x73, 0x6f, 0x72,
    0x10, 0x44, 0x12, 0x26, 0x0a, 0x22, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x10, 0x45, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e,
    0x70, 0x75, 0x74, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x54, 0x65, 0x73, 0x74, 0x10, 0x46,
    0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x52, 0x75, 0x6d, 0x62, 0x6c,
    0x65, 0x10, 0x47, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x79, 0x45, 0x6e,
    0x61, 0x62, 0x6c, 0x65, 0x64, 0x10, 0x4a, 0x12, 0x2b, 0x0a, 0x27, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68,
    0x65, 0x64, 0x10, 0x4b, 0x12, 0x28, 0x0a, 0x24, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x10, 0x4c, 0x12, 0x26,
    0x0a, 0x22, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x48, 0x61, 0x70, 0x74, 0x69, 0x63, 0x50,
    0x75, 0x6c, 0x73, 0x65, 0x10, 0x4d, 0x12, 0x2b, 0x0a, 0x27, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x65,
    0x64, 0x10, 0x4e, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x63, 0x6f,
    0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x50, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74,
    0x54, 0x69, 0x74, 0x6c, 0x65, 0x10, 0x51, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x49, 0x63,
    0x6f, 0x6e, 0x10, 0x52, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x51, 0x75, 0x69, 0x74, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x10, 0x53, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x51, 0x6f, 0x53, 0x10,
    0x57, 0x12, 0x33, 0x0a, 0x2f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
    0x6c, 0x6c, 0x65, 0x72, 0x57, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x50, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x63, 0x65, 0x10, 0x58, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x47, 0x61, 0x6d,
    0x6d, 0x61, 0x52, 0x61, 0x6d, 0x70, 0x10, 0x59, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x56, 0x69, 0x64, 0x65,
    0x6f, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x5a, 0x12, 0x2b,
    0x0a, 0x27, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65,
    0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x48, 0x49, 0x44, 0x10, 0x5d, 0x12, 0x24, 0x0a, 0x20, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53,
    0x65, 0x74, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x10,
    0x5e, 0x12, 0x2f, 0x0a, 0x2b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f,
    0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c,
    0x65, 0x72, 0x50, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,
    0x10, 0x5f, 0x12, 0x2e, 0x0a, 0x2a, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
    0x6c, 0x65, 0x72, 0x50, 0x61, 0x69, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74,
    0x10, 0x60, 0x12, 0x2f, 0x0a, 0x2b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x43, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
    0x74, 0x10, 0x61, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69,
    0x74, 0x79, 0x10, 0x62, 0x12, 0x2c, 0x0a, 0x28, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
    0x10, 0x63, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x53, 0x75, 0x73, 0x70,
    0x65, 0x6e, 0x64, 0x10, 0x64, 0x12, 0x29, 0x0a, 0x25, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x74,
    0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x10, 0x65,
    0x12, 0x26, 0x0a, 0x22, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x65, 0x72, 0x65, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x10, 0x66, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x56, 0x69, 0x72, 0x74,
    0x75, 0x61, 0x6c, 0x48, 0x65, 0x72, 0x65, 0x52, 0x65, 0x61, 0x64, 0x79, 0x10, 0x67, 0x12, 0x2a,
    0x0a, 0x26, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x43, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x65, 0x72, 0x65, 0x53, 0x68, 0x61,
    0x72, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x10, 0x68, 0x2a, 0x47, 0x0a, 0x0e, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x14,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x74, 0x10, 0x01, 0x2a, 0xc0, 0x01, 0x0a, 0x11, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41,
    0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63,
    0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x52, 0x61, 0x77,
    0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41,
    0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x56, 0x6f, 0x72, 0x62, 0x69, 0x73, 0x10,
    0x02, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75,
    0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x4f, 0x70, 0x75, 0x73, 0x10, 0x03, 0x12, 0x1a,
    0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f,
    0x43, 0x6f, 0x64, 0x65, 0x63, 0x4d, 0x50, 0x33, 0x10, 0x04, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65,
    0x63, 0x41, 0x41, 0x43, 0x10, 0x05, 0x2a, 0xfa, 0x01, 0x0a, 0x11, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x12, 0x1b, 0x0a, 0x17,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f,
    0x64, 0x65, 0x63, 0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63,
    0x52, 0x61, 0x77, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x56, 0x50, 0x38, 0x10,
    0x02, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69,
    0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x56, 0x50, 0x39, 0x10, 0x03, 0x12, 0x1b, 0x0a,
    0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43,
    0x6f, 0x64, 0x65, 0x63, 0x48, 0x32, 0x36, 0x34, 0x10, 0x04, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65,
    0x63, 0x48, 0x32, 0x36, 0x35, 0x10, 0x05, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x4f, 0x52,
    0x42, 0x58, 0x31, 0x10, 0x06, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x4f, 0x52, 0x42, 0x58,
    0x32, 0x10, 0x07, 0x2a, 0x71, 0x0a, 0x18, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x51, 0x75,
    0x61, 0x6c, 0x69, 0x74, 0x79, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x12,
    0x18, 0x0a, 0x14, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x51, 0x75, 0x61, 0x6c,
    0x69, 0x74, 0x79, 0x46, 0x61, 0x73, 0x74, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x42, 0x61, 0x6c,
    0x61, 0x6e, 0x63, 0x65, 0x64, 0x10, 0x02, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x42, 0x65, 0x61, 0x75, 0x74,
    0x69, 0x66, 0x75, 0x6c, 0x10, 0x03, 0x2a, 0x58, 0x0a, 0x0e, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x12, 0x27, 0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x41, 0x75, 0x74, 0x6f,
    0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x01, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x42, 0x69,
    0x74, 0x72, 0x61, 0x74, 0x65, 0x55, 0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x10, 0x00,
    0x2a, 0x4a, 0x0a, 0x12, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x44, 0x61,
    0x74, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x10,
    0x00, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e,
    0x67, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x61, 0x74, 0x61, 0x10, 0x01, 0x2a, 0xcb, 0x01, 0x0a,
    0x12, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74,
    0x74, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x4c, 0x65, 0x66, 0x74, 0x10,
    0x01, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f,
    0x75, 0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x52, 0x69, 0x67, 0x68, 0x74, 0x10, 0x02,
    0x12, 0x1e, 0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75,
    0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x10, 0x10,
    0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75,
    0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x58, 0x31, 0x10, 0x20, 0x12, 0x1a, 0x0a, 0x16,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75,
    0x74, 0x74, 0x6f, 0x6e, 0x58, 0x32, 0x10, 0x40, 0x12, 0x20, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e,
    0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x10, 0x80, 0x20, 0x2a, 0x98, 0x01, 0x0a, 0x1a, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c,
    0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c,
    0x55, 0x70, 0x10, 0x78, 0x12, 0x24, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c, 0x44, 0x6f, 0x77, 0x6e, 0x10,
    0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65,
    0x6c, 0x4c, 0x65, 0x66, 0x74, 0x10, 0x03, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x57, 0x68, 0x65, 0x65, 0x6c, 0x52, 0x69,
    0x67, 0x68, 0x74, 0x10, 0x04, 0x2a, 0xa7, 0x06, 0x0a, 0x17, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x54, 0x79, 0x70,
    0x65, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61,
    0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69,
    0x64, 0x10, 0x00, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x44, 0x50, 0x61, 0x64,
    0x55, 0x70, 0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x44, 0x50, 0x61,
    0x64, 0x44, 0x6f, 0x77, 0x6e, 0x10, 0x02, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x44, 0x50, 0x61, 0x64, 0x4c, 0x65, 0x66, 0x74, 0x10, 0x04, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e,
    0x70, 0x75, 0x74, 0x44, 0x50, 0x61, 0x64, 0x52, 0x69, 0x67, 0x68, 0x74, 0x10, 0x08, 0x12, 0x1e,
    0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70,
    0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x10, 0x10, 0x12, 0x1d,
    0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70,
    0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x10, 0x20, 0x12, 0x22, 0x0a,
    0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61,
    0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c, 0x65, 0x66, 0x74, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x10,
    0x40, 0x12, 0x24, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61,
    0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x69, 0x67, 0x68, 0x74, 0x54,
    0x68, 0x75, 0x6d, 0x62, 0x10, 0x80, 0x01, 0x12, 0x26, 0x0a, 0x21, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x4c, 0x65, 0x66, 0x74, 0x53, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x65, 0x72, 0x10, 0x80, 0x02, 0x12,
    0x27, 0x0a, 0x22, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65,
    0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x69, 0x67, 0x68, 0x74, 0x53, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x65, 0x72, 0x10, 0x80, 0x04, 0x12, 0x1f, 0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75,
    0x74, 0x47, 0x75, 0x69, 0x64, 0x65, 0x10, 0x80, 0x08, 0x12, 0x1b, 0x0a, 0x16, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70,
    0x75, 0x74, 0x41, 0x10, 0x80, 0x20, 0x12, 0x1b, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x42,
    0x10, 0x80, 0x40, 0x12, 0x1c, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x58, 0x10, 0x80, 0x80,
    0x01, 0x12, 0x1c, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61,
    0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x59, 0x10, 0x80, 0x80, 0x02, 0x12,
    0x25, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65,
    0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c, 0x65, 0x66, 0x74, 0x54, 0x68, 0x75, 0x6d,
    0x62, 0x58, 0x10, 0x80, 0x80, 0x04, 0x12, 0x25, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c,
    0x65, 0x66, 0x74, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x59, 0x10, 0x80, 0x80, 0x08, 0x12, 0x26, 0x0a,
    0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61,
    0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x69, 0x67, 0x68, 0x74, 0x54, 0x68, 0x75, 0x6d, 0x62,
    0x58, 0x10, 0x80, 0x80, 0x10, 0x12, 0x26, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x69,
    0x67, 0x68, 0x74, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x59, 0x10, 0x80, 0x80, 0x20, 0x12, 0x26, 0x0a,
    0x20, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61,
    0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c, 0x65, 0x66, 0x74, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65,
    0x72, 0x10, 0x80, 0x80, 0x40, 0x12, 0x28, 0x0a, 0x21, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x47, 0x61, 0x6d, 0x65, 0x70, 0x61, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x52, 0x69,
    0x67, 0x68, 0x74, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x10, 0x80, 0x80, 0x80, 0x01, 0x2a,
    0x89, 0x02, 0x0a, 0x17, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x72, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x12, 0x21, 0x0a, 0x1d, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74,
    0x65, 0x53, 0x6c, 0x6f, 0x77, 0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x10, 0x01, 0x12, 0x21,
    0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x72, 0x61, 0x74, 0x65, 0x53, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x10,
    0x02, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x53, 0x6c, 0x6f, 0x77, 0x45, 0x6e, 0x63, 0x6f, 0x64,
    0x65, 0x10, 0x04, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x53, 0x6c, 0x6f, 0x77, 0x4e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x10, 0x08, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x53, 0x6c, 0x6f, 0x77,
    0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x10, 0x10, 0x12, 0x1e, 0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x53, 0x6c,
    0x6f, 0x77, 0x47, 0x61, 0x6d, 0x65, 0x10, 0x20, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x74, 0x65, 0x53, 0x6c,
    0x6f, 0x77, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x10, 0x40, 0x2a, 0x65, 0x0a, 0x0f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x12, 0x19,
    0x0a, 0x15, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x76,
    0x69, 0x74, 0x79, 0x49, 0x64, 0x6c, 0x65, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x47, 0x61,
    0x6d, 0x65, 0x10, 0x02, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x44, 0x65, 0x73, 0x6b, 0x74, 0x6f, 0x70,
    0x10, 0x03, 0x2a, 0x44, 0x0a, 0x12, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x61, 0x74,
    0x61, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x17, 0x0a, 0x13, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x10,
    0x01, 0x12, 0x15, 0x0a, 0x11, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x61,
    0x74, 0x61, 0x4c, 0x6f, 0x73, 0x74, 0x10, 0x02, 0x2a, 0x64, 0x0a, 0x0c, 0x45, 0x41, 0x75, 0x64,
    0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x16, 0x0a, 0x12, 0x6b, 0x5f, 0x45, 0x41,
    0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00,
    0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x46, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x31, 0x36, 0x42, 0x69, 0x74, 0x4c, 0x69, 0x74, 0x74, 0x6c, 0x65, 0x45, 0x6e, 0x64,
    0x69, 0x61, 0x6e, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x6b, 0x5f, 0x45, 0x41, 0x75, 0x64, 0x69,
    0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x10, 0x02, 0x2a, 0x57,
    0x0a, 0x0c, 0x45, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x16,
    0x0a, 0x12, 0x6b, 0x5f, 0x45, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x6b, 0x5f, 0x45, 0x56, 0x69, 0x64,
    0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x59, 0x56, 0x31, 0x32, 0x10, 0x01, 0x12, 0x17,
    0x0a, 0x13, 0x6b, 0x5f, 0x45, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x41, 0x63, 0x63, 0x65, 0x6c, 0x10, 0x02, 0x2a, 0xd7, 0x01, 0x0a, 0x13, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12,
    0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74,
    0x73, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x10, 0x01, 0x12, 0x1b,
    0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73,
    0x44, 0x65, 0x62, 0x75, 0x67, 0x44, 0x75, 0x6d, 0x70, 0x10, 0x02, 0x12, 0x1c, 0x0a, 0x18, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4c, 0x6f, 0x67,
    0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x10, 0x03, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4c, 0x6f, 0x67, 0x55, 0x70,
    0x6c, 0x6f, 0x61, 0x64, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x10, 0x04, 0x12, 0x1f, 0x0a, 0x1b, 0x6b,
    0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4c, 0x6f, 0x67,
    0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x44, 0x61, 0x74, 0x61, 0x10, 0x05, 0x12, 0x23, 0x0a, 0x1f,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4c, 0x6f,
    0x67, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x10,
    0x06, 0x2a, 0x85, 0x05, 0x0a, 0x11, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74,
    0x61, 0x72, 0x74, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x6e, 0x64,
    0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49,
    0x6e, 0x70, 0x75, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x63, 0x76, 0x10, 0x02, 0x12,
    0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x70, 0x75,
    0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65, 0x64, 0x10, 0x03, 0x12, 0x1e,
    0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x70, 0x75, 0x74,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x64, 0x10, 0x04, 0x12, 0x1c,
    0x0a, 0x18, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x10, 0x05, 0x12, 0x23, 0x0a, 0x1f,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76,
    0x65, 0x6e, 0x74, 0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x10,
    0x06, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x45,
    0x6e, 0x64, 0x10, 0x07, 0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x76, 0x65,
    0x72, 0x74, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x10, 0x08, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45,
    0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x43, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x64, 0x10, 0x09, 0x12, 0x22, 0x0a, 0x1e,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76,
    0x65, 0x6e, 0x74, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x10, 0x0a,
    0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x45, 0x6e, 0x64,
    0x10, 0x0b, 0x12, 0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x6e, 0x64, 0x10, 0x0c, 0x12,
    0x1b, 0x0a, 0x17, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x63, 0x76, 0x10, 0x0d, 0x12, 0x22, 0x0a, 0x1e,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76,
    0x65, 0x6e, 0x74, 0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x10, 0x0e,
    0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x45, 0x6e, 0x64,
    0x10, 0x0f, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x42,
    0x65, 0x67, 0x69, 0x6e, 0x10, 0x10, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x55, 0x70, 0x6c,
    0x6f, 0x61, 0x64, 0x45, 0x6e, 0x64, 0x10, 0x11, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x43,
    0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x10, 0x12, 0x2a, 0xd4, 0x02, 0x0a, 0x12, 0x45, 0x53,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74,
    0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x10,
    0x00, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79,
    0x65, 0x64, 0x10, 0x01, 0x12, 0x2a, 0x0a, 0x26, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61,
    0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x44, 0x72, 0x6f, 0x70,
    0x70, 0x65, 0x64, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x53, 0x6c, 0x6f, 0x77, 0x10, 0x02,
    0x12, 0x2a, 0x0a, 0x26, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x4e,
    0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4c, 0x6f, 0x73, 0x74, 0x10, 0x03, 0x12, 0x29, 0x0a, 0x25,
    0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65,
    0x73, 0x75, 0x6c, 0x74, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x44, 0x65, 0x63, 0x6f, 0x64,
    0x65, 0x53, 0x6c, 0x6f, 0x77, 0x10, 0x04, 0x12, 0x2c, 0x0a, 0x28, 0x6b, 0x5f, 0x45, 0x53, 0x74,
    0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x44,
    0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x72, 0x72,
    0x75, 0x70, 0x74, 0x10, 0x05, 0x12, 0x23, 0x0a, 0x1f, 0x6b, 0x5f, 0x45, 0x53, 0x74, 0x72, 0x65,
    0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x44, 0x72, 0x6f,
    0x70, 0x70, 0x65, 0x64, 0x4c, 0x61, 0x74, 0x65, 0x10, 0x06, 0x12, 0x24, 0x0a, 0x20, 0x6b, 0x5f,
    0x45, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x52, 0x65, 0x73, 0x65, 0x74, 0x10, 0x07,
    0x2a, 0xa2, 0x05, 0x0a, 0x15, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x41, 0x63, 0x63, 0x75, 0x6d,
    0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x53, 0x74, 0x61, 0x74, 0x12, 0x13, 0x0a, 0x0f, 0x6b, 0x5f,
    0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x46, 0x50, 0x53, 0x10, 0x00, 0x12,
    0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x43,
    0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53,
    0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74,
    0x61, 0x74, 0x43, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x4d, 0x53, 0x10, 0x02, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x53, 0x74, 0x61, 0x74, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x4d, 0x53, 0x10, 0x03, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x53, 0x74, 0x65, 0x61, 0x6d, 0x44, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53, 0x10, 0x04, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x44, 0x75,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53, 0x10, 0x05, 0x12, 0x21, 0x0a, 0x1d, 0x6b, 0x5f,
    0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,
    0x6b, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53, 0x10, 0x06, 0x12, 0x20, 0x0a,
    0x1c, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x44, 0x65, 0x63,
    0x6f, 0x64, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53, 0x10, 0x07, 0x12,
    0x21, 0x0a, 0x1d, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x44,
    0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x53,
    0x10, 0x08, 0x12, 0x20, 0x0a, 0x1c, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74,
    0x61, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x4d, 0x53, 0x10, 0x09, 0x12, 0x1f, 0x0a, 0x1b, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x53, 0x74, 0x61, 0x74, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x4d, 0x53, 0x10, 0x0a, 0x12, 0x1e, 0x0a, 0x1a, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x53, 0x74, 0x61, 0x74, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63,
    0x79, 0x4d, 0x53, 0x10, 0x0b, 0x12, 0x1d, 0x0a, 0x19, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x53, 0x74, 0x61, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79,
    0x4d, 0x53, 0x10, 0x0c, 0x12, 0x22, 0x0a, 0x1e, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x53, 0x74, 0x61, 0x74, 0x52, 0x6f, 0x75, 0x6e, 0x64, 0x54, 0x72, 0x69, 0x70, 0x4c, 0x61, 0x74,
    0x65, 0x6e, 0x63, 0x79, 0x4d, 0x53, 0x10, 0x0d, 0x12, 0x1a, 0x0a, 0x16, 0x6b, 0x5f, 0x45, 0x46,
    0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65,
    0x4d, 0x53, 0x10, 0x0e, 0x12, 0x27, 0x0a, 0x23, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74,
    0x65, 0x4b, 0x62, 0x69, 0x74, 0x50, 0x65, 0x72, 0x53, 0x65, 0x63, 0x10, 0x0f, 0x12, 0x27, 0x0a,
    0x23, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x42, 0x69, 0x74, 0x72, 0x61, 0x74, 0x65, 0x4b, 0x62, 0x69, 0x74, 0x50, 0x65,
    0x72, 0x53, 0x65, 0x63, 0x10, 0x10, 0x12, 0x27, 0x0a, 0x23, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x42, 0x61, 0x6e, 0x64, 0x77, 0x69,
    0x64, 0x74, 0x68, 0x4b, 0x62, 0x69, 0x74, 0x50, 0x65, 0x72, 0x53, 0x65, 0x63, 0x10, 0x11, 0x12,
    0x24, 0x0a, 0x20, 0x6b, 0x5f, 0x45, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x74, 0x50,
    0x61, 0x63, 0x6b, 0x65, 0x74, 0x4c, 0x6f, 0x73, 0x73, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74,
    0x61, 0x67, 0x65, 0x10, 0x12, 0x2a, 0x5e, 0x0a, 0x0c, 0x45, 0x4c, 0x6f, 0x67, 0x46, 0x69, 0x6c,
    0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x14, 0x6b, 0x5f, 0x45, 0x4c, 0x6f, 0x67, 0x46,
    0x69, 0x6c, 0x65, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x42, 0x6f, 0x6f, 0x74, 0x10, 0x00, 0x12,
    0x19, 0x0a, 0x15, 0x6b, 0x5f, 0x45, 0x4c, 0x6f, 0x67, 0x46, 0x69, 0x6c, 0x65, 0x53, 0x79, 0x73,
    0x74, 0x65, 0x6d, 0x52, 0x65, 0x73, 0x65, 0x74, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x6b, 0x5f,
    0x45, 0x4c, 0x6f, 0x67, 0x46, 0x69, 0x6c, 0x65, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x44, 0x65,
    0x62, 0x75, 0x67, 0x10, 0x02, 0x42, 0x05, 0x48, 0x01, 0x80, 0x01, 0x00, 0x4a, 0xd9, 0xd6, 0x01,
    0x0a, 0x07, 0x12, 0x05, 0x00, 0x00, 0xbc, 0x05, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03,
    0x00, 0x00, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x00, 0x00, 0x1c,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x00, 0x07, 0x13, 0x0a, 0x0d,
    0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x00, 0x07, 0x13, 0x0a, 0x0e, 0x0a,
    0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x00, 0x07, 0x13, 0x0a, 0x0c, 0x0a,
    0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x03, 0x00, 0x16, 0x1b, 0x0a, 0x08, 0x0a, 0x01, 0x08,
    0x12, 0x03, 0x01, 0x00, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03, 0x01,
    0x00, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x03, 0x01, 0x07, 0x1a,
    0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x03, 0x01, 0x07, 0x1a, 0x0a,
    0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x01, 0x07, 0x1a, 0x0a,
    0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x03, 0x12, 0x03, 0x01, 0x1d, 0x22, 0x0a, 0x0a, 0x0a,
    0x02, 0x05, 0x00, 0x12, 0x04, 0x03, 0x00, 0x09, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01,
    0x12, 0x03, 0x03, 0x05, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x04,
    0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x04, 0x08, 0x1f,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x04, 0x22, 0x24, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x01, 0x12, 0x03, 0x05, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x05, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x01, 0x02, 0x12, 0x03, 0x05, 0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12,
    0x03, 0x06, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x06,
    0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x02, 0x02, 0x12, 0x03, 0x06, 0x22, 0x23,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x03, 0x12, 0x03, 0x07, 0x08, 0x22, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x07, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x07, 0x20, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02,
    0x04, 0x12, 0x03, 0x08, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x01, 0x12,
    0x03, 0x08, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x08,
    0x2b, 0x2c, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x04, 0x0b, 0x00, 0x0e, 0x01, 0x0a, 0x0a,
    0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x03, 0x0b, 0x05, 0x1c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x00, 0x12, 0x03, 0x0c, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x0c, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x02, 0x12, 0x03,
    0x0c, 0x28, 0x29, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12, 0x03, 0x0d, 0x08, 0x2b,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x0d, 0x08, 0x26, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x03, 0x0d, 0x29, 0x2a, 0x0a, 0x0a, 0x0a, 0x02,
    0x05, 0x02, 0x12, 0x04, 0x10, 0x00, 0x4a, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x02, 0x01, 0x12,
    0x03, 0x10, 0x05, 0x1a, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x00, 0x12, 0x03, 0x11, 0x08,
    0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x11, 0x08, 0x2d, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x00, 0x02, 0x12, 0x03, 0x11, 0x30, 0x31, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x03, 0x12, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x01, 0x01, 0x12, 0x03, 0x12, 0x08, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x01,
    0x02, 0x12, 0x03, 0x12, 0x31, 0x32, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x02, 0x12, 0x03,
    0x13, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x13, 0x08,
    0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x02, 0x02, 0x12, 0x03, 0x13, 0x2a, 0x2b, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x03, 0x14, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x03, 0x01, 0x12, 0x03, 0x14, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x03, 0x02, 0x12, 0x03, 0x14, 0x2f, 0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x04,
    0x12, 0x03, 0x15, 0x08, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x04, 0x01, 0x12, 0x03,
    0x15, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x04, 0x02, 0x12, 0x03, 0x15, 0x2e,
    0x2f, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x03, 0x16, 0x08, 0x2c, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x05, 0x01, 0x12, 0x03, 0x16, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x05, 0x02, 0x12, 0x03, 0x16, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x06, 0x12, 0x03, 0x17, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x06, 0x01,
    0x12, 0x03, 0x17, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x06, 0x02, 0x12, 0x03,
    0x17, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x07, 0x12, 0x03, 0x18, 0x08, 0x2d,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x07, 0x01, 0x12, 0x03, 0x18, 0x08, 0x28, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x07, 0x02, 0x12, 0x03, 0x18, 0x2b, 0x2c, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x02, 0x02, 0x08, 0x12, 0x03, 0x19, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x08, 0x01, 0x12, 0x03, 0x19, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x08, 0x02,
    0x12, 0x03, 0x19, 0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x09, 0x12, 0x03, 0x1a,
    0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x09, 0x01, 0x12, 0x03, 0x1a, 0x08, 0x2b,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x09, 0x02, 0x12, 0x03, 0x1a, 0x2e, 0x30, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x02, 0x02, 0x0a, 0x12, 0x03, 0x1b, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x0a, 0x01, 0x12, 0x03, 0x1b, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x0a, 0x02, 0x12, 0x03, 0x1b, 0x29, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x0b, 0x12,
    0x03, 0x1c, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x1c,
    0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0b, 0x02, 0x12, 0x03, 0x1c, 0x28, 0x2a,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x0c, 0x12, 0x03, 0x1d, 0x08, 0x2c, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x0c, 0x01, 0x12, 0x03, 0x1d, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x0c, 0x02, 0x12, 0x03, 0x1d, 0x29, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02,
    0x0d, 0x12, 0x03, 0x1e, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0d, 0x01, 0x12,
    0x03, 0x1e, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0d, 0x02, 0x12, 0x03, 0x1e,
    0x28, 0x2a, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x0e, 0x12, 0x03, 0x1f, 0x08, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0e, 0x01, 0x12, 0x03, 0x1f, 0x08, 0x28, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x0e, 0x02, 0x12, 0x03, 0x1f, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x0f, 0x12, 0x03, 0x20, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0f,
    0x01, 0x12, 0x03, 0x20, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x0f, 0x02, 0x12,
    0x03, 0x20, 0x2a, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x10, 0x12, 0x03, 0x21, 0x08,
    0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x10, 0x01, 0x12, 0x03, 0x21, 0x08, 0x26, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x10, 0x02, 0x12, 0x03, 0x21, 0x29, 0x2b, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x02, 0x02, 0x11, 0x12, 0x03, 0x22, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x11, 0x01, 0x12, 0x03, 0x22, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x11,
    0x02, 0x12, 0x03, 0x22, 0x27, 0x29, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x12, 0x12, 0x03,
    0x23, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x12, 0x01, 0x12, 0x03, 0x23, 0x08,
    0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x12, 0x02, 0x12, 0x03, 0x23, 0x27, 0x29, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x13, 0x12, 0x03, 0x24, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x13, 0x01, 0x12, 0x03, 0x24, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x13, 0x02, 0x12, 0x03, 0x24, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x14,
    0x12, 0x03, 0x25, 0x08, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x14, 0x01, 0x12, 0x03,
    0x25, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x14, 0x02, 0x12, 0x03, 0x25, 0x2f,
    0x31, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x15, 0x12, 0x03, 0x26, 0x08, 0x2f, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x15, 0x01, 0x12, 0x03, 0x26, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x15, 0x02, 0x12, 0x03, 0x26, 0x2c, 0x2e, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x16, 0x12, 0x03, 0x27, 0x08, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x16, 0x01,
    0x12, 0x03, 0x27, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x16, 0x02, 0x12, 0x03,
    0x27, 0x2f, 0x31, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x17, 0x12, 0x03, 0x28, 0x08, 0x28,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x17, 0x01, 0x12, 0x03, 0x28, 0x08, 0x22, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x17, 0x02, 0x12, 0x03, 0x28, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x02, 0x02, 0x18, 0x12, 0x03, 0x29, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x18, 0x01, 0x12, 0x03, 0x29, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x18, 0x02,
    0x12, 0x03, 0x29, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x19, 0x12, 0x03, 0x2a,
    0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x19, 0x01, 0x12, 0x03, 0x2a, 0x08, 0x21,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x19, 0x02, 0x12, 0x03, 0x2a, 0x24, 0x26, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x02, 0x02, 0x1a, 0x12, 0x03, 0x2b, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x1a, 0x01, 0x12, 0x03, 0x2b, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x1a, 0x02, 0x12, 0x03, 0x2b, 0x29, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x1b, 0x12,
    0x03, 0x2c, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1b, 0x01, 0x12, 0x03, 0x2c,
    0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1b, 0x02, 0x12, 0x03, 0x2c, 0x29, 0x2b,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x1c, 0x12, 0x03, 0x2d, 0x08, 0x2a, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x1c, 0x01, 0x12, 0x03, 0x2d, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x1c, 0x02, 0x12, 0x03, 0x2d, 0x27, 0x29, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02,
    0x1d, 0x12, 0x03, 0x2e, 0x08, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1d, 0x01, 0x12,
    0x03, 0x2e, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1d, 0x02, 0x12, 0x03, 0x2e,
    0x2d, 0x2f, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x1e, 0x12, 0x03, 0x2f, 0x08, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1e, 0x01, 0x12, 0x03, 0x2f, 0x08, 0x28, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x1e, 0x02, 0x12, 0x03, 0x2f, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x1f, 0x12, 0x03, 0x30, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1f,
    0x01, 0x12, 0x03, 0x30, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x1f, 0x02, 0x12,
    0x03, 0x30, 0x28, 0x2a, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x20, 0x12, 0x03, 0x31, 0x08,
    0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x20, 0x01, 0x12, 0x03, 0x31, 0x08, 0x26, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x20, 0x02, 0x12, 0x03, 0x31, 0x29, 0x2b, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x02, 0x02, 0x21, 0x12, 0x03, 0x32, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x21, 0x01, 0x12, 0x03, 0x32, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x21,
    0x02, 0x12, 0x03, 0x32, 0x32, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x22, 0x12, 0x03,
    0x33, 0x08, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x22, 0x01, 0x12, 0x03, 0x33, 0x08,
    0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x22, 0x02, 0x12, 0x03, 0x33, 0x2f, 0x31, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x23, 0x12, 0x03, 0x34, 0x08, 0x30, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x23, 0x01, 0x12, 0x03, 0x34, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x23, 0x02, 0x12, 0x03, 0x34, 0x2d, 0x2f, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x24,
    0x12, 0x03, 0x35, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x24, 0x01, 0x12, 0x03,
    0x35, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x24, 0x02, 0x12, 0x03, 0x35, 0x32,
    0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x25, 0x12, 0x03, 0x36, 0x08, 0x2e, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x25, 0x01, 0x12, 0x03, 0x36, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x25, 0x02, 0x12, 0x03, 0x36, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x26, 0x12, 0x03, 0x37, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x26, 0x01,
    0x12, 0x03, 0x37, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x26, 0x02, 0x12, 0x03,
    0x37, 0x23, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x27, 0x12, 0x03, 0x38, 0x08, 0x25,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x27, 0x01, 0x12, 0x03, 0x38, 0x08, 0x1f, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x27, 0x02, 0x12, 0x03, 0x38, 0x22, 0x24, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x02, 0x02, 0x28, 0x12, 0x03, 0x39, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x28, 0x01, 0x12, 0x03, 0x39, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x28, 0x02,
    0x12, 0x03, 0x39, 0x26, 0x28, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x29, 0x12, 0x03, 0x3a,
    0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x29, 0x01, 0x12, 0x03, 0x3a, 0x08, 0x1e,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x29, 0x02, 0x12, 0x03, 0x3a, 0x21, 0x23, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x02, 0x02, 0x2a, 0x12, 0x03, 0x3b, 0x08, 0x3d, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x2a, 0x01, 0x12, 0x03, 0x3b, 0x08, 0x37, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x2a, 0x02, 0x12, 0x03, 0x3b, 0x3a, 0x3c, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x2b, 0x12,
    0x03, 0x3c, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2b, 0x01, 0x12, 0x03, 0x3c,
    0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2b, 0x02, 0x12, 0x03, 0x3c, 0x27, 0x29,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x2c, 0x12, 0x03, 0x3d, 0x08, 0x2e, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x2c, 0x01, 0x12, 0x03, 0x3d, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x02, 0x02, 0x2c, 0x02, 0x12, 0x03, 0x3d, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02,
    0x2d, 0x12, 0x03, 0x3e, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2d, 0x01, 0x12,
    0x03, 0x3e, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2d, 0x02, 0x12, 0x03, 0x3e,
    0x32, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x2e, 0x12, 0x03, 0x3f, 0x08, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2e, 0x01, 0x12, 0x03, 0x3f, 0x08, 0x28, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x02, 0x02, 0x2e, 0x02, 0x12, 0x03, 0x3f, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x02, 0x02, 0x2f, 0x12, 0x03, 0x40, 0x08, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2f,
    0x01, 0x12, 0x03, 0x40, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x2f, 0x02, 0x12,
    0x03, 0x40, 0x36, 0x38, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x30, 0x12, 0x03, 0x41, 0x08,
    0x38, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x30, 0x01, 0x12, 0x03, 0x41, 0x08, 0x32, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x30, 0x02, 0x12, 0x03, 0x41, 0x35, 0x37, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x02, 0x02, 0x31, 0x12, 0x03, 0x42, 0x08, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x31, 0x01, 0x12, 0x03, 0x42, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x31,
    0x02, 0x12, 0x03, 0x42, 0x36, 0x38, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x32, 0x12, 0x03,
    0x43, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x32, 0x01, 0x12, 0x03, 0x43, 0x08,
    0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x32, 0x02, 0x12, 0x03, 0x43, 0x26, 0x28, 0x0a,
    0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x33, 0x12, 0x03, 0x44, 0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x33, 0x01, 0x12, 0x03, 0x44, 0x08, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02,
    0x02, 0x33, 0x02, 0x12, 0x03, 0x44, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x34,
    0x12, 0x03, 0x45, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x34, 0x01, 0x12, 0x03,
    0x45, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x34, 0x02, 0x12, 0x03, 0x45, 0x28,
    0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x35, 0x12, 0x03, 0x46, 0x08, 0x34, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x35, 0x01, 0x12, 0x03, 0x46, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x02, 0x02, 0x35, 0x02, 0x12, 0x03, 0x46, 0x30, 0x33, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02,
    0x02, 0x36, 0x12, 0x03, 0x47, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x36, 0x01,
    0x12, 0x03, 0x47, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x36, 0x02, 0x12, 0x03,
    0x47, 0x2d, 0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x02, 0x02, 0x37, 0x12, 0x03, 0x48, 0x08, 0x2f,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x37, 0x01, 0x12, 0x03, 0x48, 0x08, 0x28, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x02, 0x02, 0x37, 0x02, 0x12, 0x03, 0x48, 0x2b, 0x2e, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x02, 0x02, 0x38, 0x12, 0x03, 0x49, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02,
    0x38, 0x01, 0x12, 0x03, 0x49, 0x08, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x02, 0x02, 0x38, 0x02,
    0x12, 0x03, 0x49, 0x31, 0x34, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x03, 0x12, 0x04, 0x4c, 0x00, 0x4f,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x03, 0x01, 0x12, 0x03, 0x4c, 0x05, 0x13, 0x0a, 0x0b, 0x0a,
    0x04, 0x05, 0x03, 0x02, 0x00, 0x12, 0x03, 0x4d, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x4d, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x00,
    0x02, 0x12, 0x03, 0x4d, 0x1f, 0x20, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x03, 0x02, 0x01, 0x12, 0x03,
    0x4e, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x01, 0x12, 0x03, 0x4e, 0x08,
    0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x03, 0x02, 0x01, 0x02, 0x12, 0x03, 0x4e, 0x22, 0x23, 0x0a,
    0x0a, 0x0a, 0x02, 0x05, 0x04, 0x12, 0x04, 0x51, 0x00, 0x58, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05,
    0x04, 0x01, 0x12, 0x03, 0x51, 0x05, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x00, 0x12,
    0x03, 0x52, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03, 0x52,
    0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x00, 0x02, 0x12, 0x03, 0x52, 0x22, 0x23,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x01, 0x12, 0x03, 0x53, 0x08, 0x23, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x04, 0x02, 0x01, 0x01, 0x12, 0x03, 0x53, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x04, 0x02, 0x01, 0x02, 0x12, 0x03, 0x53, 0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x04, 0x02,
    0x02, 0x12, 0x03, 0x54, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x02, 0x01, 0x12,
    0x03, 0x54, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x54,
    0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x03, 0x12, 0x03, 0x55, 0x08, 0x24, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x03, 0x01, 0x12, 0x03, 0x55, 0x08, 0x1f, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x04, 0x02, 0x03, 0x02, 0x12, 0x03, 0x55, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x04, 0x02, 0x04, 0x12, 0x03, 0x56, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x04,
    0x01, 0x12, 0x03, 0x56, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x04, 0x02, 0x12,
    0x03, 0x56, 0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x04, 0x02, 0x05, 0x12, 0x03, 0x57, 0x08,
    0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x05, 0x01, 0x12, 0x03, 0x57, 0x08, 0x1e, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x04, 0x02, 0x05, 0x02, 0x12, 0x03, 0x57, 0x21, 0x22, 0x0a, 0x0a, 0x0a,
    0x02, 0x05, 0x05, 0x12, 0x04, 0x5a, 0x00, 0x63, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x05, 0x01,
    0x12, 0x03, 0x5a, 0x05, 0x16, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x00, 0x12, 0x03, 0x5b,
    0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5b, 0x08, 0x1f,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x00, 0x02, 0x12, 0x03, 0x5b, 0x22, 0x23, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x05, 0x02, 0x01, 0x12, 0x03, 0x5c, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x05, 0x02, 0x01, 0x01, 0x12, 0x03, 0x5c, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02,
    0x01, 0x02, 0x12, 0x03, 0x5c, 0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x02, 0x12,
    0x03, 0x5d, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x02, 0x01, 0x12, 0x03, 0x5d,
    0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x02, 0x02, 0x12, 0x03, 0x5d, 0x21, 0x22,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x03, 0x12, 0x03, 0x5e, 0x08, 0x23, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x05, 0x02, 0x03, 0x01, 0x12, 0x03, 0x5e, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x05, 0x02, 0x03, 0x02, 0x12, 0x03, 0x5e, 0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02,
    0x04, 0x12, 0x03, 0x5f, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x04, 0x01, 0x12,
    0x03, 0x5f, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x04, 0x02, 0x12, 0x03, 0x5f,
    0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x05, 0x12, 0x03, 0x60, 0x08, 0x24, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x05, 0x01, 0x12, 0x03, 0x60, 0x08, 0x1f, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x05, 0x02, 0x05, 0x02, 0x12, 0x03, 0x60, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x05, 0x02, 0x06, 0x12, 0x03, 0x61, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x06,
    0x01, 0x12, 0x03, 0x61, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x06, 0x02, 0x12,
    0x03, 0x61, 0x23, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x05, 0x02, 0x07, 0x12, 0x03, 0x62, 0x08,
    0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x07, 0x01, 0x12, 0x03, 0x62, 0x08, 0x20, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x05, 0x02, 0x07, 0x02, 0x12, 0x03, 0x62, 0x23, 0x24, 0x0a, 0x0a, 0x0a,
    0x02, 0x05, 0x06, 0x12, 0x04, 0x65, 0x00, 0x69, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x06, 0x01,
    0x12, 0x03, 0x65, 0x05, 0x1d, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x06, 0x02, 0x00, 0x12, 0x03, 0x66,
    0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x06, 0x02, 0x00, 0x01, 0x12, 0x03, 0x66, 0x08, 0x1c,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x06, 0x02, 0x00, 0x02, 0x12, 0x03, 0x66, 0x1f, 0x20, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x06, 0x02, 0x01, 0x12, 0x03, 0x67, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x06, 0x02, 0x01, 0x01, 0x12, 0x03, 0x67, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x06, 0x02,
    0x01, 0x02, 0x12, 0x03, 0x67, 0x23, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x06, 0x02, 0x02, 0x12,
    0x03, 0x68, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x06, 0x02, 0x02, 0x01, 0x12, 0x03, 0x68,
    0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x06, 0x02, 0x02, 0x02, 0x12, 0x03, 0x68, 0x24, 0x25,
    0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x07, 0x12, 0x04, 0x6b, 0x00, 0x6e, 0x01, 0x0a, 0x0a, 0x0a, 0x03,
    0x05, 0x07, 0x01, 0x12, 0x03, 0x6b, 0x05, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x07, 0x02, 0x00,
    0x12, 0x03, 0x6c, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x07, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x6c, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x07, 0x02, 0x00, 0x02, 0x12, 0x03, 0x6c, 0x25,
    0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x07, 0x02, 0x01, 0x12, 0x03, 0x6d, 0x08, 0x26, 0x0a, 0x0c,
    0x0a, 0x05, 0x05, 0x07, 0x02, 0x01, 0x01, 0x12, 0x03, 0x6d, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05,
    0x05, 0x07, 0x02, 0x01, 0x02, 0x12, 0x03, 0x6d, 0x24, 0x25, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x08,
    0x12, 0x04, 0x70, 0x00, 0x73, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x08, 0x01, 0x12, 0x03, 0x70,
    0x05, 0x17, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x08, 0x02, 0x00, 0x12, 0x03, 0x71, 0x08, 0x22, 0x0a,
    0x0c, 0x0a, 0x05, 0x05, 0x08, 0x02, 0x00, 0x01, 0x12, 0x03, 0x71, 0x08, 0x1d, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x08, 0x02, 0x00, 0x02, 0x12, 0x03, 0x71, 0x20, 0x21, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x08, 0x02, 0x01, 0x12, 0x03, 0x72, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x08, 0x02, 0x01,
    0x01, 0x12, 0x03, 0x72, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x08, 0x02, 0x01, 0x02, 0x12,
    0x03, 0x72, 0x20, 0x21, 0x0a, 0x0a, 0x0a, 0x02, 0x05, 0x09, 0x12, 0x04, 0x75, 0x00, 0x7c, 0x01,
    0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x09, 0x01, 0x12, 0x03, 0x75, 0x05, 0x17, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x09, 0x02, 0x00, 0x12, 0x03, 0x76, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x76, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x00, 0x02,
    0x12, 0x03, 0x76, 0x23, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x09, 0x02, 0x01, 0x12, 0x03, 0x77,
    0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x01, 0x01, 0x12, 0x03, 0x77, 0x08, 0x21,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x01, 0x02, 0x12, 0x03, 0x77, 0x24, 0x25, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x09, 0x02, 0x02, 0x12, 0x03, 0x78, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x09, 0x02, 0x02, 0x01, 0x12, 0x03, 0x78, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02,
    0x02, 0x02, 0x12, 0x03, 0x78, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x09, 0x02, 0x03, 0x12,
    0x03, 0x79, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x03, 0x01, 0x12, 0x03, 0x79,
    0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x03, 0x02, 0x12, 0x03, 0x79, 0x21, 0x23,
    0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x09, 0x02, 0x04, 0x12, 0x03, 0x7a, 0x08, 0x24, 0x0a, 0x0c, 0x0a,
    0x05, 0x05, 0x09, 0x02, 0x04, 0x01, 0x12, 0x03, 0x7a, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x09, 0x02, 0x04, 0x02, 0x12, 0x03, 0x7a, 0x21, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x09, 0x02,
    0x05, 0x12, 0x03, 0x7b, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x05, 0x01, 0x12,
    0x03, 0x7b, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x09, 0x02, 0x05, 0x02, 0x12, 0x03, 0x7b,
    0x26, 0x2a, 0x0a, 0x0b, 0x0a, 0x02, 0x05, 0x0a, 0x12, 0x05, 0x7e, 0x00, 0x83, 0x01, 0x01, 0x0a,
    0x0a, 0x0a, 0x03, 0x05, 0x0a, 0x01, 0x12, 0x03, 0x7e, 0x05, 0x1f, 0x0a, 0x0b, 0x0a, 0x04, 0x05,
    0x0a, 0x02, 0x00, 0x12, 0x03, 0x7f, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x0a, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x7f, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x0a, 0x02, 0x00, 0x02, 0x12,
    0x03, 0x7f, 0x20, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0a, 0x02, 0x01, 0x12, 0x04, 0x80, 0x01,
    0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0x80, 0x01, 0x08,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0a, 0x02, 0x01, 0x02, 0x12, 0x04, 0x80, 0x01, 0x22, 0x26,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0a, 0x02, 0x02, 0x12, 0x04, 0x81, 0x01, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x0a, 0x02, 0x02, 0x01, 0x12, 0x04, 0x81, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0a, 0x02, 0x02, 0x02, 0x12, 0x04, 0x81, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x05, 0x0a, 0x02, 0x03, 0x12, 0x04, 0x82, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0a,
    0x02, 0x03, 0x01, 0x12, 0x04, 0x82, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0a, 0x02,
    0x03, 0x02, 0x12, 0x04, 0x82, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x0b, 0x12, 0x06,
    0x85, 0x01, 0x00, 0x9c, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x0b, 0x01, 0x12, 0x04, 0x85,
    0x01, 0x05, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x00, 0x12, 0x04, 0x86, 0x01, 0x08,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x86, 0x01, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x00, 0x02, 0x12, 0x04, 0x86, 0x01, 0x27, 0x28, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x01, 0x12, 0x04, 0x87, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x87, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x01, 0x02, 0x12, 0x04, 0x87, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x0b, 0x02, 0x02, 0x12, 0x04, 0x88, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x88, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x02,
    0x02, 0x12, 0x04, 0x88, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x03, 0x12,
    0x04, 0x89, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x89, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x03, 0x02, 0x12, 0x04, 0x89,
    0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x04, 0x12, 0x04, 0x8a, 0x01, 0x08,
    0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x04, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x04, 0x02, 0x12, 0x04, 0x8a, 0x01, 0x29, 0x2a, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x05, 0x12, 0x04, 0x8b, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x05, 0x01, 0x12, 0x04, 0x8b, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x05, 0x02, 0x12, 0x04, 0x8b, 0x01, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x0b, 0x02, 0x06, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02,
    0x06, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x06,
    0x02, 0x12, 0x04, 0x8c, 0x01, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x07, 0x12,
    0x04, 0x8d, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x8d, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x07, 0x02, 0x12, 0x04, 0x8d,
    0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x08, 0x12, 0x04, 0x8e, 0x01, 0x08,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x08, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x08, 0x02, 0x12, 0x04, 0x8e, 0x01, 0x2a, 0x2d, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x09, 0x12, 0x04, 0x8f, 0x01, 0x08, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x09, 0x01, 0x12, 0x04, 0x8f, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x09, 0x02, 0x12, 0x04, 0x8f, 0x01, 0x2c, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x0b, 0x02, 0x0a, 0x12, 0x04, 0x90, 0x01, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02,
    0x0a, 0x01, 0x12, 0x04, 0x90, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0a,
    0x02, 0x12, 0x04, 0x90, 0x01, 0x2d, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x0b, 0x12,
    0x04, 0x91, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0b, 0x01, 0x12, 0x04,
    0x91, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0b, 0x02, 0x12, 0x04, 0x91,
    0x01, 0x25, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x0c, 0x12, 0x04, 0x92, 0x01, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0c, 0x01, 0x12, 0x04, 0x92, 0x01, 0x08, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0c, 0x02, 0x12, 0x04, 0x92, 0x01, 0x21, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x0d, 0x12, 0x04, 0x93, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x0d, 0x01, 0x12, 0x04, 0x93, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x0d, 0x02, 0x12, 0x04, 0x93, 0x01, 0x21, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x0b, 0x02, 0x0e, 0x12, 0x04, 0x94, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02,
    0x0e, 0x01, 0x12, 0x04, 0x94, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0e,
    0x02, 0x12, 0x04, 0x94, 0x01, 0x21, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x0f, 0x12,
    0x04, 0x95, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0f, 0x01, 0x12, 0x04,
    0x95, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x0f, 0x02, 0x12, 0x04, 0x95,
    0x01, 0x21, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x10, 0x12, 0x04, 0x96, 0x01, 0x08,
    0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x10, 0x01, 0x12, 0x04, 0x96, 0x01, 0x08, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x10, 0x02, 0x12, 0x04, 0x96, 0x01, 0x2a, 0x2f, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x11, 0x12, 0x04, 0x97, 0x01, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x11, 0x01, 0x12, 0x04, 0x97, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x11, 0x02, 0x12, 0x04, 0x97, 0x01, 0x2a, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x0b, 0x02, 0x12, 0x12, 0x04, 0x98, 0x01, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02,
    0x12, 0x01, 0x12, 0x04, 0x98, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x12,
    0x02, 0x12, 0x04, 0x98, 0x01, 0x2b, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x13, 0x12,
    0x04, 0x99, 0x01, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x13, 0x01, 0x12, 0x04,
    0x99, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x13, 0x02, 0x12, 0x04, 0x99,
    0x01, 0x2b, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x14, 0x12, 0x04, 0x9a, 0x01, 0x08,
    0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x14, 0x01, 0x12, 0x04, 0x9a, 0x01, 0x08, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0b, 0x02, 0x14, 0x02, 0x12, 0x04, 0x9a, 0x01, 0x2b, 0x32, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0b, 0x02, 0x15, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x34, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0b, 0x02, 0x15, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0b, 0x02, 0x15, 0x02, 0x12, 0x04, 0x9b, 0x01, 0x2c, 0x33, 0x0a, 0x0c, 0x0a, 0x02, 0x05,
    0x0c, 0x12, 0x06, 0x9e, 0x01, 0x00, 0xa6, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x0c, 0x01,
    0x12, 0x04, 0x9e, 0x01, 0x05, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0c, 0x02, 0x00, 0x12, 0x04,
    0x9f, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9f,
    0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x00, 0x02, 0x12, 0x04, 0x9f, 0x01,
    0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0c, 0x02, 0x01, 0x12, 0x04, 0xa0, 0x01, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa0, 0x01, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa0, 0x01, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x0c, 0x02, 0x02, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0c, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x0c, 0x02, 0x02, 0x02, 0x12, 0x04, 0xa1, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0c,
    0x02, 0x03, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x03, 0x02,
    0x12, 0x04, 0xa2, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0c, 0x02, 0x04, 0x12, 0x04,
    0xa3, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa3,
    0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x04, 0x02, 0x12, 0x04, 0xa3, 0x01,
    0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0c, 0x02, 0x05, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x0c, 0x02, 0x05, 0x02, 0x12, 0x04, 0xa4, 0x01, 0x25, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x0c, 0x02, 0x06, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0c, 0x02, 0x06, 0x01, 0x12, 0x04, 0xa5, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x0c, 0x02, 0x06, 0x02, 0x12, 0x04, 0xa5, 0x01, 0x28, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x0d,
    0x12, 0x06, 0xa8, 0x01, 0x00, 0xac, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x0d, 0x01, 0x12,
    0x04, 0xa8, 0x01, 0x05, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0d, 0x02, 0x00, 0x12, 0x04, 0xa9,
    0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa9, 0x01,
    0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0d, 0x02, 0x00, 0x02, 0x12, 0x04, 0xa9, 0x01, 0x20,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0d, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x0d, 0x02, 0x01, 0x02, 0x12, 0x04, 0xaa, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x05, 0x0d, 0x02, 0x02, 0x12, 0x04, 0xab, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xab, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0d,
    0x02, 0x02, 0x02, 0x12, 0x04, 0xab, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x0e, 0x12,
    0x06, 0xae, 0x01, 0x00, 0xb1, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x0e, 0x01, 0x12, 0x04,
    0xae, 0x01, 0x05, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x01,
    0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x01, 0x08,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0e, 0x02, 0x00, 0x02, 0x12, 0x04, 0xaf, 0x01, 0x1e, 0x1f,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0e, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0e, 0x02, 0x01, 0x02, 0x12, 0x04, 0xb0, 0x01, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x02,
    0x05, 0x0f, 0x12, 0x06, 0xb3, 0x01, 0x00, 0xb7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x0f,
    0x01, 0x12, 0x04, 0xb3, 0x01, 0x05, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0f, 0x02, 0x00, 0x12,
    0x04, 0xb4, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb4, 0x01, 0x08, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0f, 0x02, 0x00, 0x02, 0x12, 0x04, 0xb4,
    0x01, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x0f, 0x02, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x08,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x0f, 0x02, 0x01, 0x02, 0x12, 0x04, 0xb5, 0x01, 0x2a, 0x2b, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x0f, 0x02, 0x02, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x0f, 0x02, 0x02, 0x02, 0x12, 0x04, 0xb6, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x05,
    0x10, 0x12, 0x06, 0xb9, 0x01, 0x00, 0xbd, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x10, 0x01,
    0x12, 0x04, 0xb9, 0x01, 0x05, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x10, 0x02, 0x00, 0x12, 0x04,
    0xba, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xba,
    0x01, 0x08, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x10, 0x02, 0x00, 0x02, 0x12, 0x04, 0xba, 0x01,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x10, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x10, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x10, 0x02, 0x01, 0x02, 0x12, 0x04, 0xbb, 0x01, 0x1d, 0x1e, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x10, 0x02, 0x02, 0x12, 0x04, 0xbc, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x10, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x01, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x10, 0x02, 0x02, 0x02, 0x12, 0x04, 0xbc, 0x01, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x11,
    0x12, 0x06, 0xbf, 0x01, 0x00, 0xc6, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x11, 0x01, 0x12,
    0x04, 0xbf, 0x01, 0x05, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x11, 0x02, 0x00, 0x12, 0x04, 0xc0,
    0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x01,
    0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x00, 0x02, 0x12, 0x04, 0xc0, 0x01, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x11, 0x02, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x08, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x08, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x11, 0x02, 0x01, 0x02, 0x12, 0x04, 0xc1, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a,
    0x04, 0x05, 0x11, 0x02, 0x02, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x11, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11,
    0x02, 0x02, 0x02, 0x12, 0x04, 0xc2, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x11, 0x02,
    0x03, 0x12, 0x04, 0xc3, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xc3, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x03, 0x02, 0x12,
    0x04, 0xc3, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x11, 0x02, 0x04, 0x12, 0x04, 0xc4,
    0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc4, 0x01,
    0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x04, 0x02, 0x12, 0x04, 0xc4, 0x01, 0x26,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x11, 0x02, 0x05, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x11, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x11, 0x02, 0x05, 0x02, 0x12, 0x04, 0xc5, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a,
    0x02, 0x05, 0x12, 0x12, 0x06, 0xc8, 0x01, 0x00, 0xdc, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05,
    0x12, 0x01, 0x12, 0x04, 0xc8, 0x01, 0x05, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x00,
    0x12, 0x04, 0xc9, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc9, 0x01, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x00, 0x02, 0x12, 0x04,
    0xc9, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x01, 0x12, 0x04, 0xca, 0x01,
    0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x01, 0x01, 0x12, 0x04, 0xca, 0x01, 0x08,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x01, 0x02, 0x12, 0x04, 0xca, 0x01, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x02, 0x12, 0x04, 0xcb, 0x01, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x12, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcb, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x12, 0x02, 0x02, 0x02, 0x12, 0x04, 0xcb, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x05, 0x12, 0x02, 0x03, 0x12, 0x04, 0xcc, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12,
    0x02, 0x03, 0x01, 0x12, 0x04, 0xcc, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02,
    0x03, 0x02, 0x12, 0x04, 0xcc, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x04,
    0x12, 0x04, 0xcd, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xcd, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x04, 0x02, 0x12, 0x04,
    0xcd, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x05, 0x12, 0x04, 0xce, 0x01,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x05, 0x01, 0x12, 0x04, 0xce, 0x01, 0x08,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x05, 0x02, 0x12, 0x04, 0xce, 0x01, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x06, 0x12, 0x04, 0xcf, 0x01, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x12, 0x02, 0x06, 0x01, 0x12, 0x04, 0xcf, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x12, 0x02, 0x06, 0x02, 0x12, 0x04, 0xcf, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04,
    0x05, 0x12, 0x02, 0x07, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12,
    0x02, 0x07, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02,
    0x07, 0x02, 0x12, 0x04, 0xd0, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x08,
    0x12, 0x04, 0xd1, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x08, 0x01, 0x12,
    0x04, 0xd1, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x08, 0x02, 0x12, 0x04,
    0xd1, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x09, 0x12, 0x04, 0xd2, 0x01,
    0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd2, 0x01, 0x08,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x09, 0x02, 0x12, 0x04, 0xd2, 0x01, 0x28, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x0a, 0x12, 0x04, 0xd3, 0x01, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x12, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xd3, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x12, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xd3, 0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04,
    0x05, 0x12, 0x02, 0x0b, 0x12, 0x04, 0xd4, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12,
    0x02, 0x0b, 0x01, 0x12, 0x04, 0xd4, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02,
    0x0b, 0x02, 0x12, 0x04, 0xd4, 0x01, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x0c,
    0x12, 0x04, 0xd5, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x0c, 0x01, 0x12,
    0x04, 0xd5, 0x01, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x0c, 0x02, 0x12, 0x04,
    0xd5, 0x01, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x0d, 0x12, 0x04, 0xd6, 0x01,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xd6, 0x01, 0x08,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xd6, 0x01, 0x22, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x0e, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x12, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xd7, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x12, 0x02, 0x0e, 0x02, 0x12, 0x04, 0xd7, 0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04,
    0x05, 0x12, 0x02, 0x0f, 0x12, 0x04, 0xd8, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12,
    0x02, 0x0f, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02,
    0x0f, 0x02, 0x12, 0x04, 0xd8, 0x01, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x10,
    0x12, 0x04, 0xd9, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x10, 0x01, 0x12,
    0x04, 0xd9, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x10, 0x02, 0x12, 0x04,
    0xd9, 0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x11, 0x12, 0x04, 0xda, 0x01,
    0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x11, 0x01, 0x12, 0x04, 0xda, 0x01, 0x08,
    0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x12, 0x02, 0x11, 0x02, 0x12, 0x04, 0xda, 0x01, 0x27, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x12, 0x02, 0x12, 0x12, 0x04, 0xdb, 0x01, 0x08, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x12, 0x02, 0x12, 0x01, 0x12, 0x04, 0xdb, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x12, 0x02, 0x12, 0x02, 0x12, 0x04, 0xdb, 0x01, 0x26, 0x28, 0x0a, 0x0c, 0x0a, 0x02,
    0x05, 0x13, 0x12, 0x06, 0xde, 0x01, 0x00, 0xe7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x13,
    0x01, 0x12, 0x04, 0xde, 0x01, 0x05, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x00, 0x12,
    0x04, 0xdf, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xdf, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x00, 0x02, 0x12, 0x04, 0xdf,
    0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x01, 0x12, 0x04, 0xe0, 0x01, 0x08,
    0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe0, 0x01, 0x08, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x01, 0x02, 0x12, 0x04, 0xe0, 0x01, 0x28, 0x29, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x02, 0x12, 0x04, 0xe1, 0x01, 0x08, 0x33, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x13, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x13, 0x02, 0x02, 0x02, 0x12, 0x04, 0xe1, 0x01, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x13, 0x02, 0x03, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x03,
    0x02, 0x12, 0x04, 0xe2, 0x01, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x04, 0x12,
    0x04, 0xe3, 0x01, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xe3, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x04, 0x02, 0x12, 0x04, 0xe3,
    0x01, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x05, 0x12, 0x04, 0xe4, 0x01, 0x08,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe4, 0x01, 0x08, 0x30,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x05, 0x02, 0x12, 0x04, 0xe4, 0x01, 0x33, 0x34, 0x0a,
    0x0c, 0x0a, 0x04, 0x05, 0x13, 0x02, 0x06, 0x12, 0x04, 0xe5, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x13, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe5, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x13, 0x02, 0x06, 0x02, 0x12, 0x04, 0xe5, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05,
    0x13, 0x02, 0x07, 0x12, 0x04, 0xe6, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02,
    0x07, 0x01, 0x12, 0x04, 0xe6, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x13, 0x02, 0x07,
    0x02, 0x12, 0x04, 0xe6, 0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x14, 0x12, 0x06, 0xe9,
    0x01, 0x00, 0xfd, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x14, 0x01, 0x12, 0x04, 0xe9, 0x01,
    0x05, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x00, 0x12, 0x04, 0xea, 0x01, 0x08, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0xea, 0x01, 0x08, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x00, 0x02, 0x12, 0x04, 0xea, 0x01, 0x1a, 0x1b, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x14, 0x02, 0x01, 0x12, 0x04, 0xeb, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x14, 0x02, 0x01, 0x01, 0x12, 0x04, 0xeb, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x14, 0x02, 0x01, 0x02, 0x12, 0x04, 0xeb, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14,
    0x02, 0x02, 0x12, 0x04, 0xec, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xec, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x02, 0x02,
    0x12, 0x04, 0xec, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x03, 0x12, 0x04,
    0xed, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x03, 0x01, 0x12, 0x04, 0xed,
    0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x03, 0x02, 0x12, 0x04, 0xed, 0x01,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x04, 0x12, 0x04, 0xee, 0x01, 0x08, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x04, 0x01, 0x12, 0x04, 0xee, 0x01, 0x08, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x04, 0x02, 0x12, 0x04, 0xee, 0x01, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x14, 0x02, 0x05, 0x12, 0x04, 0xef, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x14, 0x02, 0x05, 0x01, 0x12, 0x04, 0xef, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x14, 0x02, 0x05, 0x02, 0x12, 0x04, 0xef, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14,
    0x02, 0x06, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x06,
    0x01, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x06, 0x02,
    0x12, 0x04, 0xf0, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x07, 0x12, 0x04,
    0xf1, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf1,
    0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x07, 0x02, 0x12, 0x04, 0xf1, 0x01,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x08, 0x12, 0x04, 0xf2, 0x01, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x08, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x08, 0x02, 0x12, 0x04, 0xf2, 0x01, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x14, 0x02, 0x09, 0x12, 0x04, 0xf3, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x14, 0x02, 0x09, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x14, 0x02, 0x09, 0x02, 0x12, 0x04, 0xf3, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14,
    0x02, 0x0a, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0a,
    0x01, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0a, 0x02,
    0x12, 0x04, 0xf4, 0x01, 0x26, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x0b, 0x12, 0x04,
    0xf5, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xf5,
    0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0b, 0x02, 0x12, 0x04, 0xf5, 0x01,
    0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x0c, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0c, 0x02, 0x12, 0x04, 0xf6, 0x01, 0x24, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x14, 0x02, 0x0d, 0x12, 0x04, 0xf7, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x14, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xf7, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x14, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xf7, 0x01, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14,
    0x02, 0x0e, 0x12, 0x04, 0xf8, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0e,
    0x01, 0x12, 0x04, 0xf8, 0x01, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0e, 0x02,
    0x12, 0x04, 0xf8, 0x01, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x0f, 0x12, 0x04,
    0xf9, 0x01, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xf9,
    0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x0f, 0x02, 0x12, 0x04, 0xf9, 0x01,
    0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14, 0x02, 0x10, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x31,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x10, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x2b, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x10, 0x02, 0x12, 0x04, 0xfa, 0x01, 0x2e, 0x30, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x14, 0x02, 0x11, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x14, 0x02, 0x11, 0x01, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x14, 0x02, 0x11, 0x02, 0x12, 0x04, 0xfb, 0x01, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x14,
    0x02, 0x12, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x12,
    0x01, 0x12, 0x04, 0xfc, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x14, 0x02, 0x12, 0x02,
    0x12, 0x04, 0xfc, 0x01, 0x2b, 0x2d, 0x0a, 0x0c, 0x0a, 0x02, 0x05, 0x15, 0x12, 0x06, 0xff, 0x01,
    0x00, 0x83, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x05, 0x15, 0x01, 0x12, 0x04, 0xff, 0x01, 0x05,
    0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x15, 0x02, 0x00, 0x12, 0x04, 0x80, 0x02, 0x08, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0x80, 0x02, 0x08, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x05, 0x15, 0x02, 0x00, 0x02, 0x12, 0x04, 0x80, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x04, 0x05, 0x15, 0x02, 0x01, 0x12, 0x04, 0x81, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x15, 0x02, 0x01, 0x01, 0x12, 0x04, 0x81, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x15,
    0x02, 0x01, 0x02, 0x12, 0x04, 0x81, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x05, 0x15, 0x02,
    0x02, 0x12, 0x04, 0x82, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x15, 0x02, 0x02, 0x01,
    0x12, 0x04, 0x82, 0x02, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x15, 0x02, 0x02, 0x02, 0x12,
    0x04, 0x82, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x06, 0x85, 0x02, 0x00,
    0x88, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x04, 0x85, 0x02, 0x08, 0x1d,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x86, 0x02, 0x08, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x86, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x86, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x86, 0x02, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x86, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x01, 0x12, 0x04, 0x87, 0x02, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x87, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x87, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x87, 0x02, 0x18, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04,
    0x87, 0x02, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x06, 0x8a, 0x02, 0x00, 0x8d,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x08, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x04, 0x8b, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8b, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8b, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b, 0x02, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02,
    0x01, 0x12, 0x04, 0x8c, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x8c, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x8c, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x8c, 0x02, 0x18, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c,
    0x02, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x06, 0x8f, 0x02, 0x00, 0x91, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x04, 0x8f, 0x02, 0x08, 0x25, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x04, 0x90, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x90, 0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x06,
    0x93, 0x02, 0x00, 0x95, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x04, 0x93,
    0x02, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x04, 0x94, 0x02, 0x08,
    0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0x94, 0x02, 0x11, 0x2f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x02, 0x30, 0x34, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x02, 0x37, 0x38, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x04, 0x12, 0x06, 0x97, 0x02, 0x00, 0x99, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x04, 0x01, 0x12, 0x04, 0x97, 0x02, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00,
    0x12, 0x04, 0x98, 0x02, 0x08, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x98, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x98, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0x98,
    0x02, 0x17, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0x98, 0x02,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x06, 0x9b, 0x02, 0x00, 0x9d, 0x02, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x04, 0x9b, 0x02, 0x08, 0x1b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x04, 0x9c, 0x02, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9c, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x00, 0x06, 0x12, 0x04, 0x9c, 0x02, 0x11, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x9c, 0x02, 0x30, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x9c, 0x02, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x06, 0x9f,
    0x02, 0x00, 0xa2, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x04, 0x9f, 0x02,
    0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x04, 0xa0, 0x02, 0x08, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa0, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa0, 0x02, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x06, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x08, 0x4e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xa1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x01, 0x06, 0x12, 0x04, 0xa1, 0x02, 0x11, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xa1, 0x02, 0x21, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xa1, 0x02, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x08, 0x12,
    0x04, 0xa1, 0x02, 0x2d, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x07, 0x12, 0x04,
    0xa1, 0x02, 0x38, 0x4c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x06, 0xa4, 0x02, 0x00, 0xac,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x08, 0x22, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x07, 0x04, 0x00, 0x12, 0x06, 0xa5, 0x02, 0x08, 0xa8, 0x02, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x04, 0x00, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x0d, 0x21, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xa6, 0x02, 0x10, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6, 0x02, 0x10, 0x19, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xa6, 0x02, 0x1c, 0x1d,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x10, 0x1b,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x10,
    0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa7, 0x02,
    0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x63,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x06, 0x12, 0x04, 0xaa, 0x02, 0x11, 0x41, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaa, 0x02, 0x42, 0x48, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaa, 0x02, 0x4b, 0x4c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x00, 0x08, 0x12, 0x04, 0xaa, 0x02, 0x4d, 0x62, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x00, 0x07, 0x12, 0x04, 0xaa, 0x02, 0x58, 0x61, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x07,
    0x02, 0x01, 0x12, 0x04, 0xab, 0x02, 0x08, 0x4e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xab, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xab, 0x02, 0x11, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xab, 0x02, 0x21, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xab, 0x02, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x08, 0x12, 0x04, 0xab,
    0x02, 0x2d, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x07, 0x12, 0x04, 0xab, 0x02,
    0x38, 0x4c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0xae, 0x02, 0x00, 0xaf, 0x02, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x04, 0xae, 0x02, 0x08, 0x15, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x09, 0x12, 0x06, 0xb1, 0x02, 0x00, 0xb6, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x09, 0x01, 0x12, 0x04, 0xb1, 0x02, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00,
    0x12, 0x04, 0xb2, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xb2, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb2,
    0x02, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb2, 0x02,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x02, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb3, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb3, 0x02, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb3, 0x02, 0x18, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb3, 0x02, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x09, 0x02, 0x02, 0x12, 0x04, 0xb4, 0x02, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xb4, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xb4, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xb4, 0x02, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xb4, 0x02, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x03, 0x12, 0x04,
    0xb5, 0x02, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb5,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb5, 0x02,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb5, 0x02, 0x18,
    0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb5, 0x02, 0x2d, 0x2e,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xb8, 0x02, 0x00, 0xbe, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xb8, 0x02, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0a, 0x02, 0x00, 0x12, 0x04, 0xb9, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xb9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xb9, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xb9, 0x02, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xb9, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12, 0x04, 0xba,
    0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xba, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xba, 0x02, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xba, 0x02, 0x18, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xba, 0x02, 0x21, 0x22, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x02, 0x12, 0x04, 0xbb, 0x02, 0x08, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbb, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbb, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x02, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xbb, 0x02, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02,
    0x03, 0x12, 0x04, 0xbc, 0x02, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xbc, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x05, 0x12,
    0x04, 0xbc, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xbc, 0x02, 0x18, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xbc,
    0x02, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x04, 0x12, 0x04, 0xbd, 0x02, 0x08,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xbd, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x04, 0xbd, 0x02, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0xbd, 0x02, 0x18, 0x30, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0xbd, 0x02, 0x33, 0x34, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x0b, 0x12, 0x06, 0xc0, 0x02, 0x00, 0xc5, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x0b, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00,
    0x12, 0x04, 0xc1, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xc1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xc1, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc1,
    0x02, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc1, 0x02,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0xc2, 0x02, 0x08, 0x2d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc2, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc2, 0x02, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc2, 0x02, 0x16, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc2, 0x02, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0b, 0x02, 0x02, 0x12, 0x04, 0xc3, 0x02, 0x08, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xc3, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xc3, 0x02, 0x17, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xc3, 0x02, 0x35, 0x36, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x03, 0x12, 0x04,
    0xc4, 0x02, 0x08, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc4,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc4, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc4, 0x02, 0x17,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc4, 0x02, 0x34, 0x35,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xc7, 0x02, 0x00, 0xd4, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xc7, 0x02, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x00, 0x12, 0x04, 0xc8, 0x02, 0x08, 0x5c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xc8, 0x02, 0x11, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc8, 0x02, 0x2b, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc8, 0x02, 0x35, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x08, 0x12, 0x04,
    0xc8, 0x02, 0x37, 0x5b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x07, 0x12, 0x04, 0xc8,
    0x02, 0x42, 0x5a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12, 0x04, 0xc9, 0x02, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc9, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc9, 0x02, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc9, 0x02, 0x18, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc9, 0x02, 0x2f, 0x30, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0c, 0x02, 0x02, 0x12, 0x04, 0xca, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xca, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xca, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xca, 0x02, 0x18, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xca, 0x02, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12,
    0x04, 0xcb, 0x02, 0x08, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xcb, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0xcb,
    0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0xcb, 0x02,
    0x18, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0xcb, 0x02, 0x36,
    0x37, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x04, 0x12, 0x04, 0xcc, 0x02, 0x08, 0x3a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcc, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x05, 0x12, 0x04, 0xcc, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcc, 0x02, 0x18, 0x35, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x04, 0x03, 0x12, 0x04, 0xcc, 0x02, 0x38, 0x39, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x05, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x05, 0x04, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xcd, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xcd, 0x02, 0x17, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xcd, 0x02, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x08, 0x12, 0x04,
    0xcd, 0x02, 0x30, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x07, 0x12, 0x04, 0xcd,
    0x02, 0x3b, 0x3d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x06, 0x12, 0x04, 0xce, 0x02, 0x08,
    0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x04, 0x12, 0x04, 0xce, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x05, 0x12, 0x04, 0xce, 0x02, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x01, 0x12, 0x04, 0xce, 0x02, 0x16, 0x2e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x06, 0x03, 0x12, 0x04, 0xce, 0x02, 0x31, 0x32, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x06, 0x08, 0x12, 0x04, 0xce, 0x02, 0x33, 0x43, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x06, 0x07, 0x12, 0x04, 0xce, 0x02, 0x3e, 0x42, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x07, 0x12, 0x04, 0xcf, 0x02, 0x08, 0x47, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x07, 0x04, 0x12, 0x04, 0xcf, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x07,
    0x05, 0x12, 0x04, 0xcf, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x07, 0x01,
    0x12, 0x04, 0xcf, 0x02, 0x16, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xcf, 0x02, 0x33, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x07, 0x08, 0x12, 0x04,
    0xcf, 0x02, 0x35, 0x46, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x07, 0x07, 0x12, 0x04, 0xcf,
    0x02, 0x40, 0x45, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x08, 0x12, 0x04, 0xd0, 0x02, 0x08,
    0x42, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x08, 0x04, 0x12, 0x04, 0xd0, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x08, 0x05, 0x12, 0x04, 0xd0, 0x02, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x08, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x16, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x08, 0x03, 0x12, 0x04, 0xd0, 0x02, 0x2f, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x08, 0x08, 0x12, 0x04, 0xd0, 0x02, 0x31, 0x41, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x08, 0x07, 0x12, 0x04, 0xd0, 0x02, 0x3c, 0x40, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x09, 0x12, 0x04, 0xd1, 0x02, 0x08, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x09, 0x04, 0x12, 0x04, 0xd1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x09,
    0x05, 0x12, 0x04, 0xd1, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xd1, 0x02, 0x16, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xd1, 0x02, 0x2f, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x09, 0x08, 0x12, 0x04,
    0xd1, 0x02, 0x32, 0x42, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x09, 0x07, 0x12, 0x04, 0xd1,
    0x02, 0x3d, 0x41, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x0a, 0x12, 0x04, 0xd2, 0x02, 0x08,
    0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xd2, 0x02, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xd2, 0x02, 0x16, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xd2, 0x02, 0x2f, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x0a, 0x08, 0x12, 0x04, 0xd2, 0x02, 0x32, 0x42, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x0a, 0x07, 0x12, 0x04, 0xd2, 0x02, 0x3d, 0x41, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x0b, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x0b, 0x04, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0b,
    0x05, 0x12, 0x04, 0xd3, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0b, 0x01,
    0x12, 0x04, 0xd3, 0x02, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0b, 0x03, 0x12,
    0x04, 0xd3, 0x02, 0x28, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0b, 0x08, 0x12, 0x04,
    0xd3, 0x02, 0x2b, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x0b, 0x07, 0x12, 0x04, 0xd3,
    0x02, 0x36, 0x37, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0xd6, 0x02, 0x00, 0xde, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04, 0xd6, 0x02, 0x08, 0x1e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x3a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd7, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x16, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd7, 0x02, 0x38, 0x39, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01,
    0x12, 0x04, 0xd8, 0x02, 0x08, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xd8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xd8, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8,
    0x02, 0x16, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x02,
    0x3c, 0x3d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x02, 0x12, 0x04, 0xd9, 0x02, 0x08, 0x37,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd9, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd9, 0x02, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x02, 0x16, 0x32, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd9, 0x02, 0x35, 0x36, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0d, 0x02, 0x03, 0x12, 0x04, 0xda, 0x02, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xda, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x03, 0x05, 0x12, 0x04, 0xda, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xda, 0x02, 0x16, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xda, 0x02, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x04, 0x12, 0x04,
    0xdb, 0x02, 0x08, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x04, 0x12, 0x04, 0xdb,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x05, 0x12, 0x04, 0xdb, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x01, 0x12, 0x04, 0xdb, 0x02, 0x17,
    0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x03, 0x12, 0x04, 0xdb, 0x02, 0x33, 0x34,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x05, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x38, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x04, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x05, 0x05, 0x12, 0x04, 0xdc, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x05, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x16, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x05, 0x03, 0x12, 0x04, 0xdc, 0x02, 0x36, 0x37, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d,
    0x02, 0x06, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06,
    0x04, 0x12, 0x04, 0xdd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xdd, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xdd, 0x02, 0x16, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xdd, 0x02, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0xe0, 0x02, 0x00, 0xe5,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0xe0, 0x02, 0x08, 0x19, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe1, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe1, 0x02, 0x16, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe1, 0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02,
    0x01, 0x12, 0x04, 0xe2, 0x02, 0x08, 0x61, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xe2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xe2, 0x02, 0x11, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xe2, 0x02, 0x24, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe2,
    0x02, 0x3b, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x08, 0x12, 0x04, 0xe2, 0x02,
    0x3d, 0x60, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x07, 0x12, 0x04, 0xe2, 0x02, 0x48,
    0x5f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x02, 0x12, 0x04, 0xe3, 0x02, 0x08, 0x61, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe3, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x06, 0x12, 0x04, 0xe3, 0x02, 0x11, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe3, 0x02, 0x24, 0x38, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe3, 0x02, 0x3b, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x02, 0x08, 0x12, 0x04, 0xe3, 0x02, 0x3d, 0x60, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x02, 0x07, 0x12, 0x04, 0xe3, 0x02, 0x48, 0x5f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0e, 0x02,
    0x03, 0x12, 0x04, 0xe4, 0x02, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xe4, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xe4, 0x02, 0x11, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xe4, 0x02, 0x23, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe4,
    0x02, 0x3b, 0x3c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06, 0xe7, 0x02, 0x00, 0xeb, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xe7, 0x02, 0x08, 0x1b, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe8, 0x02, 0x16, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe8, 0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x01,
    0x12, 0x04, 0xe9, 0x02, 0x08, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xe9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xe9, 0x02, 0x11, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe9,
    0x02, 0x24, 0x3a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe9, 0x02,
    0x3d, 0x3e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x02, 0x12, 0x04, 0xea, 0x02, 0x08, 0x3f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xea, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x06, 0x12, 0x04, 0xea, 0x02, 0x11, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xea, 0x02, 0x24, 0x3a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xea, 0x02, 0x3d, 0x3e, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x10, 0x12, 0x06, 0xed, 0x02, 0x00, 0xf1, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10,
    0x01, 0x12, 0x04, 0xed, 0x02, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12,
    0x04, 0xee, 0x02, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xee, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x06, 0x12, 0x04, 0xee,
    0x02, 0x11, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xee, 0x02,
    0x24, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04, 0xee, 0x02, 0x2d,
    0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x01, 0x12, 0x04, 0xef, 0x02, 0x08, 0x45, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x04, 0x12, 0x04, 0xef, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x06, 0x12, 0x04, 0xef, 0x02, 0x11, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x01, 0x01, 0x12, 0x04, 0xef, 0x02, 0x29, 0x40, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x01, 0x03, 0x12, 0x04, 0xef, 0x02, 0x43, 0x44, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x10, 0x02, 0x02, 0x12, 0x04, 0xf0, 0x02, 0x08, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xf0, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02,
    0x06, 0x12, 0x04, 0xf0, 0x02, 0x11, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xf0, 0x02, 0x27, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xf0, 0x02, 0x3f, 0x40, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xf3, 0x02, 0x00,
    0xf4, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xf3, 0x02, 0x08, 0x1f,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xf6, 0x02, 0x00, 0xfc, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04, 0xf6, 0x02, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x12, 0x02, 0x00, 0x12, 0x04, 0xf7, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xf7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xf7, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xf7, 0x02, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xf7, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x01, 0x12, 0x04, 0xf8,
    0x02, 0x08, 0x52, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf8, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x06, 0x12, 0x04, 0xf8, 0x02, 0x11,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf8, 0x02, 0x24, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf8, 0x02, 0x2c, 0x2d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x08, 0x12, 0x04, 0xf8, 0x02, 0x2e, 0x51, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x07, 0x12, 0x04, 0xf8, 0x02, 0x39, 0x50, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x12, 0x02, 0x02, 0x12, 0x04, 0xf9, 0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xf9, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xf9, 0x02, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xf9, 0x02, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x03, 0x12,
    0x04, 0xfa, 0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xfa, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x05, 0x12, 0x04, 0xfa,
    0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x01, 0x12, 0x04, 0xfa, 0x02,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x03, 0x12, 0x04, 0xfa, 0x02, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x04, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x04, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x05, 0x12, 0x04, 0xfb, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x04, 0x01, 0x12, 0x04, 0xfb, 0x02, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x04, 0x03, 0x12, 0x04, 0xfb, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x13, 0x12, 0x06, 0xfe, 0x02, 0x00, 0xff, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01,
    0x12, 0x04, 0xfe, 0x02, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0x81, 0x03,
    0x00, 0x87, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0x81, 0x03, 0x08,
    0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0x82, 0x03, 0x08, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x00, 0x05, 0x12, 0x04, 0x82, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x03, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x03, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x14, 0x02, 0x01, 0x12, 0x04, 0x83, 0x03, 0x08, 0x52, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x83, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01,
    0x06, 0x12, 0x04, 0x83, 0x03, 0x11, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x83, 0x03, 0x24, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x83, 0x03, 0x2c, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x08, 0x12, 0x04,
    0x83, 0x03, 0x2e, 0x51, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x07, 0x12, 0x04, 0x83,
    0x03, 0x39, 0x50, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x02, 0x12, 0x04, 0x84, 0x03, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x04, 0x12, 0x04, 0x84, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x05, 0x12, 0x04, 0x84, 0x03, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x01, 0x12, 0x04, 0x84, 0x03, 0x17, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x03, 0x12, 0x04, 0x84, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x03, 0x12, 0x04, 0x85, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x03, 0x04, 0x12, 0x04, 0x85, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x03, 0x05, 0x12, 0x04, 0x85, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x03, 0x01, 0x12, 0x04, 0x85, 0x03, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03,
    0x03, 0x12, 0x04, 0x85, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x04, 0x12,
    0x04, 0x86, 0x03, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x04, 0x12, 0x04,
    0x86, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x05, 0x12, 0x04, 0x86,
    0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x01, 0x12, 0x04, 0x86, 0x03,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x03, 0x12, 0x04, 0x86, 0x03, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0x89, 0x03, 0x00, 0x8a, 0x03, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0x89, 0x03, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x16, 0x12, 0x06, 0x8c, 0x03, 0x00, 0x8f, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16,
    0x01, 0x12, 0x04, 0x8c, 0x03, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x00, 0x12,
    0x04, 0x8d, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x8d, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8d,
    0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x03,
    0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x03, 0x25,
    0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x03, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8e, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8e, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8e, 0x03, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8e, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x17, 0x12, 0x06, 0x91, 0x03, 0x00, 0x97, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01,
    0x12, 0x04, 0x91, 0x03, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04,
    0x92, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0x92,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x05, 0x12, 0x04, 0x92, 0x03,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0x92, 0x03, 0x18,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x03, 0x12, 0x04, 0x92, 0x03, 0x25, 0x26,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x01, 0x12, 0x04, 0x93, 0x03, 0x08, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04, 0x12, 0x04, 0x93, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x01, 0x05, 0x12, 0x04, 0x93, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04, 0x93, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0x93, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17,
    0x02, 0x02, 0x12, 0x04, 0x94, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x94, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x94, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x94, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x94, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x03, 0x12, 0x04, 0x95, 0x03,
    0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x04, 0x12, 0x04, 0x95, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x05, 0x12, 0x04, 0x95, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x01, 0x12, 0x04, 0x95, 0x03, 0x17, 0x19, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x03, 0x12, 0x04, 0x95, 0x03, 0x1c, 0x1d, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x04, 0x12, 0x04, 0x96, 0x03, 0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x04, 0x04, 0x12, 0x04, 0x96, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x04, 0x05, 0x12, 0x04, 0x96, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x96, 0x03, 0x17, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x96, 0x03, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06,
    0x99, 0x03, 0x00, 0x9c, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0x99,
    0x03, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0x9a, 0x03, 0x08,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9a, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9a, 0x03, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x18, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9a, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x03, 0x08, 0x5d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9b, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x01, 0x06, 0x12, 0x04, 0x9b, 0x03, 0x11, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x9b, 0x03, 0x2d, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x9b, 0x03, 0x39, 0x3a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x08,
    0x12, 0x04, 0x9b, 0x03, 0x3b, 0x5c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x07, 0x12,
    0x04, 0x9b, 0x03, 0x46, 0x5b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0x9e, 0x03, 0x00,
    0xa1, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0x9e, 0x03, 0x08, 0x1a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0x9f, 0x03, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9f, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9f, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9f, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9f, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19,
    0x02, 0x01, 0x12, 0x04, 0xa0, 0x03, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xa0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xa0, 0x03, 0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xa0, 0x03, 0x25, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xa0, 0x03, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x08, 0x12, 0x04, 0xa0,
    0x03, 0x30, 0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x07, 0x12, 0x04, 0xa0, 0x03,
    0x3b, 0x53, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1a, 0x12, 0x06, 0xa3, 0x03, 0x00, 0xa6, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x18, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xa4, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa4, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xa4, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x01, 0x12,
    0x04, 0xa5, 0x03, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa5,
    0x03, 0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa5, 0x03,
    0x25, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa5, 0x03, 0x2e,
    0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x08, 0x12, 0x04, 0xa5, 0x03, 0x30, 0x54,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x07, 0x12, 0x04, 0xa5, 0x03, 0x3b, 0x53, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x1b, 0x12, 0x06, 0xa8, 0x03, 0x00, 0xab, 0x03, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x1b, 0x01, 0x12, 0x04, 0xa8, 0x03, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b,
    0x02, 0x00, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xa9, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa9, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xa9, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x03,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaa, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xaa, 0x03, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaa, 0x03, 0x18, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaa, 0x03, 0x23, 0x24, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xad, 0x03, 0x00, 0xb0, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x1c, 0x01, 0x12, 0x04, 0xad, 0x03, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02,
    0x00, 0x12, 0x04, 0xae, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xae, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xae, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xae, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xae,
    0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x03, 0x08,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaf, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xaf, 0x03, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaf, 0x03, 0x18, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaf, 0x03, 0x23, 0x24, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x1d, 0x12, 0x06, 0xb2, 0x03, 0x00, 0xb6, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x1d, 0x01, 0x12, 0x04, 0xb2, 0x03, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x00,
    0x12, 0x04, 0xb3, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xb3, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb3,
    0x03, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb3, 0x03,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x01, 0x12, 0x04, 0xb4, 0x03, 0x08, 0x2c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb4, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb4, 0x03, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb4, 0x03, 0x18, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb4, 0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1d, 0x02, 0x02, 0x12, 0x04, 0xb5, 0x03, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xb5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xb5, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xb5, 0x03, 0x18, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xb5, 0x03, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1e, 0x12, 0x06, 0xb8, 0x03,
    0x00, 0xbd, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1e, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x08,
    0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12, 0x04, 0xb9, 0x03, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb9, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb9, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb9, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb9, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x01, 0x12, 0x04, 0xba, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xba, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xba, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xba, 0x03, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xba, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x02, 0x12, 0x04, 0xbb,
    0x03, 0x08, 0x5d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbb, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x06, 0x12, 0x04, 0xbb, 0x03, 0x11,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x03, 0x2a, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbb, 0x03, 0x32, 0x33, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x08, 0x12, 0x04, 0xbb, 0x03, 0x34, 0x5c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x07, 0x12, 0x04, 0xbb, 0x03, 0x3f, 0x5b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x03, 0x12, 0x04, 0xbc, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x03, 0x04, 0x12, 0x04, 0xbc, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xbc, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xbc, 0x03, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xbc, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06, 0xbf,
    0x03, 0x00, 0xc1, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1f, 0x01, 0x12, 0x04, 0xbf, 0x03,
    0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x03, 0x08, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc0, 0x03, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x03, 0x17, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc0, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x20, 0x12, 0x06, 0xc3, 0x03, 0x00, 0xc7, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x20,
    0x01, 0x12, 0x04, 0xc3, 0x03, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x00, 0x12,
    0x04, 0xc4, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc4,
    0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc4, 0x03,
    0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc4, 0x03, 0x27,
    0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc5, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc5, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc5, 0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x20, 0x02, 0x02, 0x12, 0x04, 0xc6, 0x03, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xc6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xc6, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xc6, 0x03, 0x17, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xc6, 0x03, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x21, 0x12, 0x06, 0xc9, 0x03, 0x00,
    0xcb, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x21, 0x01, 0x12, 0x04, 0xc9, 0x03, 0x08, 0x14,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x00, 0x12, 0x04, 0xca, 0x03, 0x08, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x04, 0x12, 0x04, 0xca, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x21, 0x02, 0x00, 0x05, 0x12, 0x04, 0xca, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x21, 0x02, 0x00, 0x01, 0x12, 0x04, 0xca, 0x03, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x21, 0x02, 0x00, 0x03, 0x12, 0x04, 0xca, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x22,
    0x12, 0x06, 0xcd, 0x03, 0x00, 0xd1, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x22, 0x01, 0x12,
    0x04, 0xcd, 0x03, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x00, 0x12, 0x04, 0xce,
    0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x04, 0x12, 0x04, 0xce, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x05, 0x12, 0x04, 0xce, 0x03, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x01, 0x12, 0x04, 0xce, 0x03, 0x17, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x03, 0x12, 0x04, 0xce, 0x03, 0x1f, 0x20, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x01, 0x12, 0x04, 0xcf, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcf, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x22, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcf, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcf, 0x03, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xcf, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02,
    0x02, 0x12, 0x04, 0xd0, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xd0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xd0, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd0, 0x03, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd0,
    0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x23, 0x12, 0x06, 0xd3, 0x03, 0x00, 0xd6, 0x03,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xd3, 0x03, 0x08, 0x16, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x23, 0x02, 0x00, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x23, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x23, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd4, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd4, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x01,
    0x12, 0x04, 0xd5, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xd5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xd5, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd5,
    0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd5, 0x03,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x24, 0x12, 0x06, 0xd8, 0x03, 0x00, 0xd9, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24, 0x01, 0x12, 0x04, 0xd8, 0x03, 0x08, 0x16, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x25, 0x12, 0x06, 0xdb, 0x03, 0x00, 0xdd, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x25, 0x01, 0x12, 0x04, 0xdb, 0x03, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x00,
    0x12, 0x04, 0xdc, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xdc, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xdc, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc,
    0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdc, 0x03,
    0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x26, 0x12, 0x06, 0xdf, 0x03, 0x00, 0xe1, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x26, 0x01, 0x12, 0x04, 0xdf, 0x03, 0x08, 0x1a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x26, 0x02, 0x00, 0x12, 0x04, 0xe0, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x26, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xe0, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe0, 0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe0, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x27, 0x12, 0x06, 0xe3,
    0x03, 0x00, 0xea, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x27, 0x01, 0x12, 0x04, 0xe3, 0x03,
    0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x00, 0x12, 0x04, 0xe4, 0x03, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe4, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe4, 0x03, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x27, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe4, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x27, 0x02, 0x01, 0x12, 0x04, 0xe5, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xe5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xe5, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xe5, 0x03, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xe5, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x02, 0x12, 0x04,
    0xe6, 0x03, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe6,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe6, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x03, 0x17,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe6, 0x03, 0x20, 0x21,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x03, 0x08, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x27, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe7, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x27, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe7, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x27, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe7, 0x03, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x27, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe7, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27,
    0x02, 0x04, 0x12, 0x04, 0xe8, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xe8, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xe8, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xe8, 0x03, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xe8, 0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x03,
    0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe9, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x05, 0x05, 0x12, 0x04, 0xe9, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe9, 0x03, 0x17, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe9, 0x03, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xec, 0x03, 0x00, 0xef, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x28, 0x01, 0x12, 0x04, 0xec, 0x03, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02,
    0x00, 0x12, 0x04, 0xed, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xed, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xed, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xed, 0x03, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x03, 0x12, 0x04, 0xed,
    0x03, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x01, 0x12, 0x04, 0xee, 0x03, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x05, 0x12, 0x04, 0xee, 0x03, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x03, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x03, 0x12, 0x04, 0xee, 0x03, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x29, 0x12, 0x06, 0xf1, 0x03, 0x00, 0xf3, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x29, 0x01, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x00,
    0x12, 0x04, 0xf2, 0x03, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xf2, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xf2, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2,
    0x03, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x03,
    0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06, 0xf5, 0x03, 0x00, 0xf6, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2a, 0x01, 0x12, 0x04, 0xf5, 0x03, 0x08, 0x14, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x2b, 0x12, 0x06, 0xf8, 0x03, 0x00, 0xfa, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x2b, 0x01, 0x12, 0x04, 0xf8, 0x03, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x00,
    0x12, 0x04, 0xf9, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xf9, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xf9, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf9,
    0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf9, 0x03,
    0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2c, 0x12, 0x06, 0xfc, 0x03, 0x00, 0xfe, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2c, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x08, 0x21, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2c, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x03, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xfd, 0x03, 0x11, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xfd, 0x03, 0x29, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xfd, 0x03, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2d, 0x12, 0x06, 0x80,
    0x04, 0x00, 0x82, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2d, 0x01, 0x12, 0x04, 0x80, 0x04,
    0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x00, 0x12, 0x04, 0x81, 0x04, 0x08, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x04, 0x12, 0x04, 0x81, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x05, 0x12, 0x04, 0x81, 0x04, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x04, 0x16, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2d, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81, 0x04, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x2e, 0x12, 0x06, 0x84, 0x04, 0x00, 0x89, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2e,
    0x01, 0x12, 0x04, 0x84, 0x04, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x00, 0x12,
    0x04, 0x85, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x85, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x85,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x04,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x04, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x01, 0x12, 0x04, 0x86, 0x04, 0x08, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x04, 0x12, 0x04, 0x86, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x05, 0x12, 0x04, 0x86, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2e, 0x02, 0x01, 0x01, 0x12, 0x04, 0x86, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2e, 0x02, 0x01, 0x03, 0x12, 0x04, 0x86, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x2e, 0x02, 0x02, 0x12, 0x04, 0x87, 0x04, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x87, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02,
    0x05, 0x12, 0x04, 0x87, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x01,
    0x12, 0x04, 0x87, 0x04, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x03, 0x12,
    0x04, 0x87, 0x04, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x03, 0x12, 0x04, 0x88,
    0x04, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x04, 0x12, 0x04, 0x88, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x05, 0x12, 0x04, 0x88, 0x04, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x01, 0x12, 0x04, 0x88, 0x04, 0x18, 0x2d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x03, 0x12, 0x04, 0x88, 0x04, 0x30, 0x31, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x2f, 0x12, 0x06, 0x8b, 0x04, 0x00, 0x8d, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x2f, 0x01, 0x12, 0x04, 0x8b, 0x04, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f,
    0x02, 0x00, 0x12, 0x04, 0x8c, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x8c, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x8c, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x8c, 0x04, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x8c, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x30, 0x12, 0x06, 0x8f, 0x04, 0x00, 0x91,
    0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x30, 0x01, 0x12, 0x04, 0x8f, 0x04, 0x08, 0x1a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x00, 0x12, 0x04, 0x90, 0x04, 0x08, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x30, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x30, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x30, 0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x04, 0x16, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x90, 0x04, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x31, 0x12,
    0x06, 0x93, 0x04, 0x00, 0x9d, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x31, 0x01, 0x12, 0x04,
    0x93, 0x04, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x00, 0x12, 0x04, 0x94, 0x04,
    0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x04, 0x17, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x04, 0x2a, 0x2b, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x31, 0x02, 0x01, 0x12, 0x04, 0x95, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x31, 0x02, 0x01, 0x04, 0x12, 0x04, 0x95, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x31, 0x02, 0x01, 0x05, 0x12, 0x04, 0x95, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x95, 0x04, 0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x95, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x02,
    0x12, 0x04, 0x96, 0x04, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x96, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x02, 0x05, 0x12, 0x04,
    0x96, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x02, 0x01, 0x12, 0x04, 0x96,
    0x04, 0x16, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x02, 0x03, 0x12, 0x04, 0x96, 0x04,
    0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x03, 0x12, 0x04, 0x97, 0x04, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x03, 0x04, 0x12, 0x04, 0x97, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x03, 0x05, 0x12, 0x04, 0x97, 0x04, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x31, 0x02, 0x03, 0x01, 0x12, 0x04, 0x97, 0x04, 0x18, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x31, 0x02, 0x03, 0x03, 0x12, 0x04, 0x97, 0x04, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x31, 0x02, 0x04, 0x12, 0x04, 0x98, 0x04, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31,
    0x02, 0x04, 0x04, 0x12, 0x04, 0x98, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02,
    0x04, 0x05, 0x12, 0x04, 0x98, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x04,
    0x01, 0x12, 0x04, 0x98, 0x04, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x04, 0x03,
    0x12, 0x04, 0x98, 0x04, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x05, 0x12, 0x04,
    0x99, 0x04, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x05, 0x04, 0x12, 0x04, 0x99,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x05, 0x05, 0x12, 0x04, 0x99, 0x04,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x05, 0x01, 0x12, 0x04, 0x99, 0x04, 0x18,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x05, 0x03, 0x12, 0x04, 0x99, 0x04, 0x28, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x06, 0x12, 0x04, 0x9a, 0x04, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x31, 0x02, 0x06, 0x04, 0x12, 0x04, 0x9a, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x31, 0x02, 0x06, 0x05, 0x12, 0x04, 0x9a, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x31, 0x02, 0x06, 0x01, 0x12, 0x04, 0x9a, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x31, 0x02, 0x06, 0x03, 0x12, 0x04, 0x9a, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31,
    0x02, 0x07, 0x12, 0x04, 0x9b, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x07,
    0x04, 0x12, 0x04, 0x9b, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x07, 0x05,
    0x12, 0x04, 0x9b, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x07, 0x01, 0x12,
    0x04, 0x9b, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x07, 0x03, 0x12, 0x04,
    0x9b, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x08, 0x12, 0x04, 0x9c, 0x04,
    0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x08, 0x04, 0x12, 0x04, 0x9c, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x08, 0x05, 0x12, 0x04, 0x9c, 0x04, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x08, 0x01, 0x12, 0x04, 0x9c, 0x04, 0x18, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x08, 0x03, 0x12, 0x04, 0x9c, 0x04, 0x29, 0x2a, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x32, 0x12, 0x06, 0x9f, 0x04, 0x00, 0xb7, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x32, 0x01, 0x12, 0x04, 0x9f, 0x04, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02,
    0x00, 0x12, 0x04, 0xa0, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa0, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xa0, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa0, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0,
    0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x08,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa1, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa1, 0x04, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x17, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa1, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x32, 0x02, 0x02, 0x12, 0x04, 0xa2, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x32, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa2, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xa2, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xa2, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x03, 0x12,
    0x04, 0xa3, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xa3, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa3,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa3, 0x04,
    0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa3, 0x04, 0x25,
    0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x04, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa4, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x04, 0x05, 0x12, 0x04, 0xa4, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x32, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa4, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x32, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa4, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x32, 0x02, 0x05, 0x12, 0x04, 0xa5, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x05, 0x04, 0x12, 0x04, 0xa5, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xa5, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xa5, 0x04, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xa5, 0x04, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x06, 0x12, 0x04, 0xa6,
    0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x06, 0x04, 0x12, 0x04, 0xa6, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x06, 0x05, 0x12, 0x04, 0xa6, 0x04, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x06, 0x01, 0x12, 0x04, 0xa6, 0x04, 0x18, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x06, 0x03, 0x12, 0x04, 0xa6, 0x04, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x07, 0x12, 0x04, 0xa7, 0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x32, 0x02, 0x07, 0x04, 0x12, 0x04, 0xa7, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x32, 0x02, 0x07, 0x05, 0x12, 0x04, 0xa7, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x32, 0x02, 0x07, 0x01, 0x12, 0x04, 0xa7, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x07, 0x03, 0x12, 0x04, 0xa7, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02,
    0x08, 0x12, 0x04, 0xa8, 0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xa8, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x08, 0x05, 0x12,
    0x04, 0xa8, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xa8, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x08, 0x03, 0x12, 0x04, 0xa8,
    0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x09, 0x12, 0x04, 0xa9, 0x04, 0x08,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x09, 0x04, 0x12, 0x04, 0xa9, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x09, 0x05, 0x12, 0x04, 0xa9, 0x04, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x09, 0x01, 0x12, 0x04, 0xa9, 0x04, 0x18, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x09, 0x03, 0x12, 0x04, 0xa9, 0x04, 0x26, 0x28, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x32, 0x02, 0x0a, 0x12, 0x04, 0xaa, 0x04, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x32, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xaa, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x0a, 0x05, 0x12, 0x04, 0xaa, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x0a, 0x01, 0x12, 0x04, 0xaa, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0a,
    0x03, 0x12, 0x04, 0xaa, 0x04, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x0b, 0x12,
    0x04, 0xab, 0x04, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0b, 0x04, 0x12, 0x04,
    0xab, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xab,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xab, 0x04,
    0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xab, 0x04, 0x22,
    0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x0c, 0x12, 0x04, 0xac, 0x04, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xac, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xac, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x32, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xac, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x32, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xac, 0x04, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x32, 0x02, 0x0d, 0x12, 0x04, 0xad, 0x04, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x0d, 0x04, 0x12, 0x04, 0xad, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0d,
    0x05, 0x12, 0x04, 0xad, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0d, 0x01,
    0x12, 0x04, 0xad, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0d, 0x03, 0x12,
    0x04, 0xad, 0x04, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x0e, 0x12, 0x04, 0xae,
    0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xae, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xae, 0x04, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xae, 0x04, 0x18, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xae, 0x04, 0x21, 0x23, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x0f, 0x12, 0x04, 0xaf, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x32, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xaf, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x32, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xaf, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x32, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xaf, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x0f, 0x03, 0x12, 0x04, 0xaf, 0x04, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02,
    0x10, 0x12, 0x04, 0xb0, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x10, 0x04,
    0x12, 0x04, 0xb0, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x10, 0x05, 0x12,
    0x04, 0xb0, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x10, 0x01, 0x12, 0x04,
    0xb0, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x10, 0x03, 0x12, 0x04, 0xb0,
    0x04, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x11, 0x12, 0x04, 0xb1, 0x04, 0x08,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x11, 0x04, 0x12, 0x04, 0xb1, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x11, 0x05, 0x12, 0x04, 0xb1, 0x04, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x11, 0x01, 0x12, 0x04, 0xb1, 0x04, 0x18, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x11, 0x03, 0x12, 0x04, 0xb1, 0x04, 0x25, 0x27, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x32, 0x02, 0x12, 0x12, 0x04, 0xb2, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x32, 0x02, 0x12, 0x04, 0x12, 0x04, 0xb2, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x12, 0x05, 0x12, 0x04, 0xb2, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x12, 0x01, 0x12, 0x04, 0xb2, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x12,
    0x03, 0x12, 0x04, 0xb2, 0x04, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x13, 0x12,
    0x04, 0xb3, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x13, 0x04, 0x12, 0x04,
    0xb3, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x13, 0x05, 0x12, 0x04, 0xb3,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x13, 0x01, 0x12, 0x04, 0xb3, 0x04,
    0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x13, 0x03, 0x12, 0x04, 0xb3, 0x04, 0x25,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x14, 0x12, 0x04, 0xb4, 0x04, 0x08, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x14, 0x04, 0x12, 0x04, 0xb4, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x32, 0x02, 0x14, 0x05, 0x12, 0x04, 0xb4, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x32, 0x02, 0x14, 0x01, 0x12, 0x04, 0xb4, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x32, 0x02, 0x14, 0x03, 0x12, 0x04, 0xb4, 0x04, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x32, 0x02, 0x15, 0x12, 0x04, 0xb5, 0x04, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x15, 0x04, 0x12, 0x04, 0xb5, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x15,
    0x05, 0x12, 0x04, 0xb5, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x15, 0x01,
    0x12, 0x04, 0xb5, 0x04, 0x18, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x15, 0x03, 0x12,
    0x04, 0xb5, 0x04, 0x2c, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x32, 0x02, 0x16, 0x12, 0x04, 0xb6,
    0x04, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x16, 0x04, 0x12, 0x04, 0xb6, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x16, 0x05, 0x12, 0x04, 0xb6, 0x04, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x16, 0x01, 0x12, 0x04, 0xb6, 0x04, 0x18, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x16, 0x03, 0x12, 0x04, 0xb6, 0x04, 0x27, 0x29, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x33, 0x12, 0x06, 0xb9, 0x04, 0x00, 0xc0, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x33, 0x01, 0x12, 0x04, 0xb9, 0x04, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33,
    0x02, 0x00, 0x12, 0x04, 0xba, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xba, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xba, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xba, 0x04, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xba, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x04,
    0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbb, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbb, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbb, 0x04, 0x17, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbb, 0x04, 0x2a, 0x2b, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x33, 0x02, 0x02, 0x12, 0x04, 0xbc, 0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbc, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x33, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbc, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xbc, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x03,
    0x12, 0x04, 0xbd, 0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xbd, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xbd, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x01, 0x12, 0x04, 0xbd,
    0x04, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03, 0x03, 0x12, 0x04, 0xbd, 0x04,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x04, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x04, 0x12, 0x04, 0xbe, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x05, 0x12, 0x04, 0xbe, 0x04, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x01, 0x12, 0x04, 0xbe, 0x04, 0x17, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x04, 0x03, 0x12, 0x04, 0xbe, 0x04, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x33, 0x02, 0x05, 0x12, 0x04, 0xbf, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xbf, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xbf, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xbf, 0x04, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xbf, 0x04, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x34, 0x12, 0x06, 0xc2, 0x04,
    0x00, 0xc5, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x34, 0x01, 0x12, 0x04, 0xc2, 0x04, 0x08,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x04, 0x08, 0x2b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc3, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x34, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc3, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x34, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc3, 0x04, 0x16, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x34, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x34, 0x02, 0x01, 0x12, 0x04, 0xc4, 0x04, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xc4, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xc4, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xc4, 0x04, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xc4, 0x04, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x35, 0x12, 0x06, 0xc7, 0x04, 0x00,
    0xc9, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x35, 0x01, 0x12, 0x04, 0xc7, 0x04, 0x08, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x35, 0x02, 0x00, 0x12, 0x04, 0xc8, 0x04, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc8, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x35, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc8, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x35, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc8, 0x04, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x35, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc8, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x36,
    0x12, 0x06, 0xcb, 0x04, 0x00, 0xd2, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x36, 0x01, 0x12,
    0x04, 0xcb, 0x04, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x00, 0x12, 0x04, 0xcc,
    0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcc, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcc, 0x04, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcc, 0x04, 0x17, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcc, 0x04, 0x2a, 0x2b, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x04, 0x08, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x36, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x36, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcd, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x36, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x04, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xcd, 0x04, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02,
    0x02, 0x12, 0x04, 0xce, 0x04, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xce, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xce, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xce, 0x04, 0x18, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x03, 0x12, 0x04, 0xce,
    0x04, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x03, 0x12, 0x04, 0xcf, 0x04, 0x08,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x03, 0x04, 0x12, 0x04, 0xcf, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x03, 0x05, 0x12, 0x04, 0xcf, 0x04, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x03, 0x01, 0x12, 0x04, 0xcf, 0x04, 0x18, 0x29, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x36, 0x02, 0x03, 0x03, 0x12, 0x04, 0xcf, 0x04, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x36, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x36, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd0, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xd0, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xd0, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xd0, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x05, 0x12,
    0x04, 0xd1, 0x04, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xd1, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd1,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd1, 0x04,
    0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd1, 0x04, 0x20,
    0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x37, 0x12, 0x06, 0xd4, 0x04, 0x00, 0xd7, 0x04, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x37, 0x01, 0x12, 0x04, 0xd4, 0x04, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x37, 0x02, 0x00, 0x12, 0x04, 0xd5, 0x04, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xd5, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd5, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd5, 0x04, 0x16, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xd5, 0x04, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x01, 0x12, 0x04,
    0xd6, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd6,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd6, 0x04,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd6, 0x04, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd6, 0x04, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x38, 0x12, 0x06, 0xd9, 0x04, 0x00, 0xdc, 0x04, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x38, 0x01, 0x12, 0x04, 0xd9, 0x04, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x38, 0x02, 0x00, 0x12, 0x04, 0xda, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xda, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xda, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xda, 0x04, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xda, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x38, 0x02, 0x01, 0x12, 0x04, 0xdb,
    0x04, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdb, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdb, 0x04, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdb, 0x04, 0x16, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdb, 0x04, 0x27, 0x28, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x39, 0x12, 0x06, 0xde, 0x04, 0x00, 0xe0, 0x04, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x39, 0x01, 0x12, 0x04, 0xde, 0x04, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x39,
    0x02, 0x00, 0x12, 0x04, 0xdf, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xdf, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xdf, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xdf, 0x04, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xdf, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3a, 0x12, 0x06, 0xe2, 0x04, 0x00, 0xe5,
    0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3a, 0x01, 0x12, 0x04, 0xe2, 0x04, 0x08, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x00, 0x12, 0x04, 0xe3, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe3, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe3, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe3, 0x04, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe3, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02,
    0x01, 0x12, 0x04, 0xe4, 0x04, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xe4, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xe4, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xe4, 0x04, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe4,
    0x04, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3b, 0x12, 0x06, 0xe7, 0x04, 0x00, 0xe9, 0x04,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3b, 0x01, 0x12, 0x04, 0xe7, 0x04, 0x08, 0x18, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x3b, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe8, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe8, 0x04, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe8, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3c, 0x12, 0x06,
    0xeb, 0x04, 0x00, 0xed, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3c, 0x01, 0x12, 0x04, 0xeb,
    0x04, 0x08, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3c, 0x02, 0x00, 0x12, 0x04, 0xec, 0x04, 0x08,
    0x51, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xec, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xec, 0x04, 0x11, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xec, 0x04, 0x22, 0x2a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xec, 0x04, 0x2d, 0x2e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3c, 0x02, 0x00, 0x08, 0x12, 0x04, 0xec, 0x04, 0x2f, 0x50, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3c, 0x02, 0x00, 0x07, 0x12, 0x04, 0xec, 0x04, 0x3a, 0x4f, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x3d, 0x12, 0x06, 0xef, 0x04, 0x00, 0xf0, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3d, 0x01,
    0x12, 0x04, 0xef, 0x04, 0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3e, 0x12, 0x06, 0xf2, 0x04,
    0x00, 0xf4, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3e, 0x01, 0x12, 0x04, 0xf2, 0x04, 0x08,
    0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3e, 0x02, 0x00, 0x12, 0x04, 0xf3, 0x04, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf3, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf3, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf3, 0x04, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf3, 0x04, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x3f, 0x12, 0x06, 0xf6, 0x04, 0x00, 0xf8, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3f, 0x01,
    0x12, 0x04, 0xf6, 0x04, 0x08, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02, 0x00, 0x12, 0x04,
    0xf7, 0x04, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf7,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf7, 0x04,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf7, 0x04, 0x18,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf7, 0x04, 0x30, 0x31,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x40, 0x12, 0x06, 0xfa, 0x04, 0x00, 0xfc, 0x04, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x40, 0x01, 0x12, 0x04, 0xfa, 0x04, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x40, 0x02, 0x00, 0x12, 0x04, 0xfb, 0x04, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xfb, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xfb, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xfb, 0x04, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xfb, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x41, 0x12, 0x06, 0xfe, 0x04, 0x00,
    0x80, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x41, 0x01, 0x12, 0x04, 0xfe, 0x04, 0x08, 0x1a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x41, 0x02, 0x00, 0x12, 0x04, 0xff, 0x04, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x04, 0x12, 0x04, 0xff, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x41, 0x02, 0x00, 0x05, 0x12, 0x04, 0xff, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x41, 0x02, 0x00, 0x01, 0x12, 0x04, 0xff, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x41, 0x02, 0x00, 0x03, 0x12, 0x04, 0xff, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x42,
    0x12, 0x06, 0x82, 0x05, 0x00, 0x86, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x42, 0x01, 0x12,
    0x04, 0x82, 0x05, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x00, 0x12, 0x04, 0x83,
    0x05, 0x08, 0x49, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x05,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x06, 0x12, 0x04, 0x83, 0x05, 0x11,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x05, 0x1f, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x05, 0x28, 0x29, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x08, 0x12, 0x04, 0x83, 0x05, 0x2a, 0x48, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x07, 0x12, 0x04, 0x83, 0x05, 0x35, 0x47, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x42, 0x02, 0x01, 0x12, 0x04, 0x84, 0x05, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x42, 0x02, 0x01, 0x04, 0x12, 0x04, 0x84, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x84, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x84, 0x05, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x84, 0x05, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x02, 0x12,
    0x04, 0x85, 0x05, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x04, 0x12, 0x04,
    0x85, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x05, 0x12, 0x04, 0x85,
    0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x01, 0x12, 0x04, 0x85, 0x05,
    0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x03, 0x12, 0x04, 0x85, 0x05, 0x23,
    0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x43, 0x12, 0x06, 0x88, 0x05, 0x00, 0x8c, 0x05, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x43, 0x01, 0x12, 0x04, 0x88, 0x05, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x43, 0x02, 0x00, 0x12, 0x04, 0x89, 0x05, 0x08, 0x49, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x89, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02,
    0x00, 0x06, 0x12, 0x04, 0x89, 0x05, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x89, 0x05, 0x1f, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x89, 0x05, 0x28, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x00, 0x08, 0x12,
    0x04, 0x89, 0x05, 0x2a, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x00, 0x07, 0x12, 0x04,
    0x89, 0x05, 0x35, 0x47, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x43, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x05,
    0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8a, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8a, 0x05, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x05, 0x18, 0x1d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8a, 0x05, 0x20, 0x21, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x43, 0x02, 0x02, 0x12, 0x04, 0x8b, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x43, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8b, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x43, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8b, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43,
    0x02, 0x02, 0x01, 0x12, 0x04, 0x8b, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x8b, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x44, 0x12, 0x06,
    0x8e, 0x05, 0x00, 0x91, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x44, 0x01, 0x12, 0x04, 0x8e,
    0x05, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x44, 0x02, 0x00, 0x12, 0x04, 0x8f, 0x05, 0x08,
    0x56, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8f, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8f, 0x05, 0x11, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8f, 0x05, 0x24, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8f, 0x05, 0x2f, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x44, 0x02, 0x00, 0x08, 0x12, 0x04, 0x8f, 0x05, 0x31, 0x55, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x44, 0x02, 0x00, 0x07, 0x12, 0x04, 0x8f, 0x05, 0x3c, 0x54, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x44, 0x02, 0x01, 0x12, 0x04, 0x90, 0x05, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x90, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x90, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x90, 0x05, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x90, 0x05, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x45, 0x12, 0x06, 0x93, 0x05, 0x00,
    0xa0, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x45, 0x01, 0x12, 0x04, 0x93, 0x05, 0x08, 0x13,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x00, 0x12, 0x04, 0x94, 0x05, 0x08, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x45, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x45, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x45, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x05, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x45, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x05, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45,
    0x02, 0x01, 0x12, 0x04, 0x95, 0x05, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x95, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x95, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x95, 0x05, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x01, 0x03, 0x12, 0x04,
    0x95, 0x05, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x02, 0x12, 0x04, 0x96, 0x05,
    0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x04, 0x12, 0x04, 0x96, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x06, 0x12, 0x04, 0x96, 0x05, 0x11, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x01, 0x12, 0x04, 0x96, 0x05, 0x1e, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x03, 0x12, 0x04, 0x96, 0x05, 0x27, 0x28, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x45, 0x02, 0x03, 0x12, 0x04, 0x97, 0x05, 0x08, 0x58, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x45, 0x02, 0x03, 0x04, 0x12, 0x04, 0x97, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x45, 0x02, 0x03, 0x06, 0x12, 0x04, 0x97, 0x05, 0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45,
    0x02, 0x03, 0x01, 0x12, 0x04, 0x97, 0x05, 0x25, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02,
    0x03, 0x03, 0x12, 0x04, 0x97, 0x05, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x03,
    0x08, 0x12, 0x04, 0x97, 0x05, 0x30, 0x57, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x03, 0x07,
    0x12, 0x04, 0x97, 0x05, 0x3b, 0x56, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x04, 0x12, 0x04,
    0x98, 0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x04, 0x04, 0x12, 0x04, 0x98,
    0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x04, 0x05, 0x12, 0x04, 0x98, 0x05,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x04, 0x01, 0x12, 0x04, 0x98, 0x05, 0x17,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x04, 0x03, 0x12, 0x04, 0x98, 0x05, 0x2b, 0x2c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x05, 0x12, 0x04, 0x99, 0x05, 0x08, 0x2f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x45, 0x02, 0x05, 0x04, 0x12, 0x04, 0x99, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x45, 0x02, 0x05, 0x05, 0x12, 0x04, 0x99, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x45, 0x02, 0x05, 0x01, 0x12, 0x04, 0x99, 0x05, 0x17, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x45, 0x02, 0x05, 0x03, 0x12, 0x04, 0x99, 0x05, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45,
    0x02, 0x06, 0x12, 0x04, 0x9a, 0x05, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x06,
    0x04, 0x12, 0x04, 0x9a, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x06, 0x05,
    0x12, 0x04, 0x9a, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x06, 0x01, 0x12,
    0x04, 0x9a, 0x05, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x06, 0x03, 0x12, 0x04,
    0x9a, 0x05, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x07, 0x12, 0x04, 0x9b, 0x05,
    0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x07, 0x04, 0x12, 0x04, 0x9b, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x07, 0x05, 0x12, 0x04, 0x9b, 0x05, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x07, 0x01, 0x12, 0x04, 0x9b, 0x05, 0x17, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x07, 0x03, 0x12, 0x04, 0x9b, 0x05, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x45, 0x02, 0x08, 0x12, 0x04, 0x9c, 0x05, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x45, 0x02, 0x08, 0x04, 0x12, 0x04, 0x9c, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x45, 0x02, 0x08, 0x05, 0x12, 0x04, 0x9c, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45,
    0x02, 0x08, 0x01, 0x12, 0x04, 0x9c, 0x05, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02,
    0x08, 0x03, 0x12, 0x04, 0x9c, 0x05, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x09,
    0x12, 0x04, 0x9d, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x09, 0x04, 0x12,
    0x04, 0x9d, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x09, 0x05, 0x12, 0x04,
    0x9d, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x09, 0x01, 0x12, 0x04, 0x9d,
    0x05, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x09, 0x03, 0x12, 0x04, 0x9d, 0x05,
    0x28, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x0a, 0x12, 0x04, 0x9e, 0x05, 0x08, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x0a, 0x04, 0x12, 0x04, 0x9e, 0x05, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x9e, 0x05, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x45, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x9e, 0x05, 0x17, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x45, 0x02, 0x0a, 0x03, 0x12, 0x04, 0x9e, 0x05, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x45, 0x02, 0x0b, 0x12, 0x04, 0x9f, 0x05, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45,
    0x02, 0x0b, 0x04, 0x12, 0x04, 0x9f, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02,
    0x0b, 0x05, 0x12, 0x04, 0x9f, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x0b,
    0x01, 0x12, 0x04, 0x9f, 0x05, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x0b, 0x03,
    0x12, 0x04, 0x9f, 0x05, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x46, 0x12, 0x06, 0xa2, 0x05,
    0x00, 0xa7, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x46, 0x01, 0x12, 0x04, 0xa2, 0x05, 0x08,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02, 0x00, 0x12, 0x04, 0xa3, 0x05, 0x08, 0x52, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa3, 0x05, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x46, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa3, 0x05, 0x11, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x46, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x05, 0x28, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x46, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x05, 0x34, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x46, 0x02, 0x00, 0x08, 0x12, 0x04, 0xa3, 0x05, 0x36, 0x51, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46,
    0x02, 0x00, 0x07, 0x12, 0x04, 0xa3, 0x05, 0x41, 0x50, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02,
    0x01, 0x12, 0x04, 0xa4, 0x05, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xa4, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xa4, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xa4, 0x05, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa4,
    0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02, 0x02, 0x12, 0x04, 0xa5, 0x05, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa5, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa5, 0x05, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x05, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x46, 0x02, 0x03, 0x12, 0x04, 0xa6, 0x05, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x46, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa6, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xa6, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xa6, 0x05, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xa6, 0x05, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x47, 0x12, 0x06, 0xa9,
    0x05, 0x00, 0xae, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x47, 0x01, 0x12, 0x04, 0xa9, 0x05,
    0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47, 0x02, 0x00, 0x12, 0x04, 0xaa, 0x05, 0x08, 0x55,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x04, 0x12, 0x04, 0xaa, 0x05, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x06, 0x12, 0x04, 0xaa, 0x05, 0x11, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaa, 0x05, 0x25, 0x2e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x47, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaa, 0x05, 0x31, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x47, 0x02, 0x00, 0x08, 0x12, 0x04, 0xaa, 0x05, 0x33, 0x54, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x47, 0x02, 0x00, 0x07, 0x12, 0x04, 0xaa, 0x05, 0x3e, 0x53, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47,
    0x02, 0x01, 0x12, 0x04, 0xab, 0x05, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xab, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xab, 0x05, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xab, 0x05, 0x1e, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xab, 0x05, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47, 0x02, 0x02, 0x12, 0x04, 0xac, 0x05,
    0x08, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x04, 0x12, 0x04, 0xac, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x06, 0x12, 0x04, 0xac, 0x05, 0x11, 0x2c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x01, 0x12, 0x04, 0xac, 0x05, 0x2d, 0x3e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x03, 0x12, 0x04, 0xac, 0x05, 0x41, 0x42, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x47, 0x02, 0x03, 0x12, 0x04, 0xad, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x47, 0x02, 0x03, 0x04, 0x12, 0x04, 0xad, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x47, 0x02, 0x03, 0x05, 0x12, 0x04, 0xad, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47,
    0x02, 0x03, 0x01, 0x12, 0x04, 0xad, 0x05, 0x17, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xad, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x48, 0x12, 0x06,
    0xb0, 0x05, 0x00, 0xb2, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x48, 0x01, 0x12, 0x04, 0xb0,
    0x05, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x00, 0x12, 0x04, 0xb1, 0x05, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb1, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb1, 0x05, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb1, 0x05, 0x17, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x48, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb1, 0x05, 0x24, 0x25, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x49, 0x12, 0x06, 0xb4, 0x05, 0x00, 0xb7, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x49, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x08, 0x0f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x00,
    0x12, 0x04, 0xb5, 0x05, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb5, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xb5, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb5,
    0x05, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5, 0x05,
    0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x05, 0x08, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb6, 0x05, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb6, 0x05, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb6, 0x05, 0x18, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x49, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb6, 0x05, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x4a, 0x12, 0x06, 0xb9, 0x05, 0x00, 0xbc, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4a,
    0x01, 0x12, 0x04, 0xb9, 0x05, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02, 0x00, 0x12,
    0x04, 0xba, 0x05, 0x08, 0x49, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xba, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x06, 0x12, 0x04, 0xba,
    0x05, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xba, 0x05,
    0x1f, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xba, 0x05, 0x26,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x08, 0x12, 0x04, 0xba, 0x05, 0x28, 0x48,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x07, 0x12, 0x04, 0xba, 0x05, 0x33, 0x47, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x05, 0x08, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbb, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbb, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbb, 0x05, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xbb, 0x05, 0x1e, 0x1f,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
